'use strict'

const implement = require('./adapter').implement
const EventMessage = require('./message/event')
const TransactionMessage = require('./message/transaction')
const TreeManager = require('./message/org/tree-manager')
const STATUS = require('./constant').STATUS
const system = require('./system')
// const utils = require('util')

let isInit = false

class TransactionHandler {
    constructor(transactionMessage, catInstance, threadMode) {
        this.message = transactionMessage
        this.cat = catInstance
        this.treeManager = catInstance.treeManager
        this.type = String(transactionMessage.type)
        this.name = String(transactionMessage.name)
        this.threadMode = threadMode
    }
    /**
     * 设置transaction状态
     * @param {string} status , STATUS
     */
    setStatus(status) {
        this.message.status = String(status)
    }
    /**
     * end a transaction.
     * @param {number} maxTime
     */
    complete(maxTime) {
        this.treeManager.endMessage(this.message, maxTime)
    }
    /**
     * Manually set a transaction name.
     * @param {string} name , see name.
     */
    setName(name) {
        this.message.name = String(name)
    }
    /**
     * Add data to a transaction.
     * 序列化成 query的形式 &key=value
     * 允许多次addData
     * @param {string} key , 如果value存在则作为key，否则作为完整的data
     * @param {string} [value]
     */
    addData(key, value) {
        let data = key = stringifyData(key)
        if (value !== undefined) {
            // kv形式
            data = data + '=' + stringifyData(value)
        }
        if (this.message.data) {
            this.message.data += '&' + data
        } else {
            this.message.data = data
        }
    }
    /**
     * logEvent , 同cat.logEvent , 但确保挂在此transaction下
     * */
    logEvent(type, name, status, data) {
        type = String(type)
        name = String(name)
        status = String(status)
        data = String(data)

        let message = this.message
        if (message.isEnd) {
            return this.cat.logEvent(type, name, status, data)
        } else {
            message.addChild(createEvent(type, name, status, data))
        }
    }

    /**
     * @param {string} type
     * @param {string} name
     */
    newTransaction(type, name, duration) {
        type = '' + type
        name = '' + name
        let message = new TransactionMessage({
            type: type,
            name: name,
            duration: duration
        })
        if (this.threadMode) {
            this.message.addChild(message)
        }
        return new TransactionHandler(message, this.cat, this.threadMode)
    }
    /**
     * logError , 同cat.logError , 但确保挂在此transaction下
     * */
    logError(name, error) {
        name = String(name)
        let message = this.message
        if (message.isEnd) {
            return this.cat.logError(name, error)
        } else {
            message.addChild(createError(name, error))
        }
    }
}
/**
 * Class Cat
 * 暴露给用户的API在这边，以这里的参数说明为准
 * */
class Cat {
    /**
     * @param {boolean} threadMode | 线程模式
     */
    constructor(threadMode) {
        this.threadMode = false
        if (threadMode === true) {
            this.threadMode = true
        }
        this.STATUS = STATUS
        this.treeManager = new TreeManager(implement, threadMode)
    }

    /**
     * @param {object} options
     *        {string} options.appName , octo cmdb上的应用名
     */
    init(options) {
        if (isInit) {
            return
        }
        isInit = true
        let logger = require('./logger')('index')
        options = options || {}
        logger.info('Cat Version : ' + require('../package').version)
        let appKey = options.appName
        if (!appKey) {
            logger.info('appName required')
            return
        }

        logger.info('Set AppName ' + appKey)
        implement.init(appKey)

        system.collectStart(this)
    }

    /**
     * @param {string} type 一级名称
     * @param {string} name  二级名称
     * @param {string} [status]  状态, 参见 STATUS
     * @param {string} [data]  数据
     */
    logEvent(type, name, status, data) {
        this.treeManager.addMessage(createEvent(type, name, status, data))
    }

    /**
    * @param {string} [name]
    * @param {Error} error
    */
    logError(name, error) {
        let nameTuple = createErrorNameAndStack(name, error)
        implement.logError(nameTuple.name, nameTuple.errStr)
    }
    /**
     * 同CatInterface
     * @param {string} type
     * @param {string} name
     */
    newTransaction(type, name, duration) {
        type = '' + type
        name = '' + name
        let message = new TransactionMessage({
            type: type,
            name: name,
            duration: duration
        })
        this.treeManager.addMessage(message)
        return new TransactionHandler(message, this, this.threadMode)
    }

    /**
     * metric api
     * 同java的logMetricForCount
     * @param {string} name
     * @param {number} [quantity]   默认1 , 必须是整数
     * @param {object} [tags]       默认null
     */
    logMetricForCount(name, quantity, tags) {
        name = '' + name
        let q = 1
        let t = null
        if (quantity) {
            let q1 = parseInt(quantity)
            if (q1) {
                q = q1
            } else {
                t = parseTags(quantity)
            }
        }
        if (tags) {
            let q1 = parseInt(quantity)
            q = q1 || 1
            t = parseTags(tags)
        }
        implement.logMetricForCount(name, q, t)
    }

    /**
     * metric api
     * 同java的logMetricForDuration
     * @param {*} name
     * @param {*} duration 单位毫秒
     * @param {*} [tags]
     */
    logMetricForDuration(name, duration, tags) {
        name = '' + name
        duration = +duration
        let t = null
        if (!duration) {
            return
        }
        if (tags) {
            t = parseTags(tags)
        }
        implement.logMetricForDuration(name, duration, t)
    }

    /**
     * 线程模式下，标记线程结束，发送所有的数据
     */
    complete() {
        if (this.threadMode) {
            this.treeManager.complete()
        }
    }
}

function createEvent(type, name, status, data) {
    type = '' + type
    name = '' + name
    data = stringifyData(data)
    status = status ? ('' + status) : STATUS.SUCCESS
    return new EventMessage({
        type: type,
        name: name,
        status: status,
        data: data
    })
}

function createErrorNameAndStack(name, error) {
    //  只传递一个参数，且为error对象时
    if (name instanceof Error) {
        error = name
        name = null
    }
    let stack = ''
    //  针对非标准error类支持以string的显示传递错误信息
    if (typeof error === 'string') {
        stack = error
    } else if (error instanceof Error) {
        stack = error.stack
    }
    name = name || (error && error.name) || 'Error'
    let errStr = name ? (name + ' ' + stack) : stack
    name = String(name)
    errStr = String(errStr)
    return {
        name: name,
        errStr: errStr
    }
}

function createError(name, error) {
    let nameTuple = createErrorNameAndStack(name, error)
    return createEvent('Error', nameTuple.name, 'ERROR', nameTuple.errStr)
}

function stringifyData(data) {
    if (data === undefined) {
        data = ''
    }
    if (typeof data !== 'string') {
        // 有data参数,但不是字符串
        try {
            data = JSON.stringify(data)
        } catch (e) {
            data = data.toString ? data.toString() : ''
        }
    }
    return data
}
function parseTags(tagMap) {
    let tags = {}
    try {
        for (let key in tagMap) {
            tags[key] = '' + tagMap[key]
        }
    } catch (e) {
        return null
    }
    return tags
}

module.exports = Cat
