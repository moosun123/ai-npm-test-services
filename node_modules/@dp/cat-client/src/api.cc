#include <napi.h>
#include "cat/client.h"
#include "message/message_imp.h"
#include "transaction_wrap.h"
using namespace std;

namespace catapi
{

// cat.init
void Init(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1) {
        Napi::TypeError::New(env, "Init appkey required").ThrowAsJavaScriptException();
    }

    Napi::String appkey = info[0].As<Napi::String>();
    Napi::String language = info[1].As<Napi::String>();
    Napi::String language_version = info[2].As<Napi::String>();

    std::string cppAppkey = appkey.Utf8Value();
    std::string cppLanguage = language.Utf8Value();
    std::string cppLanguageVersion = language_version.Utf8Value();

    const char* cAppkey = cppAppkey.c_str();
    const char* cLanguage = cppLanguage.c_str();
    const char* cLanguageVersion = cppLanguageVersion.c_str();

    catDisableHeartbeat();
    catSetLanguageBinding(cLanguage, cLanguageVersion);
    catClientInitWithSingleProcessModel();
    catClientInit(cAppkey);
}

void Destroy(const Napi::CallbackInfo& info) {
    catClientDestroy();
}

// cat.newTransaction
Napi::Object NewTransaction(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2) {
        Napi::TypeError::New(env, "NewTransaction type & name required").ThrowAsJavaScriptException();
        return Napi::Object();
    }

    if (!info[0].IsString() || !info[1].IsString()) {
        Napi::TypeError::New(env, "NewTransaction type & name must be string").ThrowAsJavaScriptException();
        return Napi::Object();
    }

    Napi::Object t = TransactionWrap::NewInstance(env, info[0], info[1]);
    if (env.IsExceptionPending()) {
        Napi::Error e = env.GetAndClearPendingException();
        return e.Value();
    }
    return t;
}


// logEvent not used
void LogEvent(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2) {
        Napi::TypeError::New(env, "LogEvent type & name required").ThrowAsJavaScriptException();
        return;
    }

    const int infoLength = info.Length();
    for (int i = 0; i < infoLength; i++) {
        if (!info[i].IsString()) {
            Napi::TypeError::New(env, "LogEvent args must be string").ThrowAsJavaScriptException();
            return;
        }
    }

    Napi::String eventType = info[0].As<Napi::String>();
    Napi::String eventName = info[1].As<Napi::String>();
    std::string cppEventType = eventType.Utf8Value();
    std::string cppEventName = eventName.Utf8Value();

    const char *status;
    const char *data;

    if (infoLength > 3) {
        Napi::String eventData = info[3].As<Napi::String>();
        std::string cppEventData = eventData.Utf8Value();
        data = cppEventData.c_str();
    } else {
        data = NULL;
    }

    if (infoLength > 2) {
        Napi::String eventStatus = info[2].As<Napi::String>();
        std::string cppEventStatus = eventStatus.Utf8Value();
        status = cppEventStatus.c_str();
    } else {
        status = CAT_SUCCESS;
    }

    const char* eType = cppEventType.c_str();
    const char* eName = cppEventName.c_str();

    logEvent(eType, eName, status, data);
}

// logError not used
void LogError(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2) {
        Napi::TypeError::New(env, "LogError msg & errStr required").ThrowAsJavaScriptException();
        return;
    }

    Napi::String errMsg = info[0].As<Napi::String>();
    Napi::String errStr = info[1].As<Napi::String>();
    std::string cppErrMsg = errMsg.Utf8Value();
    std::string cppErrStr = errStr.Utf8Value();

    const char* msg = cppErrMsg.c_str();
    const char* eStr = cppErrStr.c_str();

    logError(msg, eStr);
}

void InnerSendNode(const Napi::Env& env, const Napi::Object& node) {
    if (node.IsNull() || node.IsUndefined()) {
        return;
    }

    Napi::String messageType = node.Get("messageType").As<Napi::String>();
    std::string cppMessageType = messageType.Utf8Value();
    if (cppMessageType.compare("transaction") == 0) {
        Napi::String type = node.Get("type").As<Napi::String>();
        Napi::String name = node.Get("name").As<Napi::String>();
        Napi::String status = node.Get("status").As<Napi::String>();
        Napi::String data = node.Get("data").As<Napi::String>();
        Napi::Number beginTime = node.Get("beginTime").As<Napi::Number>();
        Napi::Number endTime = node.Get("endTime").As<Napi::Number>();

        std::string cppType = type.Utf8Value();
        std::string cppName = name.Utf8Value();
        std::string cppStatus = status.Utf8Value();
        std::string cppData = data.Utf8Value();

        const char* cType = cppType.c_str();
        const char* cName = cppName.c_str();
        CatTransaction *t = newTransaction(cType, cName);

        // set time
        CatTransactionInner *pInner = getInnerTrans((CatMessage *)t);
        CatMessageInner *mInner = getInnerMsg((CatMessage *)t);

        long long cBeginTime = beginTime.Int64Value();
        long long cEndTime = endTime.Int64Value();

        pInner->durationStartInNano = cBeginTime * 1000 * 1000;
        pInner->durationInMicro = (cEndTime - cBeginTime) * 1000;
        if (pInner->durationInMicro <= 0) {
            pInner->durationInMicro = 1;
        }
        mInner->timestampInMillis = cBeginTime;

        const char* cData = cppData.c_str();
        t->addData((CatMessage *)t, cData, "");

        // 深度优先
        Napi::Array messageTreeChildren = node.Get("children").As<Napi::Array>();
        int count = messageTreeChildren.Length();
        for (int i = 0; i < count; i++) {
            InnerSendNode(env, messageTreeChildren.Get(i).As<Napi::Object>());
        }

        const char* cStatus = cppStatus.c_str();
        t->setStatus((CatMessage *)t, cStatus);
        t->setComplete((CatMessage *)t);
    } else if (cppMessageType.compare("event") == 0) {
        Napi::String type = node.Get("type").As<Napi::String>();
        Napi::String name = node.Get("name").As<Napi::String>();
        Napi::String status = node.Get("status").As<Napi::String>();
        Napi::String data = node.Get("data").As<Napi::String>();
        Napi::Number beginTime = node.Get("beginTime").As<Napi::Number>();

        std::string cppType = type.Utf8Value();
        std::string cppName = name.Utf8Value();
        std::string cppStatus = status.Utf8Value();
        std::string cppData = data.Utf8Value();

        const char* cType = cppType.c_str();
        const char* cName = cppName.c_str();
        const char* cStatus = cppStatus.c_str();
        const char* cData = cppData.c_str();
        long long cBeginTime = beginTime.Int64Value();

        logEventWithTime(cType, cName, cStatus, cData, cBeginTime);
    } else if (cppMessageType.compare("heartbeat") == 0) {
        Napi::String type = node.Get("type").As<Napi::String>();
        Napi::String name = node.Get("name").As<Napi::String>();
        Napi::String data = node.Get("data").As<Napi::String>();

        std::string cppType = type.Utf8Value();
        std::string cppName = name.Utf8Value();
        std::string cppData = data.Utf8Value();

        const char* cType = cppType.c_str();
        const char* cName = cppName.c_str();
        const char* cData = cppData.c_str();

        CatHeartBeat *h = newHeartBeat(cType, cName);
        h->addDataPair(h, cData);
        h->setStatus(h, CAT_SUCCESS);
        h->setComplete((CatMessage *)h);
    }
}

// send tree
void SendTree(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() == 0) {
        Napi::TypeError::New(env, "SendTree msg & errStr required").ThrowAsJavaScriptException();
        return;
    }

    Napi::Object tree = info[0].As<Napi::Object>();
    Napi::Object treeRoot = tree.Get("root").As<Napi::Object>();

    InnerSendNode(env, treeRoot);
}

// logMetricForCount
void LogMetricForCount(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1) {
        Napi::TypeError::New(env, "LogMetricForCount arguments required").ThrowAsJavaScriptException();
        return;
    }

    Napi::String metricName = info[0].As<Napi::String>();
    std::string cppMetricName = metricName.Utf8Value();
    const char* mName = cppMetricName.c_str();
    if (info.Length() == 1) {
        logMetricForCount(mName);
    }

    if (info.Length() == 2) {
        Napi::Number metricCount = info[1].As<Napi::Number>();
        int quantity = metricCount.Int32Value();

        logMetricForCountQuantity(mName, quantity);
    }

    if (info.Length() == 3) {
        Napi::Number metricCount = info[1].As<Napi::Number>();
        int quantity = metricCount.Int32Value();

        CatMetricHelper *pHelper = CatBuildMetricHelper(mName);
        Napi::Object tags = info[2].As<Napi::Object>();
        Napi::Array keys = tags.GetPropertyNames();

        for (unsigned int i = 0; i < keys.Length(); i++) {
            Napi::String tag = keys.Get(i).As<Napi::String>();
            Napi::String value = tags.Get(tag).As<Napi::String>();

            std::string cppTag = tag.Utf8Value();
            std::string cppValue = value.Utf8Value();

            const char* cTag = cppTag.c_str();
            const char* cValue = cppValue.c_str();

            pHelper->AddTag(pHelper, cTag, cValue);
        }

        pHelper->AddCount(pHelper, quantity);
    }
}

void LogMetricForDuration(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2) {
        Napi::TypeError::New(env, "LogMetricForDuration two arguments required").ThrowAsJavaScriptException();
        return;
    }
    Napi::String metricName = info[0].As<Napi::String>();
    std::string cppMetricName = metricName.Utf8Value();
    const char* mName = cppMetricName.c_str();

    if (info.Length() == 2) {
        Napi::Number metricDuration = info[1].As<Napi::Number>();
        unsigned long long duration = metricDuration.Int64Value();

        logMetricForDuration(mName, duration);
    } else if (info.Length() == 3) {
        Napi::Number metricDuration = info[1].As<Napi::Number>();
        unsigned long long duration = metricDuration.Int64Value();

        CatMetricHelper *pHelper = CatBuildMetricHelper(mName);
        Napi::Object tags = info[2].As<Napi::Object>();
        Napi::Array keys = tags.GetPropertyNames();

        for (unsigned int i = 0; i < keys.Length(); i++) {
            Napi::String tag = keys.Get(i).As<Napi::String>();
            Napi::String value = tags.Get(tag).As<Napi::String>();

            std::string cppTag = tag.Utf8Value();
            std::string cppValue = value.Utf8Value();

            const char* cTag = cppTag.c_str();
            const char* cValue = cppValue.c_str();

            pHelper->AddTag(pHelper, cTag, cValue);
        }

        pHelper->AddDuration(pHelper, duration);
    }
}

Napi::Object functionsInit(Napi::Env env, Napi::Object exports) {
    exports.Set("init", Napi::Function::New(env, Init));
    exports.Set("destroy", Napi::Function::New(env, Destroy));
    exports.Set("newTransaction", Napi::Function::New(env, NewTransaction));
    exports.Set("logEvent", Napi::Function::New(env, LogEvent));
    exports.Set("logError", Napi::Function::New(env, LogError));
    exports.Set("sendTree", Napi::Function::New(env, SendTree));
    exports.Set("logMetricForCount", Napi::Function::New(env, LogMetricForCount));
    exports.Set("logMetricForDuration", Napi::Function::New(env, LogMetricForDuration));

    return exports;
}

Napi::Object InitAll(Napi::Env env, Napi::Object exports) {
    functionsInit(env, exports);
    return TransactionWrap::Init(env, exports);
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, InitAll);

} // namespace catapi
