#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Author: stdrickforce (Tengyuan Fan)
# Email: <stdrickforce@gmail.com> <fantengyuan@meituan.com>

import logging
import os
import platform
import time

from .ccat import _, ffi

from .const import (
    ENCODER_BINARY,
    CAT_SUCCESS,
)

log = logging.getLogger()

__all__ = ['catSdk', 'catSdkCoroutine']


def load_ccat():
    path = os.path.dirname(os.path.abspath(__file__))
    # TODO Provide a musl-libc version to support alpine linux.
    if 'Linux' in platform.system():
        return ffi.dlopen(os.path.join(path, "lib/linux/libcatclient.so"))
    elif 'Darwin' in platform.system():
        return ffi.dlopen(os.path.join(path, "lib/darwin/libcatclient.dylib"))
    else:
        log.error("The Cat client can only run on the Linux/Darwin platform.")
    return


ccat = load_ccat()


class PyTransaction(object):

    def __init__(self, mtype, mname):
        self._mtype = mtype
        self._mname = mname
        self._status = CAT_SUCCESS
        self._data = ""
        self._start = time.time() * 1000

    def setStatus(self, t, status):
        self._status = status

    def addDataPair(self, t, data):
        if self._data == "":
            self._data = data
        else:
            self._data += "&" + data

    def addData(self, t, key, val):
        if self._data == "":
            self._data = "{}={}".format(key, val)
        else:
            self._data += "&{}={}".format(key, val)

    def setComplete(self, t):
        ccat.logTransaction(
            _(self._mtype),
            _(self._mname),
            _(self._status),
            _(self._data),
            self._duration_ms,
        )

    @property
    def _duration_ms(self):
        return int(time.time() * 1000 - self._start)


class _outdated_methods(object):

    def set_heartbeat_status(self, hb, status):
        pass

    def addHeartbeatDataPair(self, hb, data):
        pass

    def add_heartbeat_data_pair(self, hb, data):
        pass

    def complete_heartbeat(self, heartbeat):
        pass


class catSdk(_outdated_methods):

    def __init__(self, appkey, **kwargs):
        self.appkey = appkey
        self.__init_ccat(**kwargs)

    def __init_ccat(self, debug=False, logview=True, auto_init=False):
        self._logview = logview
        config = ffi.new("CatClientConfig*", [
            ENCODER_BINARY,         # encoder
            0,                      # heartbeat
            1,                      # sampling
            1,                      # multiprocessing
            1 if debug else 0,      # debug log
            1 if auto_init else 0,  # auto initialize
        ])
        ccat.catClientInitWithConfig(_(self.appkey), config)

    '''
    Transaction
    '''

    def new_transaction(self, type, name):
        if not self._logview:
            return PyTransaction(type, name)
        return ccat.newTransaction(_(type), _(name))

    def set_transaction_status(self, transaction, status):
        transaction.setStatus(transaction, _(status))

    def add_transaction_data_pair(self, transaction, data):
        transaction.addDataPair(transaction, _(data))

    def complete_transaction(self, transaction):
        transaction.setComplete(transaction)

    def log_batch_transaction(self, type, name, count, error, sum):
        ccat.logBatchTransaction(_(type), _(name), count, error, sum)

    '''
    Event
    '''

    def log_event(self, mtype, mname, status, nameValuePairs):
        ccat.logEvent(_(mtype), _(mname), _(status), _(nameValuePairs))

    def log_error(self, msg, err_stack):
        ccat.logError(_(msg), _(err_stack))

    def log_batch_event(self, type, name, count, error):
        ccat.logBatchEvent(_(type), _(name), count, error)

    '''
    Heartbeat
    '''

    def new_heartbeat(self, type, name):
        return ccat.newHeartBeat(_(type), _(name))

    def set_message_status(self, message, status):
        message.setStatus(message, _(status))

    def add_message_data_pair(self, message, data):
        message.addDataPair(message, _(data))

    def complete_message(self, message):
        message.setComplete(message)

    '''
    Metric
    '''

    def log_metric_for_count(self, name):
        ccat.logMetricForCount(_(name))

    def log_metric_for_duration(self, name, durationMs):
        ccat.logMetricForDuration(_(name), durationMs)

    def new_cat_build_metric_helper(self, name):
        return ccat.CatBuildMetricHelper(_(name))

    def add_metric_tag(self, helper, key, val):
        ccat.addMetricTag(helper, _(key), _(val))

    def add_mertic_name(self, helper, name):
        ccat.addMetricName(helper, _(name))

    def add_metric_count(self, helper, count):
        ccat.addMetricCount(helper, count)

    def add_metric_duration(self, helper, durationMs):
        ccat.addMetricDuration(helper, durationMs)

    '''
    Message id
    '''

    def create_message_id(self):
        mid = ccat.createMessageId()

        if mid is None:
            return ""
        else:
            return ffi.string(mid)

    def create_remote_server_message_id(self, domain):
        mid = ccat.createRemoteServerMessageId(_(domain))

        if mid is None:
            return ""
        else:
            return ffi.string(mid)

    def set_thread_local_message_tree_id(self, message_id, root_message_id, parent_message_id):
        ccat.setThreadLocalMessageTreeId(
            _(message_id),
            _(root_message_id),
            _(parent_message_id)
        )


class catSdkCoroutine(catSdk):
    pass
