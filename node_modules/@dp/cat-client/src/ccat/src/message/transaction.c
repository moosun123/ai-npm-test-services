#include <cat/client_config.h>
#include "cat/transaction.h"

#include "lib/cat_time_util.h"

#include "message_imp.h"

static void* emptyCall(CatMessage* m) {
    return NULL;
}

int isCatTransaction(CatMessage* message) {
    CatMessageInner* pInner = getInnerMsg(message);
    return pInner->h.msgType == CatMessageType_Trans;
}

int isCatEvent(CatMessage* message) {
    CatMessageInner* pInner = getInnerMsg(message);
    return pInner->h.msgType == CatMessageType_Event;
}

int isCatMetric(CatMessage* message) {
    CatMessageInner* pInner = getInnerMsg(message);
    return pInner->h.msgType == CatMessageType_Metric;
}

int isCatHeartBeat(CatMessage* message) {
    CatMessageInner* pInner = getInnerMsg(message);
    return pInner->h.msgType == CatMessageType_HeartBeat;
}

static void addChild(CatTransaction* message, CatMessage* childMsg) {
    CatTransactionInner* pInner = getInnerTrans(message);
    int pushRst = catStackPush(pInner->children, childMsg);
    if (CAT_STACK_ERR == pushRst) {
        g_config.logger->error("Transaction Add Child Error！%d", catStackSize(pInner->children));
    }
}

void* clearCatTransaction(CatMessage* message) {
    clearCatMessage(message);

    CatTransactionInner* pInner = getInnerTrans(message);
    CatMessage* pMessage = NULL;
    while (!isCatStackEmpty(pInner->children)) {
        int status = catStackPop(pInner->children, (void**)&pMessage);
        if (CAT_STACK_ERR == status) {
            break;
        }
        deleteCatMessage(pMessage);
    }

    catStackDestroy(&(pInner->children));
    return pInner;
}

static void setTransactionComplete(CatMessage* message) {
    CatTransactionInner* pInner = getInnerTrans(message);
    if (pInner->inner.isCompleted) {
        // do nothing.
    } else {
        if (pInner->durationInMicro == 0) {
            pInner->durationInMicro = GetTime64() * 1000 - pInner->durationStartInNano / 1000;
        }
        pInner->inner.isCompleted = 1;
        if (NULL != pInner->inner.flush) {
            pInner->inner.flush(message);
        }
    }
}

CatStack_T getCatTransactionChildren(CatTransaction* pSrcTrans) {
    CatTransactionInner* pInner = getInnerTrans(pSrcTrans);
    return pInner->children;
}

static void setDurationInMillis(CatTransaction* trans, unsigned long long durationMs) {
    setCatTransactionDurationUs(trans, durationMs * 1000);
}

static void setDurationStart(CatTransaction* trans, unsigned long long durationStartMs) {
    CatTransactionInner* pInner = getInnerTrans(trans);
    pInner->durationStartInNano = durationStartMs * 1000 * 1000;
}

CatTransaction* createCatTransaction(const char* type, const char* name, flusher flush) {
    CatTransactionInner* pTransInner = malloc(sizeof(CatTransaction) + sizeof(CatTransactionInner));
    if (pTransInner == NULL) {
        return NULL;
    }
    CatTransaction* pTrans = (CatTransaction*) (((char*) pTransInner + sizeof(CatTransactionInner)));

    initCatMessage((CatMessage*) pTrans, CatMessageType_Trans, type, name, flush);

    pTransInner->children = NULL;
    int status = newCatStack(128, &(pTransInner->children));
    if (status == CAT_STACK_ERR) {
        free(pTransInner);
        return NULL;
    }
    pTransInner->durationStartInNano = GetTime64() * 1000 * 1000;
    pTransInner->durationInMicro = 0;

    // overwrite message methods.
    pTrans->setComplete = setTransactionComplete;

    // define transaction specific methods.
    pTrans->addChild = addChild;
    pTrans->setDurationInMillis = setDurationInMillis;
    pTrans->setDurationStart = setDurationStart;

    pTrans->setStatus((CatMessage*) pTrans, CAT_SUCCESS); // status default success

    pTrans->clear = emptyCall;
    return pTrans;
}

unsigned long long getCatTransactionDurationUs(CatTransaction* trans) {
    CatTransactionInner* pInner = getInnerTrans(trans);

    if (pInner->durationInMicro > 0) {
        return pInner->durationInMicro;
    } else {
        unsigned long long tmpDuration = 0;
        size_t len = pInner->children == NULL ? 0 : catStackSize(pInner->children);

        if (len > 0 && pInner->children != NULL) {
            CatMessage* lastChild = NULL;
            catStackPeek(pInner->children, (void**)&lastChild);
            CatMessageInner* lastChildInner = getInnerMsg(lastChild);

            if (isCatTransaction(lastChild)) {
                CatTransactionInner* pInner = getInnerTrans(lastChild);
                tmpDuration = (lastChildInner->timestampInMillis - pInner->inner.timestampInMillis) * 1000 +
                              pInner->durationInMicro;
            } else {
                tmpDuration = (lastChildInner->timestampInMillis - pInner->inner.timestampInMillis) * 1000;
            }
        }
        return tmpDuration;
    }
}

CatTransaction* copyCatTransaction(CatTransaction* pSrcTrans) {
    CatTransactionInner* pSrcTransInner = getInnerTrans(pSrcTrans);
    CatTransaction* clonedTrans = createCatTransaction(
            pSrcTransInner->inner.type,
            pSrcTransInner->inner.name,
            pSrcTransInner->inner.flush
    );
    CatTransactionInner* clonedTransInner = getInnerTrans(clonedTrans);

    clonedTransInner->inner.timestampInMillis = pSrcTransInner->inner.timestampInMillis;
    clonedTransInner->durationInMicro = getCatTransactionDurationUs(pSrcTrans);
    clonedTransInner->inner.data = catsdsdup(pSrcTransInner->inner.data);
    return clonedTrans;
}