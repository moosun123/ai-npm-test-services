#include "transaction_helper.h"

#include "message_id.h"
#include "message_manager.h"
#include "message/message_imp.h"

#include "lib/cat_time_util.h"
#include "cat/event.h"

static void migrateMessage(CatStack_T *pStack, CatTransaction *source, CatTransaction *target, size_t level) {
    CatTransaction *current = NULL;
    int stackSize = catStackSize(pStack);
    if (level < stackSize) {
        catStackGetByIndex(pStack, stackSize - level - 1, (void**)&current);
    }
    int shouldKeep = 0;

    CatStack_T children = getCatTransactionChildren(source);
    size_t i = 0;
    for (i = 0; i < catStackSize(children); ++i) {
        CatMessage *pMsg = NULL;
        catStackGetByIndex(children, i, (void**)&pMsg);
        if (pMsg != (CatMessage *) current) {
            target->addChild(target, pMsg);
        } else {
            CatTransaction *clonedTrans = copyCatTransaction(current);
            clonedTrans->setStatus((CatMessage *) clonedTrans, CAT_SUCCESS);

            target->addChild(target, (CatMessage *) clonedTrans);
            migrateMessage(pStack, current, clonedTrans, level + 1);
            shouldKeep = 1;
        }
    }

    catStackClear(children);

    if (shouldKeep) { // add it back
        catStackPush(children, current);
    }
}

void truncateAndFlush(CatContext *context, unsigned long long timestampMs) {
    CatMessageTree *pRootMsg = context->tree;
    CatStack_T pStack = context->stack;
    CatMessage *message = pRootMsg->root;

    if (!isCatTransaction(message)) {
        return;
    }
    catsds id = pRootMsg->messageId;

    if (id == NULL) {
        id = getNextMessageId();
        pRootMsg->messageId = id;
    }
    catsds rootId = pRootMsg->rootMessageId;
    catsds childId = getNextMessageId();

    CatTransaction *source = (CatTransaction *) message;

    CatTransaction *target = copyCatTransaction(source);
    target->setStatus((CatMessage *) target, CAT_SUCCESS);

    migrateMessage(pStack, source, target, 1);

    int i;
    i = catStackSize(pStack) - 1;
    for (; i >= 0; --i) {
        CatTransaction *t = NULL;
        catStackGetByIndex(pStack, i, (void**)&t);
        CatTransactionInner *iInner = getInnerTrans(t);
        iInner->inner.timestampInMillis = timestampMs;
        iInner->durationStartInNano = GetTime64() * 1000 * 1000;
    }
    CatEvent *next = createEvent("RemoteCall", "Next", catMessageManagerAdd);

    next->addDataPair(next, childId);
    next->setStatus(next, CAT_SUCCESS);
    target->addChild(target, next);

    // tree is the parent, and m_tree is the child.
    CatMessageTree *pCp = duplicateCatMessageTree(pRootMsg);

    pCp->root = (CatMessage *) target;

    pRootMsg->messageId = childId;

    if (pRootMsg->parentMessageId != NULL) {
        catsdsfree(pRootMsg->parentMessageId);
    }

    pRootMsg->parentMessageId = id;
    pRootMsg->rootMessageId = (rootId != NULL ? rootId : catsdsdup(id));

    context->elementSize = catStackSize(pStack);
    context->lastTruncateTransDurationUs =
            context->lastTruncateTransDurationUs + getCatTransactionDurationUs(target);

    catMessageManagerFlush(pCp);
}

void markAsNotCompleted(CatTransaction *pTrans) {
//    CatEvent *event = createCatEvent("cat", "BadInstrument");
//    catCheckPtr(event);
//    CatMessageInner *eventInner = getInnerMsg(event);
//    event->setStatus(event, "TransactionNotCompleted");
//    eventInner->m_completeFlag = 1;
//    pTrans->addChild(pTrans, event);
    CatMessageInner *messageInner = getInnerMsg(pTrans);
    messageInner->isCompleted = 1;
}

void validateTransaction(CatTransaction *pParentTrans, CatTransaction *pTrans) {
    CatTransactionInner *pTransInner = getInnerTrans(pTrans);
    CatStack_T pChildren = pTransInner->children;
    size_t i = 0;
    for (; i < catStackSize(pChildren); ++i) {
        CatMessage *pMsg = NULL;
        catStackGetByIndex(pChildren, i, (void**)&pMsg);
        if (isCatTransaction(pMsg)) {
            validateTransaction(pTrans, (CatTransaction *) pMsg);
        }
    }
    if (!isCatMessageComplete((CatMessage *) pTrans)) {
        markAsNotCompleted(pTrans);
    }
}
