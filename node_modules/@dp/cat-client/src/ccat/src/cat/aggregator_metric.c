#include "aggregator_metric.h"

#include "client_config.h"
#include "context.h"

#include "message/message_imp.h"
#include "lib/cat_sds.h"
#include "lib/cat_ccmap.h"
#include "message_sender.h"
#include "message_id.h"
#include "aggregator.h"

typedef struct _CatMetricData {
    CAT_ATOMICLONG m_count;
    CAT_ATOMICLONG m_durationMsSum;
    CAT_ATOMICLONG m_slowCount;
    int m_slowThreshold;
    int m_latestFlag;

} CatMetricData;


static CatCCHashMap *g_metricAggregator;


static inline CatMetricData *createCatMetricData() {
    CatMetricData *pData = (CatMetricData *) malloc(sizeof(CatMetricData));
    catCheckPtr(pData);
    if (pData == NULL) {
        return NULL;
    }
    pData->m_count = 0;
    pData->m_durationMsSum = 0;
    pData->m_slowCount = 0;
    pData->m_slowThreshold = 0;
    pData->m_latestFlag = 0;
    return pData;
}

static inline void destroyCatMetricData(CatMetricData *pData) {
    if (pData == NULL) {
        return;
    }
    free(pData);
}

static inline void addCountMetricToData(CatMetricData *pData, int value) {
    CAT_ATOMICLONG_ADD(&pData->m_count, value);
}


static inline void addTimerMetricToData(CatMetricData *pData, int timeMs) {
    CAT_ATOMICLONG_INC(&pData->m_count);
    CAT_ATOMICLONG_ADD(&pData->m_durationMsSum, timeMs);

    if (pData->m_slowThreshold > 0 && timeMs > pData->m_slowThreshold) {
        CAT_ATOMICLONG_INC(&pData->m_slowCount);
    }
}


static inline void addLatestMetricToData(CatMetricData *pData, int quantity) {
    pData->m_count = quantity;
    pData->m_latestFlag = 1;
}


static void newAggregatorMetric(char *name, char *status, char *keyValuePairs) {
    CatMetric *metric = newMetric("", name);
    catCheckPtr(metric);
    if (metric == NULL) {
        return;
    }
    if (keyValuePairs != NULL) {
        metric->addDataPair(metric, keyValuePairs);
    }
    metric->setStatus(metric, status);
    metric->setComplete(metric);
}

static void MetricDataValOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    char tmpBuf[32];
    CatMetricData *pData = (CatMetricData *) (*ppVal);

    char *keyName = (char *) key;

    if (pData->m_durationMsSum > 0) {
        char keyValPair[32];
        strcpy(keyValPair, catItoA(pData->m_count, tmpBuf, 10));
        strcat(keyValPair, ",");
        strcat(keyValPair, catItoA(pData->m_durationMsSum, tmpBuf, 10));
        newAggregatorMetric(keyName, "S,C", keyValPair);
    } else if (pData->m_count > 0) {
        if (pData->m_latestFlag) {
            newAggregatorMetric(keyName, "L", catItoA(pData->m_count, tmpBuf, 10));
        } else {
            newAggregatorMetric(keyName, "C", catItoA(pData->m_count, tmpBuf, 10));
        }
    }

    if (pData->m_slowCount > 0) {
        catsds newName = catsdsnew(keyName);
        newName = catsdscat(newName, ".slowCount");
        newAggregatorMetric(newName, "C", catItoA(pData->m_slowCount, tmpBuf, 10));
        catsdsfree(newName);
    }


    pData->m_count = 0;
    pData->m_durationMsSum = 0;
    pData->m_slowCount = 0;
    pData->m_latestFlag = 0;
}

static void sendMetricDataNoClear() {
    catOptEveryCCHashMapItem(g_metricAggregator, MetricDataValOptFun, NULL);
}

static void sendMetricDataClear() {
    catDict **pDictArray = catMoveCCHashMap(g_metricAggregator);
    catDict **pHeadDictArray = pDictArray;
    catCheckPtr(pDictArray);
    if (pDictArray == NULL) {
        return;
    }
    catDict *pDict = NULL;
    while ((pDict = *pDictArray++) != NULL) {
        catDictIterator *iter = catDictGetIterator(pDict);
        if (iter != NULL) {
            catDictEntry *pEntry = NULL;
            while ((pEntry = catDictNext(iter)) != NULL) {
                MetricDataValOptFun(NULL, pEntry->key, &pEntry->val, NULL);
            }
            catDictReleaseIterator(iter);
        }
        catDictRelease(pDict);
    }
    catFreeDictArray(pHeadDictArray);
}

static void findValCountOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    CatMetricData *pData = (CatMetricData *) pVal;
    addCountMetricToData(pData, (int) pParam);
}

static void findValTimerOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    CatMetricData *pData = (CatMetricData *) pVal;
    addTimerMetricToData(pData, (int) pParam);
}

static void findValLatestOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    CatMetricData *pData = (CatMetricData *) pVal;
    addLatestMetricToData(pData, (int) pParam);
}


static void findValThresholdOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    CatMetricData *pData = (CatMetricData *) pVal;
    pData->m_slowThreshold = (int) pParam;
}


static void *createValFun(CatCCHashMap *pCCHM, void *key, void *pParam) {
    return createCatMetricData();
}

void addCountMetricToAggregator(const char *name, int count) {
    catFindCCHashMapCreateByFunAndOperate(g_metricAggregator, (char *) name, createValFun,
                                          NULL, findValCountOptFun, (void *) count);
}


void addTimerMetricToAggregator(const char *name, int timeMs) {
    catFindCCHashMapCreateByFunAndOperate(g_metricAggregator, (char *) name, createValFun,
                                          NULL, findValTimerOptFun, (void *) timeMs);
}


void addLatestMetricToAggregator(const char *name, int quantity) {
    catFindCCHashMapCreateByFunAndOperate(g_metricAggregator, (char *) name, createValFun,
                                          NULL, findValLatestOptFun, (void *) quantity);
}


void setMetricSlowThreshold(const char *key, int threshold) {
    catFindCCHashMapCreateByFunAndOperate(g_metricAggregator, (char *) key, createValFun,
                                          NULL, findValThresholdOptFun, (void *) threshold);
}

static void _sendMetricAggregationData() {
    sendMetricDataNoClear();
}

void sendMetricData() {
    sendAggregationData(g_metricAggregator, "MetricAggregator", _sendMetricAggregationData);
}

extern unsigned int catDictStringCopyHTHashFunction(const void *key);

extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);

extern void *catDictStringKeyValCopyHTValDup(void *privdata, const void *val);

extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1,
                                         const void *key2);

extern void catDictStringCopyHTKeyDestructor(void *privdata, void *key);


static void catMetricDataFreeFun(void *privdata, void *val) {
    destroyCatMetricData((CatMetricData *) val);
}


catDictType dictTypeCatMetricAggregator = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                               /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        catMetricDataFreeFun  /* val destructor */
};

void initCatMetricAggregator() {
    g_metricAggregator = catCreateCCHashMap(&dictTypeCatMetricAggregator, g_config.slotCount, NULL);
    catCheckPtr(g_metricAggregator);
}

void destroyCatMetricAggregator() {
    catDestroyCCHashMap(g_metricAggregator);
}