#include "message_sender.h"

#include "aggregator.h"
#include "client_config.h"
#include "context.h"
#include "encoder.h"
#include "profiling.h"
#include "router.h"
#include "statistic.h"

#include "lib/cat_mpsc_queue.h"
#include "lib/cat_thread.h"
#include "lib/cat_time_util.h"
#include "message_id.h"

static struct {
    CatMPSCQueue *normal;
    CatMPSCQueue *high;

    catperf *perf;

    volatile int stop;
} sender = {};

extern catStatistic statistic;

volatile int g_cat_send_fd = -1;
volatile char g_cat_send_ip[64] = {0};
volatile unsigned short g_cat_send_port = 0;

#define CAT_MERGEBUF_COUNT 16
#define CAT_MERGEBUF_SIZE (60 * 1024)

static pthread_t g_cat_senderHandle = NULL;
static uint64_t queue_full_log_counter = 0;
/*
 * The value of this mask should be chosen with care; it should be a value of power of 2.
 * As bitwise operation is used to detect whether we should log a warning log.
 * */
static uint64_t queue_full_log_mask = (1u << 12u) - 1;

int isCatSenderEnable() {
    return g_cat_send_fd > 0;
}

int sendCatMessageTree(CatMessageTree *tree) {
    catperfin(sender.perf);

    CatMPSCQueueHelper *helper = sender.normal->helper;

    if (tree->canDiscard) {
        if (helper->offer(sender.normal, tree) == 0) {
            statistic.onProduced();
        } else {
            queue_full_log_counter += 1;
            if ((queue_full_log_counter & queue_full_log_mask) == 0) {
                g_config.logger->warning(
                        "Normal queue is full (%d), message will be aggregated.",
                        helper->size(sender.normal));
            }
            aggregateCatMessageTree(tree);
            statistic.onOverflowed();
            return 0;
        }
    } else {
        if (helper->offer(sender.high, tree) == 0) {
            statistic.onProduced();
        } else {
            queue_full_log_counter += 1;
            if ((queue_full_log_counter & queue_full_log_mask) == 0) {
                g_config.logger->error(
                        "High queue is full (%d), message will be discarded!",
                        helper->size(sender.high));
            }
            deleteCatMessageTree(tree);
            statistic.onDiscarded();
            return 1;
        }
    }
    return 0;
}

static inline int mqPollMany(void **bufArray, int max) {
    int current = 0;
    void *data;

    CatMPSCQueueHelper *helper = sender.normal->helper;

    helper->wait(sender.normal, 100);

    // poll from high priority queue non-blocking-ly
    while (current < max) {
        data = helper->poll(sender.high);
        if (NULL == data) {
            break;
        }
        bufArray[current++] = data;
    }

    // poll from normal priority queue non-blocking-ly
    while (current < max) {
        data = helper->poll(sender.normal);
        if (NULL == data) {
            break;
        }
        bufArray[current++] = data;
    }

    // printf("%d\n", current);
    return current;
}

/**
 * Do not provide thread-safety
 * @param sendBuf
 * @param checkpoint
 * @return
 */
static int sendCatMessageBufferDirectly(catsds sendBuf, size_t checkpoint) {
    static long blockTimes = 0;

    if (g_cat_send_fd < 0) {
        g_config.logger->warning("当前ip不可用: %s, 查找其他可用机器。", g_cat_send_ip);
        recoverCatServerConn();
        if (g_cat_send_fd < 0) {
            return -1;
        }
    }

    size_t sendTotalLen = checkpoint;
    ssize_t nowSendLen = 0;
    ssize_t sendLen = 0;

    while (nowSendLen != sendTotalLen) {
        // write()会把参数buf 所指的内存写入count 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.
        sendLen = write(g_cat_send_fd, sendBuf, sendTotalLen - nowSendLen);

        if (sendLen == -1) {
            if (errno == EAGAIN) {
                ++blockTimes;
                if (blockTimes % 1000000 == 0) {
                    g_config.logger->warning("Send Cat Message : %s is blocking.", g_cat_send_ip);
                }

                // We can simply break if nothing has been sent.
                // In case of partial data has already been sent, we have to wait until the buffer could be written again.
                // TODO a timeout is required to avoid of endless waiting.
                if (nowSendLen == 0) {
                    g_config.logger->warning("Tcp buffer is full, message has been discarded");
                    break;
                }

                Sleep(5);
                continue;
            } else {
                g_config.logger->warning("Error %d occurred while sending data to server.", errno);
                break;
            }
        } else {
            statistic.onBytes(sendLen);
        }

        nowSendLen += sendLen;
        sendBuf += sendLen;
    }

    return 1;
}

static catsds catsdsrotate(catsds s, size_t offset) {
    sdshdr *sh = (sdshdr *) (s - (sizeof(sdshdr)));

    if (offset > sh->len) {
        catsdsclear(s);
        return s;
    }

    size_t i;
    char *l, *r;
    for (i = offset, l = s, r = s + offset; i <= sh->len; i++, l++, r++) {
        *l = *r;
    }
    sh->len -= offset;
    sh->free += offset;
    return s;
}

static PTHREAD catMessageSenderFun(PVOID para) {
    cat_set_thread_name("cat-sender");

    CatMessageTree *messageArray[CAT_MERGEBUF_COUNT];
    catsds mergeBuf = catsdsnewEmpty(CAT_MERGEBUF_SIZE);

    while (!sender.stop) {
        catsdsclear(mergeBuf);

        int eleNum = mqPollMany((void **) messageArray, CAT_MERGEBUF_COUNT);
        if (eleNum == 0) {
            continue;
        }

        size_t checkpoint = 0;
        for (int i = 0; i < eleNum; i++) {
            mergeBuf = catEncodeMessage(messageArray[i], mergeBuf);
            deleteCatMessageTree(messageArray[i]);

            if (catsdslen(mergeBuf) >= CAT_MERGEBUF_SIZE) {
                sendCatMessageBufferDirectly(mergeBuf, checkpoint);
                mergeBuf = catsdsrotate(mergeBuf, checkpoint);
            }
            checkpoint = catsdslen(mergeBuf);
        }

        if (checkpoint > 0) {
            sendCatMessageBufferDirectly(mergeBuf, checkpoint);
        }

        catperfout(sender.perf, eleNum);
    }

    catsdsfree(mergeBuf);

    clearCatContext();
    return 0;
}

void initCatSender() {
    sender.perf = catcreateperf("send", 100000);

    sender.normal = newCatMPSCQueue("sender_normal", g_config.messageQueueSize);
    catCheckPtr(sender.normal);

    sender.high = newCatMPSCQueue("sender_high", g_config.messageQueueSize);
    catCheckPtr(sender.high);
}

void startCatSenderThread() {
    sender.stop = 0;
    pthread_create(&g_cat_senderHandle, NULL, catMessageSenderFun, NULL);
}

static void clearMessageQueue(CatMPSCQueue* q) {
    CatMessageTree* tree;
    while (NULL != (tree = q->helper->poll(q))) {
        deleteCatMessageTree(tree);
    }
    deleteCatMPSCQueue(q);
}

void clearCatSender() {
    sender.stop = 1;
    pthread_join(g_cat_senderHandle, NULL);

    catperffinal(sender.perf);

    clearMessageQueue(sender.normal);
    clearMessageQueue(sender.high);
}

long getSenderHighPriorityQueueSize() {
    return sender.high->helper->size(sender.high);
}

long getSenderNormalPriorityQueueSize() {
    return sender.normal->helper->size(sender.normal);
}
