#include "monitor_collector.h"

#include <ctype.h>

#include "cat/client.h"

#include "lib/cat_clog.h"
#include "lib/cat_ezxml.h"

#include "statistic.h"
#include "message_sender.h"
#include "client_config.h"

#define startswith(line, prefix) (strncmp(line, prefix, sizeof(prefix) - 1) == 0)
#define ldtoa(l) (sprintf(buf, "%ld", l), buf)
#define lftoa(lf) (sprintf(buf, "%lf", lf), buf)

#define LINE_BUF_SIZE 256

#define MEM_TOTAL_PREFIX        "MemTotal:"
#define MEM_FREE_PREFIX         "MemFree:"
#define MEM_BUFFERS_PREFIX      "Buffers:"
#define MEM_CACHED_PREFIX       "Cached:"
#define MEM_SWAP_TOTAL_PREFIX   "SwapTotal:"
#define MEM_SWAP_FREE_PREFIX    "SwapFree:"

#define SYSTEM_PROCESS          "system.process"
#define CAT_STATUS              "cat.status"
#define CAT_EXTRA               "cat.extra"

extern catStatistic statistic;

static void add_detail(cat_ezxml_t ext, const char* key, const char* val, int* index);

static void collect_cat_batch_queue_status(cat_ezxml_t pEzxml);

static void inline add_detail(cat_ezxml_t ext, const char* key, const char* val, int* index) {
    cat_ezxml_t detail = cat_ezxml_add_child_d(ext, "extensionDetail", (size_t) *index);
    cat_ezxml_set_attr_d(detail, "id", key);
    cat_ezxml_set_attr_d(detail, "value", val);
    (*index)++;
}

static loadavg* fetch_loadavg() {
    loadavg* info = calloc(1, sizeof(loadavg));
    FILE* fp;

    if ((fp = fopen("/proc/loadavg", "r")) == NULL) {
        g_config.logger->warning("Cannot open /proc/loadavg to get cpu load average.");
        return info;
    }

    fscanf(fp, "%lf %lf %lf", &info->avg1, &info->avg5, &info->avg15);

    fclose(fp);
    return info;
}

static cpustat* fetch_cpustat() {
    cpustat* stat = calloc(1, sizeof(cpustat));
    FILE* fp;

    if ((fp = fopen("/proc/stat", "r")) == NULL) {
        g_config.logger->warning("Cannot open /proc/stat to get cpu status.");
        return stat;
    }

    char line[LINE_BUF_SIZE];
    while (fgets(line, LINE_BUF_SIZE, fp) != NULL) {
        if (startswith(line, "cpu") && isblank(line[3])) {  // 3 is sizeof("cpu") - 1
            int code = sscanf(
                    line,
                    "%*s %ld %ld %ld %ld %ld %ld %ld",
                    &stat->user,
                    &stat->nice,
                    &stat->system,
                    &stat->idle,
                    &stat->iowait,
                    &stat->irq,
                    &stat->softirq
            );
            if (EOF == code) {
                return stat;
            }
        } else if (startswith(line, "intr")) {
            sscanf(line, "%*s %ld", &stat->intr);
        } else if (startswith(line, "ctxt")) {
            sscanf(line, "%*s %ld", &stat->context);
        } else if (startswith(line, "procs_running")) {
            sscanf(line, "%*s %ld", &stat->proc_running);
        } else if (startswith(line, "procs_blocked")) {
            sscanf(line, "%*s %ld", &stat->proc_blocked);
        }
    }

    fclose(fp);
    return stat;
}

static cpuinfo* cpustat_delta(cpustat* old, cpustat* new) {
    cpuinfo* info = calloc(1, sizeof(cpuinfo));
    info->user = new->user - old->user;
    info->nice = new->nice - old->nice;
    info->system = new->system - old->system;
    info->idle = new->idle - old->idle;
    info->iowait = new->iowait - old->iowait;
    info->irq = new->irq - old->irq;
    info->softirq = new->softirq - old->softirq;
    info->total = info->user + info->nice + info->system + info->idle + info->iowait + info->irq + info->softirq;

    info->intr = new->intr - old->intr;
    info->context = new->context - old->context;
    return info;
}

static meminfo* fetch_meminfo() {
    meminfo* info = calloc(1, sizeof(meminfo));

    FILE* fp;
    if ((fp = fopen("/proc/meminfo", "r")) == NULL) {
        g_config.logger->warning("Cannot open /proc/meminfo to get memory status.");
        return info;
    }

    char line[LINE_BUF_SIZE];
    long value;

    while (fgets(line, sizeof(line), fp) != NULL) {
        if (sscanf(line, "%*s %ld kB", &value) != 1) {
            continue;
        }
        if (startswith(line, MEM_TOTAL_PREFIX)) {
            info->total = value * 1024;
        } else if (startswith(line, MEM_FREE_PREFIX)) {
            info->free = value * 1024;
        } else if (startswith(line, MEM_BUFFERS_PREFIX)) {
            info->buffers = value * 1024;
        } else if (startswith(line, MEM_CACHED_PREFIX)) {
            info->cached = value * 1024;
        } else if (startswith(line, MEM_SWAP_TOTAL_PREFIX)) {
            info->swap_total = value * 1024;
        } else if (startswith(line, MEM_SWAP_FREE_PREFIX)) {
            info->swap_free = value * 1024;
        }
    }

    fclose(fp);
    return info;
}

static cpustat* previous_stat = NULL;

static void collect_cpu_info(cat_ezxml_t ext, int* count) {
    char buf[16];

    loadavg* avg = fetch_loadavg();
    add_detail(ext, "system.load.average", lftoa(avg->avg1), count);
    add_detail(ext, "load.1min", lftoa(avg->avg1), count);
    add_detail(ext, "load.5min", lftoa(avg->avg5), count);
    add_detail(ext, "load.15min", lftoa(avg->avg15), count);
    free(avg);

    cpustat* stat = fetch_cpustat();
    add_detail(ext, "process.running", ldtoa(stat->proc_running), count);
    add_detail(ext, "process.blocked", ldtoa(stat->proc_blocked), count);

    if (NULL != previous_stat) {
        cpuinfo* info = cpustat_delta(previous_stat, stat);
        add_detail(ext, "cpu.user", ldtoa(info->user), count);
        add_detail(ext, "cpu.nice", ldtoa(info->nice), count);
        add_detail(ext, "cpu.system", ldtoa(info->system), count);
        add_detail(ext, "cpu.idle", ldtoa(info->idle), count);
        add_detail(ext, "cpu.iowait", ldtoa(info->iowait), count);
        add_detail(ext, "cpu.irq", ldtoa(info->irq), count);
        add_detail(ext, "cpu.softirq", ldtoa(info->softirq), count);

        if (info->total > 0) {
            add_detail(ext, "cpu.user.percent", lftoa((double) (info->user) / info->total * 100), count);
            add_detail(ext, "cpu.nice.percent", lftoa((double) (info->nice) / info->total * 100), count);
            add_detail(ext, "cpu.system.percent", lftoa((double) (info->system) / info->total * 100), count);
            add_detail(ext, "cpu.idle.percent", lftoa((double) (info->idle) / info->total * 100), count);
            add_detail(ext, "cpu.iowait.percent", lftoa((double) (info->iowait) / info->total * 100), count);
            add_detail(ext, "cpu.irq.percent", lftoa((double) (info->irq) / info->total * 100), count);
            add_detail(ext, "cpu.softirq.percent", lftoa((double) (info->softirq) / info->total * 100), count);
        }

        add_detail(ext, "cpu.context", ldtoa(info->context), count);
        add_detail(ext, "cpu.intr", ldtoa(info->intr), count);

        free(info);
        free(previous_stat);
    }
    previous_stat = stat;
}

static void collect_mem_info(cat_ezxml_t ext, int* count) {
    meminfo* info = fetch_meminfo();
    if (info->total == 0) {
        return;
    }

    info->free += info->buffers + info->cached;

    double memfree_percent = (double) info->free / info->total * 100;
    double memused_percent = 100.0 - memfree_percent;

    char buf[16];
    add_detail(ext, "mem.memtotal", ldtoa(info->total), count);
    add_detail(ext, "mem.memfree", ldtoa(info->free), count);
    add_detail(ext, "mem.memused", ldtoa(info->total - info->free), count);
    add_detail(ext, "mem.memcached", ldtoa(info->cached), count);
    add_detail(ext, "mem.swaptotal", ldtoa(info->swap_total), count);
    add_detail(ext, "mem.swapfree", ldtoa(info->swap_free), count);
    add_detail(ext, "mem.memfree.percent", lftoa(memfree_percent), count);
    add_detail(ext, "mem.memused.percent", lftoa(memused_percent), count);

    free(info);
}

static void collect_cat_status(cat_ezxml_t ext, int* count) {
    char buf[16];
    add_detail(ext, "cat.status.message.bytes", ldtoa(statistic.getBytes()), count);
    add_detail(ext, "cat.status.message.produced", ldtoa(statistic.getProduced()), count);
    add_detail(ext, "cat.status.message.overflowed", ldtoa(statistic.getOverflowed()), count);
    add_detail(ext, "cat.status.message.discarded", ldtoa(statistic.getDiscarded()), count);

    add_detail(ext, "cat.status.queue.high.size", ldtoa(getSenderHighPriorityQueueSize()), count);
    add_detail(ext, "cat.status.queue.normal.size", ldtoa(getSenderNormalPriorityQueueSize()), count);
}

static void system_process(cat_ezxml_t xml) {
    cat_ezxml_t ext = cat_ezxml_add_child_d(xml, "extension", 0);
    cat_ezxml_set_attr_d(ext, "id", SYSTEM_PROCESS);

    cat_ezxml_t desc = cat_ezxml_add_child_d(ext, "description", 0);
    cat_ezxml_set_txt_d(desc, "<![CDATA["SYSTEM_PROCESS"]]>");

    int count = 1;

    CatTransaction* t = newTransaction("System", "collect_cpu_info");
    collect_cpu_info(ext, &count);
    t->setComplete((CatMessage*) t);

    t = newTransaction("System", "collect_mem_info");
    collect_mem_info(ext, &count);
    t->setComplete((CatMessage*) t);
}

static void cat_status(cat_ezxml_t xml) {
    cat_ezxml_t ext = cat_ezxml_add_child_d(xml, "extension", 0);
    cat_ezxml_set_attr_d(ext, "id", CAT_STATUS);

    cat_ezxml_t desc = cat_ezxml_add_child_d(ext, "description", 0);
    cat_ezxml_set_txt_d(desc, "<![CDATA["CAT_STATUS"]]>");

    int count = 1;

    CatTransaction* t = newTransaction("System", "collect_cat_status");
    collect_cat_status(ext, &count);
    t->setComplete((CatMessage*) t);
}

static void collect_cat_batch_queue_status(cat_ezxml_t pEzxml) {
    char buf[16];
    int count = 1;
    if (g_config.transactionBatchQueueCapacity > 0) {
        CatMPSCQueue* batchQueue = g_config.transactionBatchDispatcher->batchQueue;
        CatMPSCQueueHelper* queueOperator = batchQueue->helper;
        add_detail(pEzxml, "cat.status.transaction.batch.queue.capacity",
                   ldtoa((long)(queueOperator->capacity(batchQueue))), &count);
        add_detail(pEzxml, "cat.status.transaction.batch.queue.size",
                   ldtoa((long)(queueOperator->size(batchQueue))), &count);
    }

    if (g_config.eventBatchQueueCapacity > 0) {
        CatMPSCQueue* batchQueue = g_config.eventBatchDispatcher->batchQueue;
        CatMPSCQueueHelper* queueOperator = batchQueue->helper;

        add_detail(pEzxml, "cat.status.event.batch.queue.capacity",
                   ldtoa((long)(queueOperator->capacity(batchQueue))), &count);
        add_detail(pEzxml, "cat.status.event.batch.queue.size",
                   ldtoa((long)(queueOperator->size(batchQueue))), &count);
    }
}

static void cat_extra(cat_ezxml_t xml) {
    cat_ezxml_t ext = cat_ezxml_add_child_d(xml, "extension", 0);
    cat_ezxml_set_attr_d(ext, "id", CAT_STATUS);

    cat_ezxml_t desc = cat_ezxml_add_child_d(ext, "description", 0);
    cat_ezxml_set_txt_d(desc, "<![CDATA["CAT_STATUS"]]>");

    CatTransaction* t = newTransaction("System", "batch_queue_status");
    collect_cat_batch_queue_status(ext);
    t->setComplete((CatMessage*) t);
}

char* get_status_report() {
    cat_ezxml_t xml = cat_ezxml_new_d("status");

    CatTransaction* t;

    t = newTransaction("System", "StatusExtension-"SYSTEM_PROCESS);
    system_process(xml);
    t->setComplete((CatMessage*) t);

    t = newTransaction("System", "StatusExtension-"CAT_STATUS);
    cat_status(xml);
    t->setComplete((CatMessage*) t);

    t = newTransaction("System", "StatusExtension-"CAT_EXTRA);
    cat_extra(xml);
    t->setComplete((CatMessage*) t);

    char* xmlContent = cat_ezxml_toxml(xml);
    cat_ezxml_free(xml);

    return xmlContent;
}
