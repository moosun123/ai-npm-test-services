#include "aggregator_event.h"

#include "context.h"
#include "client_config.h"

#include "lib/cat_ccmap.h"
#include "lib/cat_sds.h"

#include "message_sender.h"
#include "message/message_imp.h"
#include "message_id.h"
#include "aggregator.h"

typedef struct _CatEventData {
    catsds m_type;
    catsds m_name;
    CAT_ATOMICLONG m_count;
    CAT_ATOMICLONG m_error;
} CatEventData;


static CatCCHashMap *g_eventAggregator;


static inline catsds buildKey(CatMessage *pMsg) {
    static CATTHREADLOCAL catsds s_key = NULL;
    if (s_key == NULL) {
        s_key = catsdsnewEmpty(128);
    }

    CatMessageInner *pInnerMsg = getInnerMsg(pMsg);
    catsds type = pInnerMsg->type;
    catsds name = pInnerMsg->name;
    s_key = catsdscpylen(s_key, type, catsdslen(type));
    s_key = catsdscatchar(s_key, ',');
    s_key = catsdscatlen(s_key, name, catsdslen(name));
    return s_key;
}

static inline CatEventData *createCatEventData(CatEvent *pEvent) {
    CatMessageInner *pInnerMsg = getInnerMsg(pEvent);
    catsds type = pInnerMsg->type;
    catsds name = pInnerMsg->name;
    CatEventData *pData = (CatEventData *) malloc(sizeof(CatEventData));
    catCheckPtr(pData);
    pData->m_type = catsdsdup(type);
    pData->m_name = catsdsdup(name);
    pData->m_count = 0;
    pData->m_error = 0;
    return pData;
}

static inline void destroyCatEventData(CatEventData *pData) {
    if (pData == NULL) {
        return;
    }
    catsdsfree(pData->m_type);
    catsdsfree(pData->m_name);
    free(pData);
}

static inline void addEventToData(CatEventData *pData, CatEvent *pEvent) {
    CAT_ATOMICLONG_INC(&pData->m_count);
    if (!checkCatMessageSuccess(pEvent)) {
        CAT_ATOMICLONG_INC(&pData->m_error);
    }
}

static inline void addBatchEventToData(CatEventData *pData, int count, int error) {
    CAT_ATOMICLONG_ADD(&pData->m_count, (long) count);
    CAT_ATOMICLONG_ADD(&pData->m_error, (long) error);
}

static void eventDataValOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    char tmpBuf[32];
    CatEventData *pData = (CatEventData *) (*ppVal);
    if (pData->m_count > 0) {
        CatEvent *pEvent = newEvent(pData->m_type, pData->m_name);
        CatMessageInner *pInner = getInnerMsg(pEvent);
        pInner->data = catsdsnewEmpty(64);
        pInner->data = catsdscatchar(pInner->data, '@');
        pInner->data = catsdscat(pInner->data, catItoA(pData->m_count, tmpBuf, 10));
        pInner->data = catsdscatchar(pInner->data, ';');
        pInner->data = catsdscat(pInner->data, catItoA(pData->m_error, tmpBuf, 10));
        pEvent->setStatus(pEvent, CAT_SUCCESS);
        pEvent->setComplete(pEvent);
    }
    pData->m_count = 0;
    pData->m_error = 0;
}

static void sendEventDataNoClear() {
    catOptEveryCCHashMapItem(g_eventAggregator, eventDataValOptFun, NULL);
}

static void sendEventDataClear() {
    catDict **pDictArray = catMoveCCHashMap(g_eventAggregator);
    catDict **pHeadDictArray = pDictArray;
    catCheckPtr(pDictArray);
    if (pDictArray == NULL) {
        return;
    }
    catDict *pDict = NULL;
    while ((pDict = *pDictArray++) != NULL) {
        catDictIterator *iter = catDictGetIterator(pDict);
        if (iter != NULL) {
            catDictEntry *pEntry = NULL;
            while ((pEntry = catDictNext(iter)) != NULL) {
                eventDataValOptFun(NULL, pEntry->key, &pEntry->val, NULL);
            }
            catDictReleaseIterator(iter);
        }
        catDictRelease(pDict);
    }
    catFreeDictArray(pHeadDictArray);
}

static void findValOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    CatEvent *pEvent = (CatEvent *) pParam;
    volatile void *pVal = *ppVal;
    CatEventData *pData = (CatEventData *) pVal;
    addEventToData(pData, pEvent);
}

static void findValOptBatchFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    void** params = (void**) pParam;

    int *count = params[0];
    int *error = params[1];

    volatile void *pVal = *ppVal;
    CatEventData *pData = (CatEventData*) pVal;
    addBatchEventToData(pData, *count, *error);
}


static void *createValFun(CatCCHashMap *pCCHM, void *key, void *pParam) {
    CatEvent *pEvent = (CatEvent *) pParam;
    return createCatEventData(pEvent);
}

void addEventToAggregator(CatEvent *pEvent) {
    catsds key = buildKey((CatMessage *) pEvent);
    catFindCCHashMapCreateByFunAndOperate(g_eventAggregator, key, createValFun, pEvent, findValOptFun, pEvent);
}

void logBatchEventToAggregator(const char *type, const char *name, int count, int error) {
    CatEvent *event = createCatEvent(type, name);
    catsds key = buildKey((CatMessage *) event);

    void** params = calloc(sizeof(void*), 3);
    params[0] = &count;
    params[1] = &error;
    catFindCCHashMapCreateByFunAndOperate(g_eventAggregator, key, createValFun, event, findValOptBatchFun, params);

    free(params);
    deleteCatMessage(event);
}

static void _sendEventAggregationData() {
    if (g_eventAggregator->m_count < 2000) {
        sendEventDataNoClear();
    } else {
        sendEventDataClear();
    }
}

void sendEventData() {
    sendAggregationData(g_eventAggregator, "EventAggregator", _sendEventAggregationData);
}

extern unsigned int catDictStringCopyHTHashFunction(const void *key);

extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);

extern void *catDictStringKeyValCopyHTValDup(void *privdata, const void *val);

extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1,
                                         const void *key2);

extern void catDictStringCopyHTKeyDestructor(void *privdata, void *key);


static void catEventDataFreeFun(void *privdata, void *val) {
    destroyCatEventData((CatEventData *) val);
}


catDictType dictTypeCatEventAggregator = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                               /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        catEventDataFreeFun  /* val destructor */
};

void initCatEventAggregator() {
    g_eventAggregator = catCreateCCHashMap(&dictTypeCatEventAggregator, g_config.slotCount, NULL);
    catCheckPtr(g_eventAggregator);
}

void destroyCatEventAggregator() {
    catDestroyCCHashMap(g_eventAggregator);
}