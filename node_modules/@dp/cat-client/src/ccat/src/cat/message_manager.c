#include "message_manager.h"

#include "consts.h"
#include "aggregator.h"
#include "client_config.h"
#include "context.h"
#include "message_id.h"
#include "message_sender.h"
#include "problem_filter.h"

#include "lib/cat_network_util.h"
#include "lib/cat_atomic.h"
#include "lib/cat_time_util.h"

#include "message/message_imp.h"

CatMessageManager g_cat_messageManager = {0}; //memset(&g_cat_messageManager, 0, sizeof(g_cat_messageManager))

extern CatProblemFilter g_problem_filter;

static volatile u_int64 last_started_millis = 0;
static CAT_ATOMICLONG accumulated_count_for_current_second = 0;

static int isHitSample() {
    static CAT_ATOMICLONG hitCount = 0;
    long sendInterval = (long) (1.0 / g_config.sampleRatio);
    if (sendInterval == 0) {
        sendInterval = 1;
    }
    return CAT_ATOMICLONG_INC(&hitCount) % sendInterval == 0 ? 1 : 0;
}

static int tooManyMessagesPerSecond(int count_limit) {
    u_int64 current_millis = GetTime64();
    if (current_millis - last_started_millis > ONE_SECOND_IN_MILLIS) {
        last_started_millis = current_millis;
        accumulated_count_for_current_second = 0;
    }

    return CAT_ATOMICLONG_ADD(&accumulated_count_for_current_second, 1) > count_limit;
}

static int isHitProblem(CatTransaction* trans) {
    if (!g_problem_filter.isProblem(trans)) {
        return 0;
    }

    if (!g_problem_filter.hitTrans(trans)) {
        return 0;
    }

    return 1;
}


static int canBeAggregated(const CatMessageTree *tree) {
    CatMessage * rootMessage = tree->root;
    if (getInnerMsg(rootMessage)->ignoreSampleRatio) {
        return 0;
    }
    if (g_config.sampleRatio < 0) {
        return 1;
    }
    if (g_config.sampleRatio >= 1.0) {
        return 0;
    }
    if (tooManyMessagesPerSecond(g_config.msgCountPerSecond)) {
        return 1;
    }
    if (isCatTransaction(rootMessage) && isHitProblem((CatTransaction*)rootMessage)) {
        return 0;
    }
    if (!tree->canDiscard) {
        return 0;
    }

    return !isHitSample();
}

void catMessageManagerAdd(CatMessage *message) {
    if (NULL == message) {
        return;
    }
    catContextAdd(message);
}

void catMessageManagerEndTrans(CatMessage *message) {
    if (NULL == message) {
        return;
    }
    if (!isCatTransaction(message)) {
        return;
    }

    CatTransaction* trans = (CatTransaction*) message;

    if (catContextEndTrans(trans)) {
        resetCatContext();
    }
}

void catMessageManagerFlush(CatMessageTree *tree) {
    if (NULL == tree) {
        return;
    }

    if (!isCatSenderEnable()) {
        deleteCatMessageTree(tree);

        long next = CAT_ATOMICLONG_INC(&g_cat_messageManager.discardTimes);
        if (next % 1000000 == 1) {
            g_config.logger->warning("Cat Message has been discarded! Times: %d", next);
        }
        return;
    }

    if (canBeAggregated(tree)) {
        aggregateCatMessageTree(tree);
        return;
    }

    if (NULL == tree->messageId) {
        tree->messageId = getNextMessageId();
    }
    sendCatMessageTree(tree);
}

void initMessageManager(const char *domain, const char *hostName) {
    g_cat_messageManager.domain = catsdsnew(domain);
    catCheckPtr(g_cat_messageManager.domain);

    g_cat_messageManager.hostname = catsdsnew(hostName);
    catCheckPtr(g_cat_messageManager.hostname);

    // Get ip
    g_cat_messageManager.ip = catsdsnewEmpty(64);
    catCheckPtr(g_cat_messageManager.ip);

    getLocalHostIp(g_cat_messageManager.ip);

    // Check if ip has been successfully got.
    if (g_cat_messageManager.ip[0] == '\0') {
        g_config.logger->warning("Cannot get self ip address, using default ip: %s", g_config.defaultIp);
        g_cat_messageManager.ip = catsdscpy(g_cat_messageManager.ip, g_config.defaultIp);
    }
    g_config.logger->info("Ip: %s", g_cat_messageManager.ip);

    // Get ip hex.
    g_cat_messageManager.ipHex = catsdsnewEmpty(64);
    catCheckPtr(g_cat_messageManager.ipHex);

    getLocalHostIpHex(g_cat_messageManager.ipHex);

    // Check if ip hex has been successfully got.
    if (g_cat_messageManager.ipHex[0] == '\0') {
        g_config.logger->warning("Cannot get self ip address, use default ip hex: %s", g_config.defaultIpHex);
        g_cat_messageManager.ipHex = catsdscpy(g_cat_messageManager.ipHex, g_config.defaultIpHex);
    }
    g_config.logger->warning("Ip hex: 0x%s", g_cat_messageManager.ipHex);

}

void destroyCatMessageManager() {
    catsdsfree(g_cat_messageManager.domain);
    g_cat_messageManager.domain = NULL;
    catsdsfree(g_cat_messageManager.hostname);
    g_cat_messageManager.hostname = NULL;
    catsdsfree(g_cat_messageManager.ip);
    g_cat_messageManager.ip = NULL;
    catsdsfree(g_cat_messageManager.ipHex);
    g_cat_messageManager.ipHex = NULL;
}

void catMessageManagerStartTrans(CatTransaction *trans) {
    catContextStartTrans(trans);
}

