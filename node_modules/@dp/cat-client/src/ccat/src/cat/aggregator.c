#include "aggregator.h"

#include "aggregator_event.h"
#include "aggregator_metric.h"
#include "aggregator_metric_tag.h"
#include "aggregator_transaction.h"
#include "context.h"

#include "lib/cat_thread.h"
#include "lib/cat_time_util.h"
#include "lib/cat_static_queue.h"
#include "client_config.h"

#include "message/message_imp.h"
#include "message_id.h"
#include "message_sender.h"

static volatile int g_cat_aggregatorStop = 0;
static pthread_t g_cat_aggregatorHandle = NULL;

static void sleepForNextRound(u_int64 startTime);

void aggregateCatTransaction(CatTransaction* pTransaction) {
    addTransToAggregator(pTransaction);

    CatStack_T pChildren = getCatTransactionChildren(pTransaction);
    if (pChildren == NULL) {
        return;
    }

    size_t len = catStackSize(pChildren);
    size_t i = 0;
    for (; i < len; i++) {
        CatMessage *pChild = NULL;
        catStackGetByIndex(pChildren, i, (void**)&pChild);
        if (isCatTransaction(pChild)) {
            aggregateCatTransaction((CatTransaction*) pChild);
        } else if (isCatEvent(pChild)) {
            addEventToAggregator(pChild);
        }
        deleteCatMessage(pChild);
    }
    catStackClear(pChildren);
}

void aggregateCatMessageTree(CatMessageTree* tree) {
    if (isCatTransaction(tree->root)) {
        aggregateCatTransaction((CatTransaction*) tree->root);
    } else if (isCatEvent(tree->root)) {
        addEventToAggregator(tree->root);
    }
    deleteCatMessage(tree->root);
    tree->root = NULL;
    deleteCatMessageTree(tree);
}

PTHREAD catAggregatorDataUpdateFun(PVOID para) {
    cat_set_thread_name("cat-aggregator");

    while (!g_cat_aggregatorStop) {
        g_config.logger->debug("aggregator data update starts");
        u_int64 startTime = GetTime64();

        sendTransData();
        sendEventData();
        sendMetricData();
        sendMetricTagData();

        sleepForNextRound(startTime);
    }

    clearCatContext();
    return 0;
}

void sleepForNextRound(u_int64 startTime) {
    u_int64 duration = GetTime64() - startTime;

    int interval = getAggregatorInterval();
    if (duration < interval) {
        Sleep(interval - (int) duration);
    }
}

void initCatAggregator() {
    initCatTransAggregator();
    initCatEventAggregator();
    initCatMetricAggregator();
    initCatMetricTagAggregator();

    g_cat_aggregatorStop = 0;
}

void startCatAggregatorThread() {
    pthread_create(&g_cat_aggregatorHandle, NULL, catAggregatorDataUpdateFun, NULL);
}

void destroyCatAggregator() {
    g_cat_aggregatorStop = 1;
    pthread_join(g_cat_aggregatorHandle, NULL);

    destroyCatTransAggregator();
    destroyCatEventAggregator();
    destroyCatMetricAggregator();
    destroyCatMetricTagAggregator();
}

void sendAggregationData(CatCCHashMap* aggregationMap, const char* name, aggregationDataSender sender) {
    if (aggregationMap->m_count <= 0) {
        return;
    }
    setCatMessageTreeCanDiscard(0);

    CatTransaction * pTrans = createCatTransaction("System", name, emptyCatMessageFlusher);
    catContextStartTrans(pTrans);

    sender();

    CatMessageTree * old = getCatContext()->tree;
    getCatContext()->tree = duplicateCatMessageTree(old);
    old->messageId = getNextMessageId();
    old->canDiscard = 0;
    sendCatMessageTree(old);
    resetCatContext();
}

