#include "encoder.h"

#include "transaction_helper.h"

#include "message/message_imp.h"
#include "message_manager.h"

#include "lib/cat_clog.h"
#include "client_config.h"

#define POLICY_DEFAULT 0
#define POLICY_WITHOUT_STATUS 1
#define POLICY_WITH_DURATION 2

#define CAT_ENCODE_VERSION "NT1"
#define CAT_TAB '\t'
#define CAT_EL '\n'


extern CatMessageManager g_cat_messageManager;

static inline catsds sdswriteLong(catsds s, unsigned long long val) {
    if (val < 0) {
        return s;
    }
    while (1) {
        if ((val & ~0x7FL) == 0) {
            return catsdscatchar(s, (char) val);
        } else {
            s = catsdscatchar(s, ((char) val & 0x7F) | 0x80);
            val >>= 7;
        }
    }
}

#define sdswritetimestamp sdswriteLong
#define sdswriteduration sdswriteLong

static inline catsds sdswritestringwithnull(catsds s, const char *buf) {
    if (buf == NULL) {
        return sdswriteLong(s, 0);
    } else {
        int len = strlen(buf);
        s = sdswriteLong(s, len);
        return catsdscatlen(s, buf, len);
    }
}

static inline catsds sdswitestringwithdefault(catsds s, const char *buf, const char *defaultStr) {
    if (buf == NULL) {
        buf = defaultStr;
    }
    if (buf == NULL) {
        return sdswritestringwithnull(s, buf);
    }
    int len = strlen(buf);
    s = sdswriteLong(s, len);
    return catsdscatlen(s, buf, len);
}


static inline catsds sdscatwithnull(catsds s, const char *buf) {
    return catsdscat(s, buf == NULL ? "null" : buf);
}

static inline catsds sdscatwithdefault(catsds s, const char *buf, const char *defaultStr) {
    return catsdscat(s, buf == NULL ? defaultStr : buf);
}


static inline int TRANSACTION_START_encode(catsds *buf, CatMessage *pMsg) {
    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *messageInner = getInnerMsg(pMsg);

    tmpBuf = catsdscatchar(tmpBuf, 't');
    tmpBuf = sdswritetimestamp(tmpBuf, getCatMessageTimeStamp(pMsg));
    tmpBuf = sdswritestringwithnull(tmpBuf, messageInner->type);
    tmpBuf = sdswritestringwithnull(tmpBuf, messageInner->name);


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

static inline int TRANSACTION_END_encode(catsds *buf, CatMessage *pMsg) {
    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *messageInner = getInnerMsg(pMsg);

    // TODO check if the given message is a valid transaction
    CatTransaction *transaction = (CatTransaction *) pMsg;

    tmpBuf = catsdscatchar(tmpBuf, 'T');
    tmpBuf = sdswritestringwithnull(tmpBuf, messageInner->status);
    tmpBuf = sdswritestringwithnull(tmpBuf, messageInner->data);
    tmpBuf = sdswriteduration(tmpBuf, getCatTransactionDurationUs(transaction));


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

static inline int EVENT_encode(catsds *buf, CatMessage *pMsg) {
    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *pMsgInner = getInnerMsg(pMsg);

    tmpBuf = catsdscatchar(tmpBuf, 'E');
    tmpBuf = sdswritetimestamp(tmpBuf, getCatMessageTimeStamp(pMsg));
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->type);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->name);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->status);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->data);


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

static inline int METRIC_encode(catsds *buf, CatMessage *pMsg) {

    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *pMsgInner = getInnerMsg(pMsg);

    tmpBuf = catsdscatchar(tmpBuf, 'M');
    tmpBuf = sdswritetimestamp(tmpBuf, getCatMessageTimeStamp(pMsg));
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->type);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->name);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->status);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->data);


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

static inline int HEARTBEAT_encode(catsds *buf, CatMessage *pMsg) {

    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *pMsgInner = getInnerMsg(pMsg);

    tmpBuf = catsdscatchar(tmpBuf, 'H');
    tmpBuf = sdswritetimestamp(tmpBuf, getCatMessageTimeStamp(pMsg));
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->type);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->name);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->status);
    tmpBuf = sdswritestringwithnull(tmpBuf, pMsgInner->data);


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

int catEncodeHeader(CatMessageTree *pRootMsg, catsds *buf) {
    catsds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);

    tmpBuf = sdscatwithnull(tmpBuf, CAT_ENCODE_VERSION);
    tmpBuf = sdswritestringwithnull(tmpBuf, g_cat_messageManager.domain);
    tmpBuf = sdswritestringwithnull(tmpBuf, g_cat_messageManager.hostname);
    tmpBuf = sdswritestringwithnull(tmpBuf, g_cat_messageManager.ip);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->threadGroupName);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->threadId);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->threadName);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->messageId);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->parentMessageId);
    tmpBuf = sdswritestringwithnull(tmpBuf, pRootMsg->rootMessageId);
    tmpBuf = sdswritestringwithnull(tmpBuf, NULL);

    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}


int catEncodeBody(CatMessage *pMsg, catsds *buf) {
    if (isCatTransaction(pMsg)) {
        CatTransaction *transaction = (CatTransaction *) pMsg;
        CatStack_T children = getCatTransactionChildren(transaction);

        int count = TRANSACTION_START_encode(buf, pMsg);

        size_t len = catStackSize(children);
        size_t i = 0;
        for (; i < len; i++) {
            CatMessage *child = NULL;
            catStackGetByIndex(children, i, (void**)&child);

            if (child != NULL) {
                count += catEncodeBody(child, buf);
            }
        }

        count += TRANSACTION_END_encode(buf, pMsg);

        return count;
    } else if (isCatEvent(pMsg)) {
        return EVENT_encode(buf, pMsg);
    } else if (isCatMetric(pMsg)) {
        return METRIC_encode(buf, pMsg);
    } else if (isCatHeartBeat(pMsg)) {
        return HEARTBEAT_encode(buf, pMsg);
    } else {
        g_config.logger->error("Unsupported message type: %s.", getCatMessageType(pMsg));
    }
    return 0;
}


catsds catEncodeMessage(CatMessageTree *pRootMsg, catsds buf) {
    int count = 0;
    size_t pos = catsdslen(buf);

    // message header
    buf = catsdscatlen(buf, "0000", 4);
    count += catEncodeHeader(pRootMsg, &buf);

    // message body
    if (pRootMsg->root != NULL) {
        count += catEncodeBody(pRootMsg->root, &buf);
    }

    buf[pos++] = (char) ((count >> 24) & 0xFF);
    buf[pos++] = (char) ((count >> 16) & 0xFF);
    buf[pos++] = (char) ((count >> 8) & 0xFF);
    buf[pos] = (char) ((count) & 0xFF);
    return buf;
}

