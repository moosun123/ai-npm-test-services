#include "cat/client.h"

#include "version.h"

#include "aggregator.h"
#include "aggregator_event.h"
#include "aggregator_metric.h"
#include "aggregator_transaction.h"
#include "client_config.h"
#include "context.h"
#include "message_id.h"
#include "message_manager.h"
#include "message_sender.h"
#include "monitor.h"
#include "problem_filter.h"
#include "router.h"
#include "statistic.h"
#include "router_json_parser.h"
#include "message/message_imp.h"
#include "lib/cat_time_util.h"
#include "lib/cat_mpsc_queue.h"
#include "batch_dispatcher.h"

#ifdef WIN32
#ifdef CAT_MEMLEAK_DETECT
#include "vld.h"
#endif
#endif

#ifdef __linux__
char version[]  __attribute__((section(".ccat_version"))) = CCAT_VERSION;
#endif

static volatile int g_cat_init = 0;
static uint64_t batchTransactionErrorCount = 0;
static uint64_t batchEventErrorCount = 0;
static uint64_t batchLogShowUpThreshold = 10000;

extern volatile int g_cat_enabled;
extern CatMessage* g_cat_nullMsg;
extern CatTransaction* g_cat_nullTrans;
extern CatProblemFilter g_problem_filter;
extern CatClientInfo g_client_info;

void default_cat_info_log(const char *format, ...);
void default_cat_debug_log(const char *format, ...);
void default_cat_error_log(const char *format, ...);
void default_cat_warning_log(const char *format, ...);

void stopCatBatchDispatcher();

CatLogger default_cat_logger = {
        default_cat_info_log,
        default_cat_error_log,
        default_cat_warning_log,
        default_cat_debug_log,
};

CatClientConfig DEFAULT_CCAT_CONFIG = {
        CAT_ENCODER_BINARY,
        1,  // enable heartbeat
        1,  // enable sampling
        1, // no longer used
        0,  // disable auto initialize when forked
        CAT_LOG_INFO,  // only log info level
        &default_cat_logger,
        CAT_DEFAULT_SUB_COMPONENT_NAME,
        0,
        0,
};

int catDisableHeartbeat() {
    DEFAULT_CCAT_CONFIG.enableHeartbeat = 0;
    g_config.enableHeartbeat = 0;
    return 0;
}

void catClientInitWithSingleProcessModel() {
    DEFAULT_CCAT_CONFIG.enableMultiprocessing = 1;
}

int catSetLanguageBinding(const char *language, const char *language_version) {
    g_client_info.language = catsdsnew(language);
    g_client_info.language_version = catsdsnew(language_version);
    return 0;
}

int registerComponentSwitch(CatClientConfig *mainConfig, char *switchName) {
    if (switchName == NULL) {
        return -2;
    }

    if (strlen(switchName) == 0) {
        return -2;
    }

    if (strcmp(CAT_DEFAULT_SUB_COMPONENT_NAME, mainConfig->componentSwitch) != 0) {
        mainConfig->logger->error("component switch already registered, %s", mainConfig->componentSwitch);
        return -1;
    }

    mainConfig->componentSwitch = switchName;
    return 0;
}

static int catClientInitInner() {
    g_cat_init = 1;

    initProblemFilter();

    initMessageIdHelper();

    initCatAggregator();
    initCatMonitor();
    initCatRouter();
    initCatSender();
    if (initConfigChangeListenerMap()) {
        return 1;
    }

    resetCatContext();

    // TODO Refactor it.
    if (!updateMetaConfig()) {
        g_cat_init = 0;
        g_cat_enabled = 0;
        g_config.logger->error("Initialize failed: Can't get meta config from remote server.");
        return 1;
    }

    startCatAggregatorThread();
    startCatMonitorThread();
    startCatSenderThread();
    return 0;
}

static void catClientInitInnerForked() {
    g_cat_init = 0;

    // Disable the heartbeat if the process is forked from another thread.
    g_config.enableHeartbeat = 0;
    g_config.logger->info("Master process has been forked, heartbeat will be disabled.");

    if (g_config.enableAutoInitialize) {
        if (catClientInitInner()) {
            g_config.logger->info("failed to init cat at fork");
            return;
        }
        g_config.logger->info("All cat threads has been reestablished automatically.");
    }
}

/**
 * @param domain
 * @return
 */
int catClientInit(const char *domain) {
    return catClientInitWithConfig(domain, &DEFAULT_CCAT_CONFIG);
}

/**
 * TODO Need a mutex lock to ensure thread safe.
 * @param domain
 * @param config
 * @return
 */
int catClientInitWithConfig(const char *domain, CatClientConfig *config) {
    if (g_cat_init) {
        return 0;
    }
    g_cat_init = 1;

    signal(SIGPIPE, SIG_IGN);

    initCatClientConfig(config);

    initCatStatistic();

    if (loadCatClientConfig(DEFAULT_XML_FILE) < 0) {
        g_cat_init = 0;
        g_cat_enabled = 0;
        g_config.logger->error("Failed to initialize cat: Error occurred while loading client config.");
        return 0;
    }
    g_config.domain = catsdsnew(domain);

    initMessageManager(g_config.domain, g_config.hostname);

    if (catClientInitInner()) {
        g_config.logger->error("failed to init catclient");
        return 0;
    }

    pthread_atfork(NULL, NULL, catClientInitInnerForked);

    g_config.logger->info("Cat has been initialized with domain: %s.", domain);

    return 1;
}

const char *catVersion() {
    return CCAT_VERSION;
}

int catClientDestroy() {
    g_cat_enabled = 0;
    g_cat_init = 0;

    destroyCatAggregator();

    clearCatMonitor();
    clearCatSender();
    clearCatRouter();

    stopCatBatchDispatcher();
    destroyCatMessageManager();
    destroyCatMessageIdHelper();
    deleteProblemFilter();
    destroyConfigChangeListenerMap();

    clearCatClientConfig();

    return 1;
}

void stopCatBatchDispatcher() {
    if (g_config.transactionBatchQueueCapacity > 0) {
        StopCatBatchDispatcher(g_config.transactionBatchDispatcher);
        deleteCatMPSCQueue(g_config.transactionBatchDispatcher->batchQueue);
        free(g_config.transactionBatchDispatcher);
    }

    if (g_config.eventBatchQueueCapacity > 0) {
        StopCatBatchDispatcher(g_config.eventBatchDispatcher);
        deleteCatMPSCQueue(g_config.eventBatchDispatcher->batchQueue);
        free(g_config.eventBatchDispatcher);
    }
}

void logTransaction(const char *type, const char *name, const char *status, const char *nameValuePairs,
                    unsigned long long durationMs) {
    if (!isCatEnabled()) {
        return;
    }
    CatTransaction *trans = newTransaction(type, name);
    catCheckPtr(trans);
    if (trans == NULL) {
        return;
    }
    if (nameValuePairs != NULL) {
        trans->addDataPair((CatMessage *) trans, nameValuePairs);
    }
    trans->setStatus((CatMessage *) trans, status);
    trans->setDurationInMillis(trans, durationMs);
    trans->setComplete((CatMessage *) trans);
}

void logEvent(const char *type, const char *name, const char *status, const char *nameValuePairs) {
    if (!isCatEnabled()) {
        return;
    }
    CatEvent *event = newEvent(type, name);
    catCheckPtr(event);
    if (event == NULL) {
        return;
    }
    if (nameValuePairs != NULL) {
        event->addDataPair(event, nameValuePairs);
    }
    event->setStatus(event, status);
    event->setComplete(event);
}

void logEventWithTime(const char *type, const char *name, const char *status, const char *nameValuePairs,
                      unsigned long long timeStamp) {
    if (!isCatEnabled()) {
        return;
    }
    CatEvent *event = newEvent(type, name);
    catCheckPtr(event);
    if (event == NULL) {
        return;
    }
    if (nameValuePairs != NULL) {
        event->addDataPair(event, nameValuePairs);
    }

    CatMessageInner *pInner = getInnerMsg(event);
    pInner->timestampInMillis = timeStamp;

    event->setStatus(event, status);
    event->setComplete(event);
}

void logMetricForCount(const char *name) {
    if (!isCatEnabled()) {
        return;
    }
    addCountMetricToAggregator(name, 1);
}

void logMetricForCountQuantity(const char *name, int quantity) {
    if (!isCatEnabled()) {
        return;
    }
    addCountMetricToAggregator(name, quantity);
}

void logMetricForDuration(const char *name, unsigned long long durationMs) {
    if (!isCatEnabled()) {
        return;
    }
    addTimerMetricToAggregator(name, (int) durationMs);
}

void logMetricForLatestValue(const char *name, int quantity) {
    if (!isCatEnabled()) {
        return;
    }
    addLatestMetricToAggregator(name, quantity);
}

void logError(const char *msg, const char *errStr) {
    if (!isCatEnabled()) {
        return;
    }
    if (g_problem_filter.hit(msg)) {
        setCatMessageTreeCanDiscard(0);
    }
    logEvent("Exception", msg, "ERROR", errStr);
}

void logErrorWithCodeLocation(const char *type, const char *name, const char *data, const char *fileName,
                              const char *functionName, int lineNo) {
    if (!isCatEnabled()) {
        return;
    }

    CatEvent *event = newEvent(type, name);
    if (event == NULL) {
        return;
    }

    if (data != NULL) {
        event->addDataPair(event, data);
    }
    event->addData(event, "fileName", fileName);
    event->addData(event, "functionName", functionName);

    char buf[32];
    catItoA(lineNo, buf, 10);
    event->addData(event, "lineNo", buf);

    event->setStatus(event, CAT_FAIL);
    event->setComplete(event);
}

CatEvent *newEvent(const char *type, const char *name) {
    if (!isCatEnabled()) {
        return g_cat_nullMsg;
    }
    getCatContext();
    CatEvent *event = createCatEvent(type, name);
    catCheckPtr(event);
    return event;
}

CatMetric *newMetric(const char *type, const char *name) {
    if (!isCatEnabled()) {
        return g_cat_nullMsg;
    }
    getCatContext();
    CatMetric *metric = createCatMetric(type, name);
    catCheckPtr(metric);
    return metric;
}

CatHeartBeat *newHeartBeat(const char *type, const char *name) {
    if (!isCatEnabled()) {
        return g_cat_nullMsg;
    }
    setCatMessageTreeCanDiscard(0);

    CatHeartBeat *hb = createCatHeartBeat(type, name);
    catCheckPtr(hb);
    return hb;
}

CatTransaction *newTransaction(const char *type, const char *name) {
    if (!isCatEnabled()) {
        return g_cat_nullTrans;
    }
    getCatContext();

    CatTransaction *trans = createCatTransaction(type, name, catMessageManagerEndTrans);
    catCheckPtr(trans);
    if (trans == NULL) {
        return NULL;
    }
    catMessageManagerStartTrans(trans);
    return trans;
}

CatTransaction *newTransactionWithDuration(const char *type, const char *name, unsigned long long durationMs) {
    if (!isCatEnabled()) {
        return g_cat_nullTrans;
    }
    getCatContext();
    CatTransaction *trans = createCatTransaction(type, name, catMessageManagerEndTrans);

    setCatTransactionDurationUs(trans, durationMs * 1000);
    catCheckPtr(trans);
    if (trans == NULL) {
        return NULL;
    }
    catMessageManagerStartTrans(trans);
    return trans;
}

void newCompletedTransactionWithDuration(const char *type, const char *name, unsigned long long durationMs) {
    if (!isCatEnabled()) {
        return;
    }
    CatTransaction *trans = newTransactionWithDuration(type, name, durationMs);
    if (durationMs > 0 && durationMs < 60 * 1000) {
        setMessageTimestamp((CatMessage *) trans, GetTime64() - durationMs);
    }
    trans->setComplete((CatMessage *) trans);
}

void logBatchTransaction(const char *type, const char *name, int count, int error, unsigned long long durationMsSum) {
    if (!isCatEnabled()) {
        return;
    }
    if (g_config.transactionBatchQueueCapacity <= 0) {
        logBatchTransToAggregator(type, name, count, error, durationMsSum);
        return;
    }
    int status = DispatchTransactionToBatchDispatcher(
        g_config.transactionBatchDispatcher,
        type, name, count, error, durationMsSum
    );
    if (status) {
        if (batchTransactionErrorCount++ % batchLogShowUpThreshold != 0) {
            return;
        }
        g_config.logger->error(
                "failed to enqueue batch transaction, current batch transaction queue size is %d, try to increase it!!",
                g_config.transactionBatchQueueCapacity);
    }
}

void logBatchEvent(const char *type, const char *name, int count, int error) {
    if (!isCatEnabled()) {
        return;
    }
    if (g_config.eventBatchQueueCapacity <= 0) {
        logBatchEventToAggregator(type, name, count, error);
        return;
    }
    int status = DispatchEventToBatchDispatcher(
        g_config.eventBatchDispatcher,
        type, name, count, error
    );
    if (status) {
        if (batchEventErrorCount++ % batchLogShowUpThreshold != 0) {
            return;
        }
        g_config.logger->error(
                "failed to enqueue batch event, current batch event queue size is %d, try to increase it!!",
                g_config.eventBatchQueueCapacity
        );
    }
}

void setTransactionStatus(CatTransaction *transaction, const char *status) {
    if (!isCatEnabled()) {
        return;
    }
    transaction->setStatus((CatMessage *) transaction, status);
}

void setTransactionTimestamp(CatTransaction *transaction, unsigned long long timestampMs) {
    if (!isCatEnabled()) {
        return;
    }
    setMessageTimestamp((CatMessage *) transaction, timestampMs);
}

void completeTransaction(CatTransaction *transaction) {
    if (!isCatEnabled()) {
        return;
    }
    transaction->setComplete((CatMessage *) transaction);
}

void addTransactionDataPair(CatTransaction *transaction, const char *data) {
    if (!isCatEnabled()) {
        return;
    }
    transaction->addDataPair((CatMessage *) transaction, data);
}

void setMessageStatus(CatMessage *message, const char *status) {
    if (!isCatEnabled()) {
        return;
    }
    message->setStatus(message, status);
}

void setMessageTimestamp(CatMessage *message, unsigned long long timestampMs) {
    if (!isCatEnabled()) {
        return;
    }
    CatMessageInner *inner = getInnerMsg(message);
    inner->timestampInMillis = timestampMs;
}

void completeMessage(CatMessage *message) {
    if (!isCatEnabled()) {
        return;
    }
    message->setComplete(message);
}

void addMessageData(CatMessage *message, const char *data) {
    if (!isCatEnabled()) {
        return;
    }
    message->addDataPair(message, data);
}

void addMetricTag(CatMetricHelper *pHelper, const char *key, const char *val) {
    if (!isCatEnabled()) {
        return;
    }
    pHelper->AddTag(pHelper, key, val);
}

void addMetricName(CatMetricHelper *pHelper, const char *name) {
    if (!isCatEnabled()) {
        return;
    }
    pHelper->AddName(pHelper, name);
}

void addMetricCount(CatMetricHelper *pHelper, int count) {
    if (!isCatEnabled()) {
        return;
    }
    pHelper->AddCount(pHelper, count);
}

void addMetricDuration(CatMetricHelper *pHelper, unsigned long long durationMs) {
    if (!isCatEnabled()) {
        return;
    }
    pHelper->AddDuration(pHelper, durationMs);
}

char *createMessageId() {
    if (!isCatEnabled()) {
        return NULL;
    }
    return getNextMessageId();
}

/*
 * create a messageId for message link.
 * It is the user's responsibility to free the returned memory after use.
 * */
char *createRemoteServerMessageId(const char *domain) {
    if (!isCatEnabled()) {
        return NULL;
    }
    return getNextMessageIdByDomain(domain);
}

char *getThreadLocalMessageTreeId() {
    if (!isCatEnabled()) {
        return NULL;
    }
    return getContextMessageTree()->messageId;
}

char *getThreadLocalMessageTreeRootId() {
    if (!isCatEnabled()) {
        return NULL;
    }
    return getContextMessageTree()->rootMessageId;
}

char *getThreadLocalMessageTreeParentId() {
    if (!isCatEnabled()) {
        return NULL;
    }
    return getContextMessageTree()->parentMessageId;
}

void setThreadLocalMessageTreeId(const char *messageId, const char *rootMessageId, const char *parentMessageId) {
    if (!isCatEnabled()) {
        return;
    }
    CatMessageTree *pTree = getContextMessageTree();

    if (pTree->messageId != NULL) {
        catsdsfree(pTree->messageId);
        pTree->messageId = NULL;
    }
    if (pTree->parentMessageId != NULL) {
        catsdsfree(pTree->parentMessageId);
        pTree->parentMessageId = NULL;
    }
    if (pTree->rootMessageId != NULL) {
        catsdsfree(pTree->rootMessageId);
        pTree->rootMessageId = NULL;
    }

    pTree->messageId = catsdsnew(messageId);
    pTree->rootMessageId = catsdsnew(rootMessageId);
    pTree->parentMessageId = catsdsnew(parentMessageId);
}

CatEvent *createCatEvent(const char *type, const char *name) {
    return createEvent(type, name, catMessageManagerAdd);
}

CatHeartBeat *createCatHeartBeat(const char *type, const char *name) {
    return createHeartBeat(type, name, catMessageManagerAdd);
}

CatMetric *createCatMetric(const char *type, const char *name) {
    return createMetric(type, name, catMessageManagerAdd);
}
