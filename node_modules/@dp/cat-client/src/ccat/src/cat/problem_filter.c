//
// Created by Terence Fan on 3/6/19.
//

#include "problem_filter.h"
#include "consts.h"
#include "message/message_imp.h"

#include "lib/cat_time_util.h"

#define millis2minute(x) (int) (x / 1000 / 60) % 60

struct _ProblemFilter g_problem_filter = {};

extern unsigned int catDictStringCopyHTHashFunction(const void *key);

extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);

extern void *catDictStringKeyValCopyHTValDup(void *privdata, const void *val);

extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1,
                                         const void *key2);

extern void catDictStringCopyHTKeyDestructor(void *privdata, void *key);

static void _freeInterceptorCounterFun(void* privdata, void* val) {
    free((CAT_ATOMICLONG *) val);
}

static void* _createInterceptorCounterFun(CatCCHashMap *pCCHM, void *key, void *pParam) {
    CAT_ATOMICLONG *count = (CAT_ATOMICLONG *) calloc(1, sizeof(CAT_ATOMICLONG));
    catCheckPtr(count);
    return count;
}

catDictType dictInterceptor = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                                 /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        _freeInterceptorCounterFun            /* val destructor */
};

int isErrorMessage(CatMessageInner* message) {
    if (strcmp(message->status, CAT_SUCCESS) != 0) {
        return 1;
    }

    return 0;
}

int isProblem(CatTransaction* trans) {
    CatTransactionInner* pInner = getInnerTrans(trans);
    return isErrorMessage(&(pInner->inner));
}

static int _hit(const char* name, int minute) {
    if (minute < 0 || minute >= 60) {
        return 0;
    }

    ProblemInterceptor* interceptor = g_problem_filter.interceptors[minute];
    CAT_ATOMICLONG *count = (CAT_ATOMICLONG *) catFindCCHashMapCreateByFun(interceptor->map, name, _createInterceptorCounterFun,
                                                                           NULL);
    return CAT_ATOMICLONG_INC(count) <= interceptor->capacity;
}

int hit(const char* name) {
    int minute = millis2minute(GetTime64());
    return _hit(name, minute);
}

int hitTrans(CatTransaction* trans) {
    CatTransactionInner* pInner = getInnerTrans(trans);
    catsds type = pInner->inner.type;
    catsds name = pInner->inner.name;

    if (catsdslen(type) + catsdslen(name) > 500) {
        // Transaction will always be aggregated if len(type) + len(name) > 500
        return 0;
    }

    char id[512] = {0};
    strcat(id, type);
    strcat(id, "#");
    strcat(id, name);

    int minute = millis2minute(pInner->inner.timestampInMillis);
    return _hit(id, minute);
}

ProblemInterceptor* newProblemInterceptor(int capacity) {
    ProblemInterceptor* interceptor = calloc(1, sizeof(ProblemInterceptor));
    interceptor->capacity = capacity;
    interceptor->map = catCreateCCHashMap(&dictInterceptor, 16, NULL);
    return interceptor;
}

void deleteProblemInterceptor(ProblemInterceptor* interceptor) {
    catDestroyCCHashMap(interceptor->map);
    free(interceptor);
}

int clearCache() {
    ProblemInterceptor* interceptor;

    int minute = millis2minute(GetTime64());
    for (int i = 1; i < 4; i++) {
        interceptor = g_problem_filter.interceptors[(minute + i) % 60];
        catClearCCHashMap(interceptor->map);
    }
    for (int i = 54; i < 57; i++) {
        interceptor = g_problem_filter.interceptors[(minute + i) % 60];
        catClearCCHashMap(interceptor->map);
    }

    return 0;
}

int initProblemFilter() {
    g_problem_filter.interceptors = calloc(60, sizeof(ProblemInterceptor));
    for (int i = 0; i < 60; i++) {
        g_problem_filter.interceptors[i] = newProblemInterceptor(DEFAULT_FAIL_LOG_LIMIT);
    }

    g_problem_filter.hit = hit;
    g_problem_filter.hitTrans = hitTrans;
    g_problem_filter.isProblem = isProblem;
    g_problem_filter.clearCache = clearCache;

    return 0;
}

int deleteProblemFilter() {
    for (int i = 0; i < 60; i++) {
        deleteProblemInterceptor(g_problem_filter.interceptors[i]);
    }

    return 0;
}

void resetFailLogLimit(int newLimit) {
    for (int i = 0; i < 60; ++i) {
        g_problem_filter.interceptors[i]->capacity = newLimit;
    }
}