#include "aggregator_metric_tag.h"

#include "client_config.h"
#include "context.h"

#include "lib/cat_sds.h"
#include "lib/cat_ccmap.h"
#include "aggregator.h"

typedef struct _CatMetricItemData {
    CAT_ATOMICLONG m_count;
    CAT_ATOMICLONG m_durationMsSum;
    catsds m_key;

} CatMetricItemData;


static CatCCHashMap *g_metricTagAggregator;


catsds CatBuildTagKey(catDict *tags) {
    catsds tagKey = catsdsnewEmpty(32);
    int first = 1;
    if (tags == NULL) {
        return tagKey;
    }
    catDictIterator *pIter = catDictGetIterator(tags);
    if (pIter == NULL) {
        return tagKey;
    }
    catDictEntry *pEntry = NULL;
    while ((pEntry = catDictNext(pIter)) != NULL) {
        if (!first) {
            tagKey = catsdscatchar(tagKey, '&');
        } else {
            first = 0;
        }

        tagKey = catsdscat(tagKey, (char *) pEntry->key);
        tagKey = catsdscatchar(tagKey, '=');
        tagKey = catsdscat(tagKey, (char *) pEntry->val);
    }
    catDictReleaseIterator(pIter);
    return tagKey;
}

static inline catDict *createCatMetricMapData();

static inline CatMetricItemData *createCatMetricItemData() {
    CatMetricItemData *pData = (CatMetricItemData *) malloc(sizeof(CatMetricItemData));
    catCheckPtr(pData);
    if (pData == NULL) {
        return NULL;
    }
    pData->m_count = 0;
    pData->m_durationMsSum = 0;
    pData->m_key = catsdsempty();
    return pData;
}

static inline void destroyCatMetricItemData(CatMetricItemData *pData) {
    if (pData == NULL) {
        return;
    }
    catsdsfree(pData->m_key);
    free(pData);
}

static inline void addCountMetricToData(CatMetricItemData *pData, int value) {
    CAT_ATOMICLONG_ADD(&pData->m_count, value);
}


static inline void addTimerMetricToData(CatMetricItemData *pData, unsigned long long timeMs) {
    CAT_ATOMICLONG_INC(&pData->m_count);
    CAT_ATOMICLONG_ADD(&pData->m_durationMsSum, timeMs);
}

static void newAggregatorMetricItem(char *name, char *status, char *keyValuePairs) {
    CatMetric *metric = newMetric("", name);
    catCheckPtr(metric);
    if (metric == NULL) {
        return;
    }
    if (keyValuePairs != NULL) {
        metric->addDataPair(metric, keyValuePairs);
    }
    metric->setStatus(metric, status);
    metric->setComplete(metric);
}

static void MetricDataValOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    char tmpBuf[32];
    catDict *pDict = (catDict *) (*ppVal);

    char *keyName = (char *) key;

    catDictIterator *pIter = catDictGetIterator(pDict);
    if (pIter == NULL) {
        return;
    }
    catsds valStr = catsdsnewEmpty(64);
    catDictEntry *pEntry = NULL;
    while ((pEntry = catDictNext(pIter)) != NULL) {
        char *keyItem = (char *) pEntry->key;
        CatMetricItemData *pItem = (CatMetricItemData *) pEntry->val;

        if (keyItem == NULL || pItem == NULL || valStr == NULL) {
            continue;
        }
        catsdsclear(valStr);
        long count = pItem->m_count;
        long sum = pItem->m_durationMsSum;

        if (count > 0) {
            if (sum > 0) {
                valStr = catsdscat(valStr, catItoA(count, tmpBuf, 10));
                valStr = catsdscatchar(valStr, ',');
                valStr = catsdscat(valStr, catItoA(sum, tmpBuf, 10));
                valStr = catsdscatchar(valStr, ',');
                valStr = catsdscat(valStr, keyItem);
                newAggregatorMetricItem(keyName, "TD", valStr);
            } else {
                valStr = catsdscat(valStr, catItoA(count, tmpBuf, 10));
                valStr = catsdscatchar(valStr, ',');
                valStr = catsdscat(valStr, catItoA(count, tmpBuf, 10));
                valStr = catsdscatchar(valStr, ',');
                valStr = catsdscat(valStr, keyItem);
                newAggregatorMetricItem(keyName, "TC", valStr);
            }
        }

        pItem->m_count = 0;
        pItem->m_durationMsSum = 0;
    }
    catDictReleaseIterator(pIter);
    catsdsfree(valStr);
}

static void sendMetricItemDataNoClear() {
    catOptEveryCCHashMapItem(g_metricTagAggregator, MetricDataValOptFun, NULL);
}

static void sendMetricTagDataClear() {
    catDict **pDictArray = catMoveCCHashMap(g_metricTagAggregator);
    catDict **pHeadDictArray = pDictArray;
    catCheckPtr(pDictArray);
    if (pDictArray == NULL) {
        return;
    }
    catDict *pDict = NULL;
    while ((pDict = *pDictArray++) != NULL) {
        catDictIterator *iter = catDictGetIterator(pDict);
        if (iter != NULL) {
            catDictEntry *pEntry = NULL;
            while ((pEntry = catDictNext(iter)) != NULL) {
                MetricDataValOptFun(NULL, pEntry->key, &pEntry->val, NULL);
            }
            catDictReleaseIterator(iter);
        }
        catDictRelease(pDict);
    }
    catFreeDictArray(pHeadDictArray);
}

typedef struct _TagParamData {
    catsds itemKey;
    unsigned long long val;
} TagParamData;

static CatMetricItemData *getMetricItemByCreate(catDict *pItemMap, catsds itemKey) {
    catDictEntry *pRst = catDictFind(pItemMap, (void *) itemKey);
    CatMetricItemData *pItem = NULL;
    if (pRst == NULL) {
        if (pItemMap->used > 10000) {
            logEvent("cat.TooManyTagValuesForMetric", itemKey, CAT_SUCCESS, NULL);

            char *otherKey = "others";
            pRst = catDictFind(pItemMap, (void *) otherKey);

            if (pRst == NULL) {
                pItem = createCatMetricItemData();
                catDictAdd(pItemMap, otherKey, pItem);
            } else {
                pItem = (CatMetricItemData *) pRst->val;
            }
        } else {
            pItem = createCatMetricItemData();
            catDictAdd(pItemMap, itemKey, pItem);
        }
    } else {
        pItem = (CatMetricItemData *) pRst->val;
    }
    return pItem;
}

static void findValCountOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    catDict *pItemMap = (catDict *) pVal;
    TagParamData *pTagParam = (TagParamData *) pParam;
    CatMetricItemData *pItem = getMetricItemByCreate(pItemMap, pTagParam->itemKey);
    addCountMetricToData(pItem, pTagParam->val);
}

static void findValTimerOptFun(CatCCHashMap *pCCHM, void *key, volatile void **ppVal, void *pParam) {
    volatile void *pVal = *ppVal;
    catDict *pItemMap = (catDict *) pVal;
    TagParamData *pTagParam = (TagParamData *) pParam;
    CatMetricItemData *pItem = getMetricItemByCreate(pItemMap, pTagParam->itemKey);
    addTimerMetricToData(pItem, pTagParam->val);
}


static void *createValFun(CatCCHashMap *pCCHM, void *key, void *pParam) {
    return createCatMetricMapData();
}


void addCountMetricToTagAggregator(const char *name, int count, catDict *tagMap) {
    catsds itemKey = CatBuildTagKey(tagMap);
    if (itemKey == NULL) {
        return;
    }
    TagParamData data;
    data.itemKey = itemKey;
    data.val = count;
    catFindCCHashMapCreateByFunAndOperate(g_metricTagAggregator, (char *) name, createValFun,
                                          NULL, findValCountOptFun, (void *) &data);
    catsdsfree(itemKey);
}

void addTimerMetricToTagAggregator(const char *name, unsigned long long timeMs, catDict *tagMap) {
    catsds itemKey = CatBuildTagKey(tagMap);
    if (itemKey == NULL) {
        return;
    }
    TagParamData data;
    data.itemKey = itemKey;
    data.val = timeMs;
    catFindCCHashMapCreateByFunAndOperate(g_metricTagAggregator, (char *) name, createValFun,
                                          NULL, findValTimerOptFun, (void *) &data);
    catsdsfree(itemKey);
}

static void _sendMetricTagAggregationData() {
    sendMetricItemDataNoClear();
}

void sendMetricTagData() {
    sendAggregationData(g_metricTagAggregator, "MetricTagAggregator", _sendMetricTagAggregationData);
}

extern unsigned int catDictStringCopyHTHashFunction(const void *key);

extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);

extern void *catDictStringKeyValCopyHTValDup(void *privdata, const void *val);

extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1,
                                         const void *key2);

extern void catDictStringCopyHTKeyDestructor(void *privdata, void *key);


static void CatMetricItemMapDataFreeFun(void *privdata, void *val) {
    destroyCatMetricItemData((CatMetricItemData *) val);
}

static void CatMetricTagMapDataFreeFun(void *privdata, void *val) {
    catDictRelease((catDict *) val);
}

catDictType dictTypeCatTagMap = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        catDictStringCopyHTKeyDup,              /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        catDictStringCopyHTKeyDestructor  /* val destructor */
};

catDict *CatTagMapAdd(catDict *pTagMap, const char *key, const char *val) {
    if (pTagMap == NULL) {
        pTagMap = catDictCreate(&dictTypeCatTagMap, NULL);
        if (pTagMap == NULL) {
            return pTagMap;
        }
    }
    catDictAdd(pTagMap, (void *) key, (void *) val);
    return pTagMap;
}

void CatTagMapRelease(catDict *pTagMap) {
    if (pTagMap != NULL) {
        catDictRelease(pTagMap);
    }
}

catDictType dictTypeCatMetricItemAggregator = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                               /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        CatMetricItemMapDataFreeFun  /* val destructor */
};

static inline catDict *createCatMetricMapData() {
    return catDictCreate(&dictTypeCatMetricItemAggregator, NULL);
}

catDictType dictTypeCatMetricTagAggregator = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                               /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        CatMetricTagMapDataFreeFun  /* val destructor */
};

void initCatMetricTagAggregator() {
    g_metricTagAggregator = catCreateCCHashMap(&dictTypeCatMetricTagAggregator, g_config.slotCount, NULL);
    catCheckPtr(g_metricTagAggregator);
}

void destroyCatMetricTagAggregator() {
    catDestroyCCHashMap(g_metricTagAggregator);
}