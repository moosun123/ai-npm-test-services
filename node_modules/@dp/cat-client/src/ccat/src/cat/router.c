#include "router.h"

#include "client_config.h"
#include "message_manager.h"
#include "router_json_parser.h"

#include "lib/ae.h"
#include "lib/cat_anet.h"
#include "lib/cat_mutex.h"
#include "lib/headers.h"

#if defined(__linux)
#include <linux/tcp.h>
#include <sys/types.h>
#include <sys/socket.h>
#elif defined(__APPLE__)
#endif


#define RouterHttpConnectTimeout 200
#define RouterHttpWriteTimeout 500
#define RouterHttpReadTimeout 3000

static catsds g_server_ips[64] = {0};
static unsigned short g_server_ports[64] = {0};
static volatile int g_server_count = 0;

static CatCriticalSection g_server_lock = NULL;
extern int g_cat_send_port;
extern CatMessageManager g_cat_messageManager;
extern char g_cat_send_ip[64];
extern int g_cat_send_fd;


static int tryConnBestServer() {
    for (int i = 0; i < g_server_count; ++i) {
        catsds host = g_server_ips[i];
        int port = g_server_ports[i];
        int oldFd = g_cat_send_fd;
        if (oldFd > 0 && g_cat_send_port == port && strcmp(g_cat_send_ip, host) == 0) {
            g_config.logger->info("Current connection %s:%d is same as given server.", g_cat_send_ip, g_cat_send_port);
            return 1;
        }
        g_config.logger->info("Trying to connect to server %s:%d.", host, port);
        int newFd = catAnetTcpNonBlockConnect(NULL, g_server_ips[i], g_server_ports[i]);
        if (newFd > 0) {
            int retVal = catAeWait(newFd, AE_WRITABLE | AE_ERROR | AE_HUP, 200);
            if (retVal > 0 && !(retVal & AE_ERROR) && (retVal & AE_WRITABLE)) {
                g_config.logger->info("Connection has been established successfully.");
                strcpy(g_cat_send_ip, host);
                g_cat_send_port = (unsigned short) port;
                g_cat_send_fd = newFd;

                struct linger linger;
                linger.l_onoff = 1;
                linger.l_linger = 0;
                setsockopt(g_cat_send_fd, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger)); // 直接释放连接

                if (oldFd > 0) {
                    catAnetClose(oldFd);
                }
                return 1;
            } else {
                g_config.logger->warning("Cannot connect to server %s:%d.", host, port);
                catAnetClose(newFd);
            }
        }
    }

    return 0;
}

static int checkIpValid(const char *ip, size_t ipLen) {
    if (ipLen < 7 || ipLen > 15) {
        return 0;
    }
    size_t i = 0;
    int splitCount = 0;
    for (; i < ipLen; ++i) {
        if (ip[i] == '.') {
            ++splitCount;
        } else if (ip[i] < '0' || ip[i] > '9') {
            return 0;
        }
    }
    if (splitCount != 3) {
        return 0;
    }
    return 1;
}

// resolve ip such as "192.168.110.111:9090"
static int resolveIpPortStr(catsds ipPortStr, catsds *ip, unsigned short *port) {
    size_t i = 0;

    for (; i < catsdslen(ipPortStr); ++i) {
        if (ipPortStr[i] == ':') {
            if (*ip == NULL) {
                *ip = catsdsnewEmpty(16);
            }
            // check valid
            if (!checkIpValid(ipPortStr, i)) {
                return 0;
            }
            *ip = catsdscpylen(*ip, ipPortStr, i);
            long lPort = atol(ipPortStr + i + 1);
            if (lPort <= 0 || lPort > 65536) {
                *port = 2280;
            } else {
                *port = (unsigned short) lPort;
            }
            return 1;
        }
    }
    return 0;
}

int resolveServerIps(char *routerIps) {
    int i = 0;
    int count = 0;
    int validIpCount = 0;
    catsds *spIpPorts = catsdssplitlen(routerIps, (int) strlen(routerIps), ";", 1, &count);

    if (spIpPorts != NULL && count > 0) {
    } else {
        return 0;
    }


    for (i = 0; i < g_server_count; ++i) {
        catsdsfree(g_server_ips[i]);
        g_server_ips[i] = NULL;
    }

    for (i = 0; i < count && i < 64; ++i) {
        if (resolveIpPortStr(spIpPorts[i], g_server_ips + validIpCount, g_server_ports + validIpCount) > 0) {
            ++validIpCount;
        }
    }
    catsdsfreesplitres(spIpPorts, count);
    g_server_count = validIpCount;
    return validIpCount;
}

static catsds buildRequestBuf(char *hostname, int port, char *domain) {
    catsds buf = catsdsnewEmpty(1024);
    buf = catsdscatprintf(
            buf,
            "GET http://%s:%d/cat/s/router?op=json&domain=%s&ip=%s&env=%s&hostname=%s HTTP/1.0\r\n",
            hostname,
            port,
            domain,
            g_cat_messageManager.ip,
            g_config.env,
            g_cat_messageManager.hostname
    );

    buf = catsdscatprintf(buf, "Host: %s\r\n", hostname);
    buf = catsdscatprintf(buf, "Connection: close\r\n\r\n");
    return buf;
}

static int strHashcode(const char *str, int maxLen) {
    int i, h = 0;
    for (i = 0; i < maxLen; i++) {
        if (str[i] == '\0') {
            break;
        }
        h = 31 * h + str[i];
    }
    return h;
}

/**
 * @param hostname
 * @param port
 * @param domain
 * @return 0 if failed else server count.
 */
static int getRouterFromServer(char *hostname, int port, char *domain) {
    char destIP[128];
    if (catAnetResolveIP(NULL, hostname, destIP, 128) == CAT_ANET_ERR) {
        return 0;
    }

    g_config.logger->info("Try connecting to router server %s:%d.", destIP, port);
    int sockfd = catAnetTcpNonBlockConnect(NULL, destIP, port);
    if (sockfd < 0) {
        g_config.logger->warning("Failed in connecting to router server.");
        return 0;
    }

    // wait newFd to be writable
    int retVal = catAeWait(sockfd, AE_WRITABLE | AE_ERROR | AE_HUP, RouterHttpConnectTimeout);
    if (retVal > 0 && !(retVal & AE_ERROR) && (retVal & AE_WRITABLE)) {
        // Connection has been established successfully.
    } else {
        g_config.logger->warning("Failed in connecting to router server after %dms.", RouterHttpConnectTimeout);
        catAnetClose(sockfd);
        return 0;
    }

    catsds requestBuf = buildRequestBuf(hostname, port, domain);
    int status = catAnetBlockWriteTime(sockfd, requestBuf, (int) catsdslen(requestBuf), RouterHttpWriteTimeout);
    catsdsfree(requestBuf);

    if (status == CAT_ANET_ERR) {
        g_config.logger->warning("Failed in sending request after %dms.", RouterHttpConnectTimeout);
        catAnetClose(sockfd);
        return 0;
    }

    char resp[2048];
    status = catAnetBlockReadTime(sockfd, resp, 2047, RouterHttpReadTimeout);
    if (status == CAT_ANET_ERR || status < 4) {
        catAnetClose(sockfd);
        return 0;
    }
    resp[status] = '\0';

    // skip header.
    char *t = strstr(resp, "\r\n\r\n");
    if (NULL == t) {
        catAnetClose(sockfd);
        return 0;
    }

    // skip content-length
    char *body = t + 4;
    if (body[0] == '\0') {
        catAnetClose(sockfd);
        return 0;
    }
    catAnetClose(sockfd);
    g_config.logger->info("Got available router config from remote server:\n%s", body);

    static int routerBodyHashCode = 0;

    // determine if response body is changed or not.
    int h = strHashcode(body, 2048);
    if (h != routerBodyHashCode) {
        routerBodyHashCode = h;
        return parseCatJsonRouter(body);
    } else {
        return g_server_count;
    }
}

int recoverCatServerConn() {
    CATCS_ENTER(g_server_lock);
    catAnetClose(g_cat_send_fd);
    g_cat_send_fd = -1;

    if (!tryConnBestServer()) {
        g_config.logger->warning("恢复与服务器连接失败, 尝试更新路由.");
        if (!updateMetaConfig()) {
            g_config.logger->error("重试失败，服务器不可用。");
            CATCS_LEAVE(g_server_lock);
            return 0;
        }
    }

    CATCS_LEAVE(g_server_lock);
    return 1;
}

static int min(int a, int b) {
    return a > b ? b : a;
}


void initCatRouter() {
    g_server_lock = CatCreateCriticalSection();
    g_server_count = min(g_config.serverNum, 64);

    int validCount = 0;
    for (int i = 0; i < g_server_count; ++i) {
        if (resolveIpPortStr(g_config.serverAddresses[i], g_server_ips + validCount, g_server_ports + validCount)) {
            ++validCount;
        }
    }
    g_server_count = validCount;
}


void clearCatRouter() {
    int i = 0;
    CatDeleteCriticalSection(g_server_lock);
    if (g_cat_send_fd > 0) {
        catAnetClose(g_cat_send_fd);
    }
    for (i = 0; i < g_server_count; ++i) {
        catsdsfree(g_server_ips[i]);
        g_server_ips[i] = NULL;
    }
}

int socketConnected(int sock) {
#if defined(__APPLE__)
    return sock;
#else
    if (sock <= 0)
        return 0;
    struct tcp_info info;
    int len = sizeof(info);
    getsockopt(sock, IPPROTO_TCP, TCP_INFO, &info, (socklen_t *) &len);
    if ((info.tcpi_state == 1)) {
        return 1;
    } else {
        return 0;
    }
#endif
}

static inline int _checkCatActiveConn() {
    if (g_cat_send_fd <= 0) {
        return 0;
    }

    if (!socketConnected(g_cat_send_fd)) {
        g_config.logger->warning("Check Cat Server Fail, cannot connect to server %s:%d.", g_cat_send_ip,
                  g_cat_send_port);
        if (g_cat_send_fd > 0) {
            catAnetClose(g_cat_send_fd);
            g_cat_send_fd = -1;
        }

        recoverCatServerConn();
    }
    return 0;
}

int checkCatActiveConn() {
    CATCS_ENTER(g_server_lock);
    int r = _checkCatActiveConn();
    CATCS_LEAVE(g_server_lock);
    return r;
}

static int updateFromMetaService() {
    return getRouterFromServer("cat-meta.sankuai.com", 80, g_cat_messageManager.domain);
}

static int updateFromCachedService() {
    int index = 0; // TODO randomize
    for (int i = 0; i < 3; i++) {
        int offset = (index + i) % g_server_count;
        int rst = getRouterFromServer(g_server_ips[offset], 8080, g_cat_messageManager.domain);
        if (rst > 0) {
            return rst;
        }
    }
    return 0;
}

int updateMetaConfig() {
    CATCS_ENTER(g_server_lock);
    int rst = updateFromCachedService();
    if (rst > 0) {
        tryConnBestServer();
    } else {
        g_config.logger->warning("UpdateMetaConfig Fail, cannot connect to server");
    }
    CATCS_LEAVE(g_server_lock);
    return rst;
}

