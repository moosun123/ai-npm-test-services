#include <stdlib.h>
#include <string.h>
#include "batch_dispatcher.h"
#include "cat/client_config.h"
#include "lib/cat_time_util.h"
#include "lib/cat_thread.h"

struct wrappedArgs {
    CatBatchDispatcher * dispatcher;
    catBatchAction batchAction;
};

static void wrappedDispatcherAction(void* input) {
    struct wrappedArgs* args = (struct wrappedArgs*)input;
    CatBatchDispatcher * dispatcher = args->dispatcher;
    if (dispatcher == NULL) {
        return;
    }
    CatMPSCQueue * queue = dispatcher->batchQueue;
    catBatchAction batchAction = args->batchAction;

    if (queue == NULL || batchAction == NULL) {
        return;
    }

    cat_set_thread_name(dispatcher->name);
    CatMPSCQueueHelper* queueOperator = queue->helper;

    while (dispatcher->running) {
        void* element = queueOperator->poll(queue);
        if (element == NULL) {
            Sleep(1000);
            continue;
        }

        CatBatchElement * ele = (CatBatchElement*)element;
        batchAction(ele->type, ele->name, ele->count, ele->error, ele->durationSumInMillis);
        free(ele);
    }
    free(input);

    g_config.logger->info("%s exiting...", dispatcher->name);
}

void createDispatcher(CatBatchDispatcher * dispatcher, catBatchAction pFunction) {
    struct wrappedArgs* args = (struct wrappedArgs*)malloc(sizeof(struct wrappedArgs));
    memset(args, 0, sizeof(struct wrappedArgs));
    args->dispatcher = dispatcher;
    args->batchAction = pFunction;

    pthread_create(&(dispatcher->dispatcher), NULL, wrappedDispatcherAction, (void*)args);
}

CatBatchDispatcher * NewCatBatchDispatcher(const char* name, catBatchAction batchAction, size_t queueSize) {
    CatBatchDispatcher * dispatcher = (CatBatchDispatcher*)malloc(sizeof(CatBatchDispatcher));
    memset(dispatcher, 0, sizeof(CatBatchDispatcher));

    dispatcher->name = name;
    dispatcher->batchQueue = newCatMPSCQueue(name, queueSize);
    dispatcher->batchAction = batchAction;
    dispatcher->running = 1;

    createDispatcher(dispatcher, batchAction);

    return dispatcher;
}

void StopCatBatchDispatcher(CatBatchDispatcher* batchDispatcher) {
    batchDispatcher->running = 0;
    int status = pthread_join(batchDispatcher->dispatcher, NULL);
    if (status != 0) {
        g_config.logger->error("error when waiting thread %s to finish", batchDispatcher->name);
    }
}

static int dispatchBatchElement(
    CatBatchDispatcher* dispatcher,
    const char *type,
    const char *name,
    int count,
    int error,
    unsigned long long durationSumInMillis
) {
    CatBatchElement * catBatchElement = (CatBatchElement *)malloc(sizeof(CatBatchElement));
    memset(catBatchElement, 0, sizeof(CatBatchElement));
    catBatchElement->type = type;
    catBatchElement->name = name;
    catBatchElement->count = count;
    catBatchElement->error = error;
    catBatchElement->durationSumInMillis = durationSumInMillis;

    CatMPSCQueueHelper* queueOperator = dispatcher->batchQueue->helper;
    if (queueOperator->offer(dispatcher->batchQueue, (void*)catBatchElement)) {
        return 1;
    }

    return 0;
}

int DispatchTransactionToBatchDispatcher(
    CatBatchDispatcher* dispatcher,
    const char *type,
    const char *name,
    int count,
    int error,
    unsigned long long durationMsSum
) {
    return dispatchBatchElement(dispatcher, type, name, count, error, durationMsSum);
}
int DispatchEventToBatchDispatcher(
    CatBatchDispatcher* dispatcher,
    const char *type,
    const char *name,
    int count,
    int error
) {
    return dispatchBatchElement(dispatcher, type, name, count, error, 0);
}

