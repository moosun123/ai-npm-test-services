#include "context.h"

#include "client_config.h"
#include "message_manager.h"
#include "transaction_helper.h"

#include "message/message_imp.h"

#include "lib/cat_thread.h"
#include "aggregator.h"
#include "aggregator_event.h"

extern CatMessageManager g_cat_messageManager;

CATTHREADLOCAL CatContext *g_cat_context = NULL;

static void catContextAddTransChild(CatContext* ctx, CatMessage *message, CatTransaction *trans) {
    unsigned long long treePeriod = catTrimToHour(getCatMessageTimeStamp(ctx->tree->root));
    unsigned long long messagePeriod = catTrimToHour(
            getCatMessageTimeStamp(message) - 10 * 1000L); // 10 seconds extra time allowed

    if (treePeriod < messagePeriod || ctx->elementSize >= g_config.maxContextElementSize) {
        truncateAndFlush(ctx, getCatMessageTimeStamp(message));
    }

    trans->addChild(trans, message);
    ++ctx->elementSize;
}

static void catContextAdjustForTruncatedTrans(CatContext* ctx, CatTransaction *root) {
    CatEvent *next = createEvent("TruncatedTransaction", "TotalDuration", NULL);
    unsigned long long actualDurationUs = ctx->lastTruncateTransDurationUs + getCatTransactionDurationUs(root);

    next->addDataPair(next, catsdsfromlonglong(actualDurationUs));
    next->setStatus(next, CAT_SUCCESS);
    root->addChild(root, next);

    ctx->lastTruncateTransDurationUs = 0;
}

CatContext *getCatContext() {
    if (g_cat_context == NULL) {
        g_cat_context = (CatContext *) malloc(sizeof(CatContext));

        catCheckPtr(g_cat_context);
        if (g_cat_context == NULL) {
            return NULL;
        }
        g_cat_context->lastTruncateTransDurationUs = 0;
        g_cat_context->elementSize = 0;

        newCatStack(128, &(g_cat_context->stack));
        catCheckPtr(g_cat_context->stack);

        g_cat_context->tree = newCatMessageTree();
        catCheckPtr(g_cat_context->tree);
        if (g_cat_context->tree != NULL) {
            g_cat_context->tree->root = NULL;

            int pid = cat_get_thread_id();
            char tmpBuf[32];
            g_cat_context->tree->threadId = catsdsnew(catItoA(pid, tmpBuf, 10));
            g_cat_context->tree->threadGroupName = catsdsnew("cat");
            g_cat_context->tree->threadName = catsdsnew("cat");
            catCheckPtr(g_cat_context->tree->threadName);
        }
    }
    return g_cat_context;
}

void deleteCatContext(CatContext* ctx) {
    if (NULL != ctx->tree) {
        deleteCatMessageTree(ctx->tree);
    }
    if (NULL != ctx->stack) {
        catStackDestroy(&(ctx->stack));
    }
    free(ctx);
}

void clearCatContext() {
    if (NULL == g_cat_context) {
        return;
    }
    deleteCatContext(g_cat_context);
}

CatMessageTree *getContextMessageTree() {
    return getCatContext()->tree;
}

void resetCatContext() {
    if (NULL == g_cat_context) {
        return;
    }
    g_cat_context->elementSize = 0;
    g_cat_context->lastTruncateTransDurationUs = 0;
    catStackClear(g_cat_context->stack);
}

void catContextAdd(CatMessage *message) {
    CatContext* ctx = getCatContext();
    CatStack_T pStack = ctx->stack;

    if (isCatStackEmpty(pStack)) {
        if (isCatEvent(message) && ctx->tree->canDiscard) {
            addEventToAggregator(message);
            deleteCatMessage(message);
        } else {
            CatMessageTree *old = ctx->tree;
            old->root = message;
            ctx->tree = duplicateCatMessageTree(old);
            catMessageManagerFlush(old);
        }
    } else {
        CatTransaction *parent = NULL;
        catStackPeek(pStack, (void**)&parent);
        catContextAddTransChild(ctx, message, parent);
    }
}

void catContextStartTrans(CatTransaction *trans) {
    CatContext* ctx = getCatContext();
    if (!isCatStackEmpty(ctx->stack)) {
        CatTransaction *parent = NULL;
        catStackPeek(ctx->stack, (void**)&parent);
        catContextAddTransChild(ctx, (CatMessage *) trans, parent);
    } else {
        ctx->tree->root = (CatMessage *) trans;
    }
    catStackPush(ctx->stack, trans);
}

int catContextEndTrans(CatTransaction *trans) {
    CatContext* ctx = getCatContext();
    size_t i, j;
    size_t initStackSize = catStackSize(ctx->stack);

    for (i = 0; i < initStackSize; ++i) {
        CatTransaction *stackTrans = NULL;
        catStackGetByIndex(ctx->stack, i, (void**)&stackTrans);
        if (stackTrans == trans) {
            break;
        }
    }

    if (i != initStackSize) {
        for (j = 0; j <= i; ++j) {
            CatTransaction *t = NULL;
            catStackPop(ctx->stack, (void**)&t);
        }
        validateTransaction(NULL, trans);
        if (isCatStackEmpty(ctx->stack)) {
            CatMessageTree *old = ctx->tree;

            ctx->tree = duplicateCatMessageTree(old);

            if (ctx->lastTruncateTransDurationUs > 0) {
                catContextAdjustForTruncatedTrans(ctx, (CatTransaction *) old->root);
            }

            catMessageManagerFlush(old);
            return 1;
        }
    }
    return 0;
}

void setCatMessageTreeCanDiscard(int canDiscard) {
    CatContext* ctx = getCatContext();
    ctx->tree->canDiscard = canDiscard;
}
