#include "router_json_parser.h"

#include "client_config.h"
#include "consts.h"
#include "lib/cat_json.h"
#include "lib/cat_dict.h"
#include "lib/cat_linked_list.h"
#include "lib/cat_ccmap.h"
#include "problem_filter.h"

extern volatile int g_cat_enabled;

extern int resolveServerIps(char *routerIps);

CatCCHashMap * configChangeListenerMap = NULL;

static int parseAndUpdateRouters(const catCJSON *kvsObject);

static int parseJsonStringArray(catCJSON* kvsObject, char* objName, int* pNum, catsds** pStrArray, char* splitor) {
    catCJSON *item = NULL;
    char *itemBuf = NULL;
    item = catCJSON_GetObjectItem(kvsObject, objName);
    if (item != NULL && (itemBuf = item->valuestring) != NULL) {
        *pStrArray = catsdssplitlen(itemBuf, strlen(itemBuf), splitor, strlen(splitor), pNum);

        if (*pStrArray != NULL && *pNum > 0) {
            return 1;
        }
    } else {
        g_config.logger->warning("CatRouter Json GetObjectItem Error, no key [%s].", objName);
    }
    return 0;
}

static int parseJsonDouble(catCJSON* kvsObject, char* objName, double* pVal) {
    catCJSON *item = NULL;
    char *itemBuf = NULL;
    item = catCJSON_GetObjectItem(kvsObject, objName);
    if (item != NULL && (itemBuf = item->valuestring) != NULL) {
        char *endBuf = NULL;
        double val = strtod(itemBuf, &endBuf);
        if (endBuf != NULL && endBuf[0] == '\0') {
            *pVal = val;
            return 1;
        } else {
            g_config.logger->warning("CatRouter Json strtod Error, key [%s].", objName);
        }
    } else {
        g_config.logger->warning("CatRouter Json GetObjectItem Error, no key [%s].", objName);
    }
    return 0;
}

static int parseJsonInt(catCJSON* kvsObject, char* objName, int* pVal) {
    catCJSON *item = NULL;
    char *itemBuf = NULL;
    item = catCJSON_GetObjectItem(kvsObject, objName);
    if (item != NULL && (itemBuf = item->valuestring) != NULL) {
        if (!catAtoI(itemBuf, 10, pVal)) {
            g_config.logger->warning("CatRouter Json catAtoI Error, key [%s].", objName);
            return -1;
        } else {
            return 1;
        }
    } else {
        g_config.logger->warning("CatRouter Json GetObjectItem Error, no key [%s].", objName);
    }
    return 0;
}

static int parseJsonBool(catCJSON* kvsObject, char* objName, int* pRst) {
    catCJSON *item = NULL;
    char *itemBuf = NULL;
    item = catCJSON_GetObjectItem(kvsObject, objName);
    if (item != NULL && (itemBuf = item->valuestring) != NULL) {
        if (strcmp(itemBuf, "true") == 0 || strcmp(itemBuf, "TRUE") == 0
            || strcmp(itemBuf, "Yes") == 0 || strcmp(itemBuf, "yes") == 0) {
            *pRst = 1;
        } else {
            *pRst = 0;
        }
        return 1;
    } else {
        g_config.logger->warning("CatRouter Json GetObjectItem Error, no key [%s].", objName);
    }
    return 0;
}

typedef int (*jsonItemParser)(catCJSON*, char*, void*);

static int parseJsonWithListener(catCJSON *kvsObject, const char *objName, int originalValue, int defaultValue, jsonItemParser parser) {
    int newValue = 0;
    int result = parser(kvsObject, objName, &newValue);
    if (result < 0) {
        // value parse error. We stop going on, leaving the config value as it is.
        return result;
    }

    if (result == 0) {
        // This means that the config is missing in the new-retrieved config.
        // use defaultValue.
        newValue = defaultValue;
    }

    if (newValue == originalValue) {
        return 1;
    }

    CatLinkedList_T listenerList = (CatLinkedList_T) catFindCCHashMap(configChangeListenerMap, objName);
    if (listenerList == NULL) {
        return 0;
    }

    void **listenerArray;
    int length = 0;
    result = catLinkedListToArray(listenerList, &listenerArray, &length);
    if (result == 0) {
        g_config.logger->error("failed to create config change listener array for %s", objName);
        return 0;
    }

    for (int i = 0; i < length; ++i) {
        ((intConfigChangeListener) (listenerArray[i]))(newValue);
    }

    return 1;
}

static void enableCatOrNot(int catBlocked, int subComponentBlocked) {
    if (!catBlocked && subComponentBlocked) {
        g_cat_enabled = 0;
        return;
    }

    if (catBlocked) {
        g_cat_enabled = 0;
    } else {
        g_cat_enabled = 1;
    }
}

static int parseCatJsonRouterItem(catCJSON *kvsObject) {
    int rst = 0;
    int componentSwitchBlocked = 0;

    // parse every item
    rst += parseJsonInt(kvsObject, "long-url", &g_config.longUrl) <= 0 ? 0 : 1;
    rst += parseJsonInt(kvsObject, "long-service", &g_config.longService) <= 0 ? 0 : 1;
    rst += parseJsonInt(kvsObject, "long-call", &g_config.longCall) <= 0 ? 0 : 1;
    rst += parseJsonInt(kvsObject, "long-sql", &g_config.longSql) <= 0 ? 0 : 1;
    rst += parseJsonInt(kvsObject, "long-cache", &g_config.longCache) <= 0 ? 0 : 1;
    rst += parseJsonInt(kvsObject, "long-mq", &g_config.longMq) <= 0 ? 0 : 1;
    rst += parseJsonBool(kvsObject, "block", &g_config.block);
    rst += parseJsonDouble(kvsObject, "sample", &g_config.sampleRatio);
    rst += parseJsonWithListener(kvsObject, CONFIG_NAME_AGGREGATOR_INTERVAL, g_config.aggregatorInterval, DEFAULT_AGGREGATOR_INTERVAL,parseJsonInt) <= 0 ? 0 : 1;
    rst += parseJsonWithListener(kvsObject, CONFIG_NAME_MSG_COUNT_PER_SECOND, g_config.msgCountPerSecond, DEFAULT_MSG_COUNT_PER_SECOND,parseJsonInt) <= 0 ? 0 : 1;
    rst += parseJsonWithListener(kvsObject, CONFIG_NAME_FAIL_LOG_LIMIT, g_config.failLogLimit, DEFAULT_FAIL_LOG_LIMIT,parseJsonInt) <= 0 ? 0 : 1;
    rst += parseJsonWithListener(kvsObject, CONFIG_NAME_HEARTBEAT_ENABLED, g_config.enableHeartbeat, DEFAULT_HEARTBEAT_ENABLED,parseJsonBool) <= 0 ? 0 : 1;

    rst += parseJsonBool(kvsObject, g_config.componentSwitch, &componentSwitchBlocked);

    enableCatOrNot(g_config.block, componentSwitchBlocked);
    g_config.logger->info("ccat config has been updated: enabled(%d), sampleRatio(%f), componentSwitch(%d)",
            g_cat_enabled, g_config.sampleRatio, componentSwitchBlocked);

    rst += parseAndUpdateRouters(kvsObject);
    return rst;
}

int parseAndUpdateRouters(const catCJSON *kvsObject) {
    catCJSON *item = NULL;
    char *itemBuf = NULL;
    item = catCJSON_GetObjectItem(kvsObject, "routers");
    if (item != NULL && (itemBuf = item->valuestring) != NULL) {
        if (resolveServerIps(itemBuf) > 0) {
            return 1;
        } else {
            g_config.logger->warning("CatRouter Json catAtoI Error, key [routers].");
        }
    } else {
        g_config.logger->warning("CatRouter Json GetObjectItem Error, no key [routers].");
    }
    return 0;
}

int parseCatJsonRouter(char *jsonBuf) {
    catCJSON *catRouterJson = NULL;

    catRouterJson = catCJSON_Parse(jsonBuf);
    if (catRouterJson == NULL) {
        g_config.logger->warning("CatRouter Json Parser Error before: [%s]\n", catCJSON_GetErrorPtr());
        // error
        return 0;
    }

    catCJSON *kvsItem = catCJSON_GetObjectItem(catRouterJson, "kvs");
    if (kvsItem == NULL) {
        g_config.logger->warning("CatRouter Json GetObjectItem [kvs] Error before: [%s]\n", catCJSON_GetErrorPtr());
        // error
        return 0;
    }
    if (catCJSON_GetArraySize(kvsItem) < 1) {
        g_config.logger->warning("CatRouter Json ArraySize [kvs] Error before: [%s]\n", catCJSON_GetErrorPtr());
        // error
        return 0;
    }
    parseCatJsonRouterItem(kvsItem);
    catCJSON_Delete(catRouterJson);

    return 1;
}

extern unsigned int catDictStringCopyHTHashFunction(const void *key);
extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);
extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1, const void *key2);

static void configChangeListenerMapValueFreeFun(void *privdata, void *value) {
    catLinkedListDestroy(value);
}

static void* createListenerList(CatCCHashMap *pCCHM, void *key, void *pParam) {
    CatLinkedList_T list;
    newCatLinkedList(&list, NULL);
    return list;
}

static void failLogLimitChanged(int newValue) {
    g_config.failLogLimit = newValue;
    resetFailLogLimit(newValue);

    g_config.logger->info("%s failLogLimit has been updated to %d", g_config.domain, g_config.failLogLimit);
}

static void aggregatorIntervalChanged(int newValue) {
    catClientConfigLock();
    g_config.aggregatorInterval = newValue;
    catClientConfigUnlock();

    g_config.logger->info("%s aggregatorInterval has been updated to %d", g_config.domain, g_config.aggregatorInterval);
}

static void msgCountPerSecondChanged(int newValue) {
    g_config.msgCountPerSecond = newValue;

    g_config.logger->info("%s msgCountPerSecond has been updated to %d", g_config.domain, g_config.msgCountPerSecond);
}

static void heartbeatEnabledChanged(int newValue) {
    if (g_config.userHasDisabledHeartbeat) {
        g_config.logger->warning("%s user has disabled heartbeat, ignore the server config", g_config.domain);
        return;
    }
    g_config.enableHeartbeat = newValue;
    g_config.logger->info("%s heartbeatEnabled has been updated to %d", g_config.domain, g_config.enableHeartbeat);
}

catDictType dictTypeConfigChangeListenerMap = {
        catDictStringCopyHTHashFunction,          /* hash function */
        catDictStringCopyHTKeyDup,                /* key dup */
        NULL,                                   /* val dup */
        catDictStringCopyHTKeyCompare,            /* key compare */
        NULL,         /* key destructor */
        configChangeListenerMapValueFreeFun     /* val destructor */
};

int initConfigChangeListenerMap() {
    configChangeListenerMap = catCreateCCHashMap(&dictTypeConfigChangeListenerMap, 64, NULL);
    if (configChangeListenerMap == NULL) {
        g_config.logger->error("failed to allocate memory for configChangeListenerMap");
        return 1;
    }

    if (registerIntConfigChangeListener(CONFIG_NAME_FAIL_LOG_LIMIT, failLogLimitChanged)) {
        return 1;
    }
    if (registerIntConfigChangeListener(CONFIG_NAME_AGGREGATOR_INTERVAL, aggregatorIntervalChanged)) {
        return 1;
    }
    if (registerIntConfigChangeListener(CONFIG_NAME_MSG_COUNT_PER_SECOND, msgCountPerSecondChanged)) {
        return 1;
    }
    if (registerBoolConfigChangeListener(CONFIG_NAME_HEARTBEAT_ENABLED, heartbeatEnabledChanged)) {
        return 1;
    }
    return 0;
}

void destroyConfigChangeListenerMap() {
    catClearCCHashMap(configChangeListenerMap);
    catDestroyCCHashMap(configChangeListenerMap);
}

static int registerConfigChangeListener(const char* configName, void* changeListener) {
    CatLinkedList_T list = (CatLinkedList_T) catFindCCHashMapCreateByFun(
            configChangeListenerMap, configName, createListenerList, NULL);
    if (list == NULL) {
        g_config.logger->error("failed to listener list for %s", configName);
        return 1;
    }

    catLinkedListAdd(list, changeListener);
    return 0;
}

int registerIntConfigChangeListener(const char* configName, intConfigChangeListener changeListener) {
    return registerConfigChangeListener(configName, changeListener);
}

int registerDoubleConfigChangeListener(const char* configName, doubleConfigChangeListener changeListener) {
    return registerConfigChangeListener(configName, changeListener);
}

int registerBoolConfigChangeListener(const char* configName, boolConfigChangeListener changeListener) {
    return registerConfigChangeListener(configName, changeListener);
}
