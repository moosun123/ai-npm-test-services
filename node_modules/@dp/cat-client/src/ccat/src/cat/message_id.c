#include "message_id.h"

#include "client_config.h"
#include "message_manager.h"

#include "lib/cat_time_util.h"
#include "lib/cat_ccmap.h"

extern CatMessageManager g_cat_messageManager;

static volatile int g_id_index = 0;
static volatile catsds g_multiprocessing_pid_str = NULL;
static volatile unsigned long long g_last_hour = 0;
static const char* MESSAGE_ID_PREFIX_FORMAT = "%s-%s.%s-%lld-";

static catsds g_id_prefix = NULL;

static CatCriticalSection g_id_lock = NULL;

static CatCCHashMap *g_domainMessageIdDict;

static void domainMessageIdFreeFun(void *privdata, void *val) {
    free(val);
}

extern unsigned int catDictStringCopyHTHashFunction(const void *key);

extern void *catDictStringCopyHTKeyDup(void *privdata, const void *key);

extern void *catDictStringKeyValCopyHTValDup(void *privdata, const void *val);

extern int catDictStringCopyHTKeyCompare(void *privdata, const void *key1,
                                         const void *key2);

extern void catDictStringCopyHTKeyDestructor(void *privdata, void *key);

catDictType dictDomainMessageId = {
        catDictStringCopyHTHashFunction,        /* hash function */
        catDictStringCopyHTKeyDup,              /* key dup */
        NULL,                               /* val dup */
        catDictStringCopyHTKeyCompare,          /* key compare */
        catDictStringCopyHTKeyDestructor,       /* key destructor */
        domainMessageIdFreeFun  /* val destructor */
};

void initMessageIdHelper() {
    pid_t pid = getpid();
    char tmpBuf[32];
    g_multiprocessing_pid_str = catsdsnew(catItoA(pid, tmpBuf, 10));

    g_id_lock = CatCreateCriticalSection();
    uint64_t nowT = GetTime64();
    unsigned long long nowHour = catTrimToHour(nowT);

    if (nowHour > g_last_hour) {
        g_last_hour = nowHour;
        g_id_index = 0;
    } else {
        g_id_index += 10000;
    }
    g_id_prefix = catsdsnewEmpty(256);
    g_id_prefix = catsdscatprintf(g_id_prefix, MESSAGE_ID_PREFIX_FORMAT, g_cat_messageManager.domain,
            g_cat_messageManager.ipHex, g_multiprocessing_pid_str, g_last_hour);

    g_domainMessageIdDict = catCreateCCHashMap(&dictDomainMessageId, g_config.slotCount, NULL);
}

void destroyCatMessageIdHelper() {
    catsdsfree(g_id_prefix);
    g_id_prefix = NULL;

    catDestroyCCHashMap(g_domainMessageIdDict);
}

catsds getNextMessageId() {
    unsigned long long nowT = GetTime64();
    unsigned long long nowHour = catTrimToHour(nowT);

    // g_id_prefix need to be updated while hour is changed.
    if (nowHour > g_last_hour) {
        CATCS_ENTER(g_id_lock);
        g_last_hour = nowHour;
        g_id_index = 0;
        catsdsclear(g_id_prefix);

        g_id_prefix = catsdscatprintf(g_id_prefix, MESSAGE_ID_PREFIX_FORMAT, g_cat_messageManager.domain,
                g_cat_messageManager.ipHex, g_multiprocessing_pid_str, g_last_hour);
        CATCS_LEAVE(g_id_lock);
    }

    ++g_id_index;

    catsds msgIdStr = catsdsnewEmpty(128);
    msgIdStr = catsdscpylen(msgIdStr, g_id_prefix, catsdslen(g_id_prefix));
    char tmpBuf[32];

    msgIdStr = catsdscat(msgIdStr, catItoA(g_id_index, tmpBuf, 10));

    return msgIdStr;
}

static void *createRemoteDomainFun(CatCCHashMap *pCCHM, void *key, void *pParam) {
    CAT_ATOMICLONG *count = (CAT_ATOMICLONG *) malloc(sizeof(CAT_ATOMICLONG));
    catCheckPtr(count);
    memset(count, 0, sizeof(CAT_ATOMICLONG));
    return count;
}

char* getNextMessageIdByDomain(const char *domain) {
    catsds _domain = catsdsnew(domain);

    if (catsdscmp(g_cat_messageManager.domain, _domain) == 0) {
        catsdsfree(_domain);
        catsds msgId = getNextMessageId();

        int msgIdStrLen = catsdslen(msgId);
        char* returnBuf = (char*)malloc(msgIdStrLen+1);
        if (returnBuf == NULL) {
            return NULL;
        }
        memcpy(returnBuf, msgId, msgIdStrLen);
        returnBuf[msgIdStrLen] = '\0';

        catsdsfree(msgId);
        return returnBuf;
    }

    catsdsfree(_domain);

    unsigned long long nowT = GetTime64();
    unsigned long long nowHour = catTrimToHour(nowT);

    if (nowHour > g_last_hour) {
        CATCS_ENTER(g_id_lock);
        g_last_hour = nowHour;
        g_id_index = 0;
        catsdsclear(g_id_prefix);
        g_id_prefix = catsdscatprintf(g_id_prefix, MESSAGE_ID_PREFIX_FORMAT, g_cat_messageManager.domain,
                g_cat_messageManager.ipHex, g_multiprocessing_pid_str, g_last_hour);
        CATCS_LEAVE(g_id_lock);
    }

    CAT_ATOMICLONG *count = (CAT_ATOMICLONG *) catFindCCHashMapCreateByFun(g_domainMessageIdDict, domain, createRemoteDomainFun,
                                                                           NULL);
    CAT_ATOMICLONG_INC(count);

    catsds id_prefix = catsdsnewEmpty(256);;

    id_prefix = catsdscatprintf(id_prefix, MESSAGE_ID_PREFIX_FORMAT, domain, g_cat_messageManager.ipHex,
            g_multiprocessing_pid_str, g_last_hour);

    catsds msgIdStr = catsdsnewEmpty(128);
    msgIdStr = catsdscpylen(msgIdStr, id_prefix, catsdslen(id_prefix));

    char tmpBuf[32];
    msgIdStr = catsdscat(msgIdStr, catItoA((int)(*count), tmpBuf, 10));
    catsdsfree(id_prefix);

    int msgIdStrLen = catsdslen(msgIdStr);
    char* returnBuf = (char*)malloc(msgIdStrLen+1);
    if (returnBuf == NULL) {
        return NULL;
    }
    memcpy(returnBuf, msgIdStr, msgIdStrLen);
    returnBuf[msgIdStrLen] = '\0';

    catsdsfree(msgIdStr);

    return returnBuf;
}

