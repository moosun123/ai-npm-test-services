#include "client_config.h"
#include "consts.h"
#include "batch_dispatcher.h"
#include "aggregator_event.h"
#include "aggregator_transaction.h"

#include "lib/ae.h"
#include "lib/cat_anet.h"
#include "lib/cat_clog.h"
#include "lib/properties.h"
#include "lib/cat_network_util.h"
#include "lib/cat_ezxml.h"
#include "lib/cat_mutex.h"

CatClientInnerConfig g_config;
static unsigned int LOGGING_LEVEL_SET_FOR_INFO[] = {CAT_LOG_INFO};
static unsigned int LOGGING_LEVEL_SET_FOR_DEBUG[] = {CAT_LOG_INFO, CAT_LOG_DEBUG};

static CatCriticalSection _cat_client_config_lock = NULL;

static catsds buildRequestBuf(char *ip, char* env) {
    catsds buf = catsdsnewEmpty(1024);
    buf = catsdscatprintf(buf, "GET /cat/s/launch?ip=%s&env=%s HTTP/1.1\r\n", ip, env);
    buf = catsdscatprintf(buf, "Host: %s\r\n", CAT_REMOTE_SERVER);
    buf = catsdscatprintf(buf, "Connection: close\r\n\r\n");
    return buf;
}

static cat_ezxml_t getCatClientConfig(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        return NULL;
    } else {
        return cat_ezxml_parse_file(filename);
    }
}

static cat_ezxml_t getCatClientConfigFromRemoteServer() {
    catsds destIP = catsdsnewEmpty(64);
    if (hostnameToIp(CAT_REMOTE_SERVER, destIP) < 0) {
        return 0;
    }

    int port = 80;
    g_config.logger->info("Start connect to remote server %s:%d.", destIP, port);
    int sockfd = catAnetTcpNonBlockConnect(NULL, destIP, port);
    if (sockfd < 0) {
        g_config.logger->warning("Connect to remote server %s:%d Error.", destIP, port);
        return 0;
    }

    // wait newFd to be writable
    int retVal = 0;
    retVal = catAeWait(sockfd, AE_WRITABLE | AE_ERROR | AE_HUP, 200);
    if (retVal > 0 && !(retVal & AE_ERROR) && (retVal & AE_WRITABLE)) {
        // Connection has been established successfully.
    } else {
        g_config.logger->warning("Failed in connecting to remote server after %dms.", 200);
        catAnetClose(sockfd);
        return 0;
    }

    char ip[64];
    getLocalHostIp(&ip);

    catsds requestBuf = buildRequestBuf(ip, g_config.env);
    int status = catAnetBlockWriteTime(sockfd, requestBuf, (int) catsdslen(requestBuf), 100);
    catsdsfree(requestBuf);

    if (status == CAT_ANET_ERR) {
        g_config.logger->warning("Failed in sending request after %dms.", 100);
        catAnetClose(sockfd);
        return 0;
    }

    char resp[2048];
    status = catAnetBlockReadTime(sockfd, resp, 2047, 1000);
    if (status == CAT_ANET_ERR || status < 4) {
        catAnetClose(sockfd);
        return 0;
    }
    resp[status] = '\0';

    // skip header
    char *t = strstr(resp, "\r\n\r\n");
    if (NULL == t) {
        catAnetClose(sockfd);
        return 0;
    }

    // skip content-length
    char *body = t + 4;
    if (body[0] == '\0') {
        catAnetClose(sockfd);
        return 0;
    }

    catAnetClose(sockfd);
    g_config.logger->info("Got available client config from remote server:\n\n%s", body);
    return cat_ezxml_parse_str(body, strlen(body));
}

int parseCatClientConfig(cat_ezxml_t f1) {
    int serverIndex = 0;
    cat_ezxml_t servers, server;

    for (servers = cat_ezxml_child(f1, "servers"); servers; servers = servers->next) {
        for (server = cat_ezxml_child(servers, "server"); server; server = server->next) {
            const char *ip = cat_ezxml_attr(server, "ip");

            if (NULL == ip || ip[0] == '\0') {
                continue;
            }

            catsds s = catsdsnew(ip);
            s = catsdscat(s, ":");
            const char *port = cat_ezxml_attr(server, "port");
            if (NULL == port || port[0] == '\0') {
                s = catsdscat(s, "2280");
            } else {
                s = catsdscat(s, port);
            }
            g_config.serverAddresses[serverIndex] = s;
            serverIndex++;
            if (serverIndex >= 64) {
                break;
            }
        }
    }
    cat_ezxml_free(f1);
    g_config.serverNum = serverIndex;

    if (serverIndex <= 0) {
        return -1;
    }
    return 0;
}

static unsigned int getLoggingLevelFromUser(unsigned int loggingLevelsFromUser) {
    unsigned int finalLoggingLevel = 0;
    if (CAT_LOG_INFO & loggingLevelsFromUser) {
        finalLoggingLevel = finalLoggingLevel | CAT_LOG_INFO;
    }
    if (CAT_LOG_DEBUG & loggingLevelsFromUser) {
        finalLoggingLevel = finalLoggingLevel | CAT_LOG_INFO;
        finalLoggingLevel = finalLoggingLevel | CAT_LOG_DEBUG;
    }
    return finalLoggingLevel;
}

static unsigned int getLoggingLevelFromSingleEnv(char* envName, const uint32_t * loggingLevels, int length) {
    unsigned int finalLoggingLevel = 0;
    char *value = getenv(envName);
    if (value == NULL) {
        return finalLoggingLevel;
    }

    if (strcmp(value, "true") != 0) {
        return finalLoggingLevel;
    }

    for (int i = 0; i < length; ++i) {
        finalLoggingLevel = finalLoggingLevel | loggingLevels[i];
    }
    return finalLoggingLevel;
}

static unsigned int getLoggingLevelFromEnv() {
    unsigned int infoLevel = getLoggingLevelFromSingleEnv("CCatEnableInfoLogging", LOGGING_LEVEL_SET_FOR_INFO, 1);
    unsigned int debugLevel = getLoggingLevelFromSingleEnv("CCatEnableDebugLogging", LOGGING_LEVEL_SET_FOR_DEBUG, 2);
    return infoLevel | debugLevel;
}

static unsigned int getLoggingLevelForDefaultCatLogger(uint32_t loggingLevelsFromUser) {
    unsigned int llFromUser = getLoggingLevelFromUser(loggingLevelsFromUser);
    unsigned int llFromEnv = getLoggingLevelFromEnv();

    if (llFromEnv) {
        return llFromEnv;
    }

    return llFromUser;
}

void catClientConfigLock() {
    CATCS_ENTER(_cat_client_config_lock);
}

void catClientConfigUnlock() {
    CATCS_LEAVE(_cat_client_config_lock);
}

int getAggregatorInterval() {
    int interval;
    catClientConfigLock();
    interval = g_config.aggregatorInterval;
    catClientConfigUnlock();

    return interval;
}

/*************  wrappers for batch aggregating *************/
// Although there is no need to add this layer for transaction aggregation, I put it here for consistency.
// The main idea of these wrappers is to generalize the batch log aggregating to the same function signature.
static void transactionBatchAggregatorWrapper(const char *type, const char *name, int count, int error, unsigned long long sum) {
    logBatchTransToAggregator(type, name, count, error, sum);
}

static void eventBatchAggregatorWrapper(const char *type, const char *name, int count, int error, unsigned long long sum) {
    logBatchEventToAggregator(type, name, count, error);
}
/************* end of wrappers for batch aggregating *************/

void initCatClientConfig(CatClientConfig *config) {
    _cat_client_config_lock = CatCreateCriticalSection();

    memset(&g_config, 0, sizeof(g_config));

    g_config.loggingLevelForDefaultCatLogger = getLoggingLevelForDefaultCatLogger(config->loggingLevelConfig);
    g_config.logger = config->logger;
    g_config.logger->info("Encoder: %d", config->encoderType);
    g_config.logger->info("Sampling: %d", config->enableSampling);
    g_config.logger->info("Heartbeat: %d", config->enableHeartbeat);
    g_config.logger->info("Auto initialize: %d", config->enableAutoInitialize);

    g_config.domain = catsdsnew(DEFAULT_APPKEY);
    g_config.hostname = catsdsnewEmpty(128);
    g_config.env = getEnvProperty(DEFAULT_ENV_FILE, "env");

    g_config.defaultIp = catsdsnew(DEFAULT_IP);
    g_config.defaultIpHex = catsdsnew(DEFAULT_IP_HEX);

    if (catAnetGetHost(NULL, g_config.hostname, 128) == CAT_ANET_ERR) {
        g_config.hostname = catsdscpy(g_config.hostname, "CUnknownHost");
    }
    g_config.logger->info("Hostname: %s", g_config.hostname);

    g_config.serverNum = 0;
    g_config.serverAddresses = (catsds *) malloc(64 * sizeof(catsds));

    g_config.messageQueueSize = 10000;
    g_config.maxContextElementSize = 2000;

    g_config.dataDir = catsdsnew(DEFAULT_DATA_DIR);

    g_config.indexFileName = catsdsnew("client.idx.h");
    g_config.slotCount = 16;
    g_config.sampleRatio = 1.0;

    g_config.routerType = CAT_ROUTER_JSON;

    g_config.longUrl = 0;
    g_config.longCall = 0;
    g_config.longService = 0;
    g_config.longSql = 0;
    g_config.longCache = 0;
    g_config.longMq = 0;
    g_config.block = 0;

    g_config.enableHeartbeat = config->enableHeartbeat;
    g_config.userHasDisabledHeartbeat = !config->enableHeartbeat;
    g_config.enableAutoInitialize = config->enableAutoInitialize;
    g_config.componentSwitch = config->componentSwitch;

    g_config.aggregatorInterval = DEFAULT_AGGREGATOR_INTERVAL;
    g_config.msgCountPerSecond = DEFAULT_MSG_COUNT_PER_SECOND;
    g_config.failLogLimit = DEFAULT_FAIL_LOG_LIMIT;

    g_config.transactionBatchQueueCapacity = config->transactionBatchQueueCapacity;
    if (g_config.transactionBatchQueueCapacity > 0) {
        g_config.transactionBatchDispatcher = NewCatBatchDispatcher(
                "transactionBatchDispatcher", transactionBatchAggregatorWrapper, g_config.transactionBatchQueueCapacity);
    }
    g_config.eventBatchQueueCapacity = config->eventBatchQueueCapacity;
    if (g_config.eventBatchQueueCapacity > 0) {
        g_config.eventBatchDispatcher = NewCatBatchDispatcher(
                "eventBatchDispatcher", eventBatchAggregatorWrapper, g_config.eventBatchQueueCapacity);
    }
}

int loadCatClientConfig(const char *file) {
    cat_ezxml_t config = getCatClientConfig(file);
    if (NULL == config) {
        g_config.logger->warning("Failed to load cat client config from %s, trying loading from remote server...", file);
        config = getCatClientConfigFromRemoteServer();
    }

    if (NULL == config) {
        g_config.logger->error("Failed to load cat client config from remote server.");
        return -1;
    }

    if (parseCatClientConfig(config) < 0) {
        g_config.logger->error("Failed to parse client.xml, is it a legal xml file?");
        return -1;
    }
    return 0;
}

void clearCatClientConfig() {
    catsdsfree(g_config.domain);
    catsdsfree(g_config.hostname);
    catsdsfree(g_config.env);

    catsdsfree(g_config.defaultIp);
    catsdsfree(g_config.defaultIpHex);

    int i = 0;
    for (i = 0; i < g_config.serverNum; ++i) {
        catsdsfree(g_config.serverAddresses[i]);
    }
    free(g_config.serverAddresses);

    catsdsfree(g_config.dataDir);
    catsdsfree(g_config.indexFileName);
    CatDeleteCriticalSection(_cat_client_config_lock);
}

