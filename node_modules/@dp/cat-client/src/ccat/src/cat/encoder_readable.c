#include "encoder.h"

#include "lib/cat_clog.h"
#include "lib/cat_time_util.h"
#include "message/message_imp.h"
#include "message_manager.h"
#include "transaction_helper.h"
#include "message/transaction_imp.h"
#include "client_config.h"

#define POLICY_DEFAULT 0
#define POLICY_WITHOUT_STATUS 1
#define POLICY_WITH_DURATION 2

#define CAT_ENCODE_VERSION "PT1"
#define CAT_TAB '\t'
#define CAT_EL '\n'


extern CatMessageManager g_cat_messageManager;


static inline sds sdscatwithnull(sds s, const char *buf) {
    return catsdscat(s, buf == NULL ? "null" : buf);
}

static inline sds sdscatwithdefault(sds s, const char *buf, const char *defaultStr) {
    return catsdscat(s, buf == NULL ? defaultStr : buf);
}

int catEncodeHeader(CatMessageTree *pRootMsg, sds *buf) {
    sds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);

    tmpBuf = sdscatwithnull(tmpBuf, CAT_ENCODE_VERSION);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, g_cat_messageManager.m_domain);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, g_cat_messageManager.m_hostname);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, g_cat_messageManager.m_ip);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_threadGroupName);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_threadId);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_threadName);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_messageId);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_parentMessageId);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_rootMessageId);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pRootMsg->m_sessionToken);
    tmpBuf = catsdscatchar(tmpBuf, CAT_EL);

    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;
}

int catEncodeLine(CatMessage *pMsg, sds *buf, char type, int policy) {
    sds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);
    CatMessageInner *pMsgInner = getInnerMsg(pMsg);


    tmpBuf = catsdscatchar(tmpBuf, type);

    if (type == 'T' && isCatTransaction(pMsg)) {
        unsigned long long durationMs = getCatTransactionDurationUs((CatTransaction *) pMsg) / 1000;

        tmpBuf = catsdscatprintf(tmpBuf, "%s", GetCatTimeString(getCatMessageTimeStamp(pMsg) + durationMs));
    } else {
        tmpBuf = catsdscatprintf(tmpBuf, "%s", GetCatTimeString(getCatMessageTimeStamp(pMsg)));
    }
    //printf("Now Time %s\n", GetCatTimeString(getCatMessageTimeStamp(pMsg)));

    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pMsgInner->m_type);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    tmpBuf = sdscatwithnull(tmpBuf, pMsgInner->m_name);
    tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);

    if (policy != POLICY_WITHOUT_STATUS) {
        // if status is null, set status to "DefaultStatus"
        tmpBuf = sdscatwithdefault(tmpBuf, pMsgInner->m_status, "DefaultStatus");
        tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);


        if (policy == POLICY_WITH_DURATION && isCatTransaction(pMsg)) {
            unsigned long long durationUs = getCatTransactionDurationUs((CatTransaction *) pMsg);
            tmpBuf = catsdscatprintf(tmpBuf, "%lldus\t", durationUs);
        }

        tmpBuf = sdscatwithnull(tmpBuf, pMsgInner->m_data);
        tmpBuf = catsdscatchar(tmpBuf, CAT_TAB);
    }

    tmpBuf = catsdscatchar(tmpBuf, CAT_EL);


    *buf = tmpBuf;
    return catsdslen(tmpBuf) - count;

}

int catEncodeBody(CatMessage *pMsg, sds *buf) {
    sds tmpBuf = *buf;
    int count = catsdslen(tmpBuf);


    if (isCatTransaction(pMsg)) {
        CatTransaction *transaction = (CatTransaction *) pMsg;
        CatStack_T children = getCatTransactionChildren(transaction);

        if (isCATStaticQueueEmpty(children)) {
            return catEncodeLine(pMsg, buf, 'A', POLICY_WITH_DURATION);
        } else {
            int count = 0;
            size_t len = catStackSize(children);

            count += catEncodeLine(pMsg, buf, 't', POLICY_WITHOUT_STATUS);
            size_t i = 0;
            for (; i < len; i++) {
                CatMessage *child = NULL;
                catStackGetByIndex(children, i, (void**)&child);

                if (child != NULL) {
                    count += catEncodeBody(child, buf);
                }
            }

            count += catEncodeLine(pMsg, buf, 'T', POLICY_WITH_DURATION);

            return count;
        }
    } else if (isCatEvent(pMsg)) {
        return catEncodeLine(pMsg, buf, 'E', POLICY_DEFAULT);
    } else if (isCatMetric(pMsg)) {
        return catEncodeLine(pMsg, buf, 'M', POLICY_DEFAULT);
    } else if (isCatHeartBeat(pMsg)) {
        return catEncodeLine(pMsg, buf, 'H', POLICY_DEFAULT);
    } else {
        g_config.logger->error("Unsupported message type: %s.", getCatMessageType(pMsg));
    }
    return 0;
}


sds catEncodeMessage(CatMessageTree *pRootMsg, sds buf) {
    int count = 0;
    buf = catsdscatlen(buf, "0000", 4);

    count += catEncodeHeader(pRootMsg, &buf);

    if (pRootMsg->m_rootMsg != NULL) {
        count += catEncodeBody(pRootMsg->m_rootMsg, &buf);
    }

    buf[0] = (count >> 24) & 0xFF;
    buf[1] = (count >> 16) & 0xFF;
    buf[2] = (count >> 8) & 0xFF;
    buf[3] = (count) & 0xFF;


    return buf;
}

