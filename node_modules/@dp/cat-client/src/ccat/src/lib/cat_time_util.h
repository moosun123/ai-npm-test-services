#ifndef  _TIMEUTILITY_
#define  _TIMEUTILITY_

#include "headers.h"
#include "typedef.h"

#ifdef WIN32
#include <sys/timeb.h>
#endif

#define Sleep(ms) usleep((ms) * 1000);

/**
 * 获取系统64位时间，时间/1000为seconds since midnight, January 1, 1970(UTC)时间 %1000 为毫秒
 */
static u_int64 inline GetTime64() {
    u_int64 buf;
#if defined(WIN32)
    struct __timeb64 timeBuf;
    _ftime64_s(&timeBuf);
    buf = (timeBuf.time * 1000) + (timeBuf.millitm);
#elif defined(__linux__) || defined(__APPLE__)
    struct timeval tv;
    gettimeofday(&tv, NULL);
    buf = tv.tv_sec * 1000 + tv.tv_usec / 1000;
#endif
    return buf;
}

static void inline sleepToNextMinute(int nextSec) {
    u_int64 now = GetTime64();
    u_int64 delta = ((now / 1000 / 60 + 1) * 60 + nextSec) * 1000 - now;
    Sleep(delta);
}

static void inline sleepToNextSecond() {
    u_int64 now = GetTime64();
    u_int64 delta = (now / 1000 + 1) * 1000 - now;
    Sleep(delta);
}

/**
 * 获取两个时间区间长度，单位毫秒
 * @param oldTime 靠前的时间
 * @param newTime 靠后的时间
 * @return
 */
static int64 inline GetTimeIntervalLength64(u_int64 oldTime, u_int64 newTime) {
    return newTime - oldTime;
}

/**
 * 设置系统当前时间
 * @param srcTime
 * @param incTime
 * @return
 */
static int inline SetNowTime(u_int64 nowTime) {
#ifdef WIN32
    SYSTEMTIME curr_st;
    struct tm *local = NULL;
    time_t tt = nowTime / 1000;

#pragma warning(push)
#pragma warning(disable : 4996)

    local = localtime(&tt);
#pragma  warning(pop)

    curr_st.wYear = (WORD)local->tm_year + 1900;
    curr_st.wMonth = (WORD)local->tm_mon + 1;
    curr_st.wDay = (WORD)local->tm_mday;
    curr_st.wHour = (WORD)local->tm_hour;
    curr_st.wMinute = (WORD)local->tm_min;
    curr_st.wSecond = (WORD)local->tm_sec;
    curr_st.wMilliseconds = (WORD)(nowTime % 1000);
    int rst = SetLocalTime(&curr_st);
    if (!rst)
    {
        printf("Set Local Time failed,Error No.: %u", GetLastError());
        return 0;
    }
    else
    {
        printf("Update local time successfully!\n");
        printf("Current time:%u年 %u月 %u日 %u时 %u分 %u秒 %u微秒\n",
            curr_st.wYear, curr_st.wMonth, curr_st.wDay, curr_st.wHour, curr_st.wMinute,
            curr_st.wSecond, curr_st.wMilliseconds);
        return 1;
    }
#endif
    return 0;
}

/**
 * 获取时间增量
 * @param srcTime
 * @param incTime
 * @return
 */
static u_int64 inline GetTimeIncrementLength64(u_int64 srcTime, int64 incTime) {
    return srcTime + incTime;
}

/**
 * 获取时间，格式为2013-10-11 23:21:16 如果srcTime为0，则使用当前时间
 * @param srcTime
 * @return
 */
char *GetTimeString(u_int64 srcTime);

static int inline GetTimeHour(u_int64 timeV) {
    time_t t = 0;
    struct tm *pTm = NULL;
    if (timeV == 0) {
        t = time(0);
    } else {
        t = timeV / 1000;
    }
    pTm = localtime(&t);
    return pTm->tm_hour;
}

char *GetDetailTimeString(u_int64 srcTime);


char *GetCatTimeString(u_int64 srcTime);

struct tm cat_nolocks_localtime(time_t t);

static int inline GetPerformanceFrequency(int64 *frequence) {
#ifdef WIN32
    LARGE_INTEGER f;
    if (QueryPerformanceFrequency(&f))
    {
        *frequence = f.QuadPart;
        return 1;
    }
    else
    {
        return 0;
    }
#elif defined(__linux)
    *frequence = 1000000000;
    return 1;
#else

    return 0;
#endif //WIN32
}


static int64 inline GetPerformanceCounter() {
#ifdef WIN32
    LARGE_INTEGER c;
    QueryPerformanceCounter(&c);
    return c.QuadPart;
#elif defined(__linux)
    struct timeval tv;

    gettimeofday(&tv, NULL);
    return (int64)tv.tv_sec * 1000000 + tv.tv_usec;
#else

#endif //WIN32
    return 0;
}


typedef struct _TimeInterval {
    u_int64 time_s;
    u_int64 time_e;
} TimeInterval;

static inline u_int8 TimeIntervalCompare(TimeInterval *resInterval, TimeInterval *desInterval) {
    u_int8 rst = 0;
    if (resInterval->time_e < desInterval->time_s) {
        rst = 0;
    } else {
        //res.s > des.e no cross
        if (resInterval->time_s > desInterval->time_e) {
            rst = 0;
        } else {
            if (resInterval->time_s > desInterval->time_s) {
                if (resInterval->time_e > desInterval->time_e) {
                    //res                             |________|
                    //des                    |__________|
                    rst = 1;
                } else {
                    //res                     |__________|
                    //des                |_________________|
                    rst = 2;
                }
            } else {
                if (resInterval->time_e > desInterval->time_e) {
                    //res              |____________|
                    //des                  |_______|
                    rst = 3;
                } else {
                    //res              |___________|
                    //des                 |_____________|
                    rst = 4;
                }
            }
        }
    }
    return rst;
}

#endif