//
// Created by mtdp on 2020/1/14.
//

#include "cat/client_config.h"
#include "cat_stack.h"
#include "cat_mutex.h"

struct _CatStack_T {
    volatile uint64_t top;
    volatile size_t capacity;
    CatCriticalSection mutex;
    void** valueArray;
};

static int ensureCATDynamicStack(CatStack_T pStack);
static int enlargeDynamicStack(CatStack_T pStack, size_t targetCapacity);

int newCatStack(size_t initialSize, CatStack_T* receiver) {
    CatStack_T pStack = (CatStack_T) malloc(sizeof(struct _CatStack_T));
    if (pStack == NULL) {
        g_config.logger->error("failed to malloc for CatStack");
        *receiver = NULL;
        return CAT_STACK_ERR;
    }

    void** newArray = (void**) malloc(initialSize * sizeof(void*));
    if (newArray == NULL) {
        g_config.logger->error("failed to malloc for CatStack valueArray, %d", initialSize);
        free(pStack);
        return CAT_STACK_ERR;
    }

    memset(pStack, 0, sizeof(struct _CatStack_T));
    memset(newArray, 0, initialSize * sizeof(void*));

    pStack->valueArray = newArray;
    pStack->capacity = initialSize;
    pStack->top = 0;
    pStack->mutex = CatCreateCriticalSection();

    *receiver = pStack;
    return CAT_STACK_OK;
}

int catStackPush(CatStack_T pStack, void *pData) {
    if (pStack == NULL) {
        g_config.logger->error("cannot operate on a NULL stack");
        return CAT_STACK_ERR;
    }

    CATCS_ENTER(pStack->mutex);
    int status = ensureCATDynamicStack(pStack);
    if (status != CAT_STACK_OK) {
        g_config.logger->error(
            "failed to ensure cat stack capacity, current capacity:%d, sizeof pointer:%d",
            pStack->capacity, sizeof(void*)
        );
        CATCS_LEAVE(pStack->mutex);
        return status;
    }
    pStack->valueArray[pStack->top] = pData;
    pStack->top += 1;
    CATCS_LEAVE(pStack->mutex);

    return CAT_STACK_OK;
}

static int _isCatStackEmpty(CatStack_T stk) {
    return stk->top == 0;
}

int isCatStackEmpty(CatStack_T stk) {
    if (stk == NULL) {
        g_config.logger->error("cannot operate on a NULL stack");
        return CAT_STACK_ERR;
    }
    int result;
    CATCS_ENTER(stk->mutex);
    result = _isCatStackEmpty(stk);
    CATCS_LEAVE(stk->mutex);

    return result;
}

int catStackPop(CatStack_T pStack, void** pReceiver) {
    if (pStack == NULL) {
        g_config.logger->error("cannot operate on a NULL stack");
        return CAT_STACK_ERR;
    }

    CATCS_ENTER(pStack->mutex);
    if (_isCatStackEmpty(pStack)) {
        CATCS_LEAVE(pStack->mutex);
        return CAT_STACK_ERR;
    }

    *pReceiver = pStack->valueArray[(pStack->top) - 1];
    pStack->top -= 1;
    CATCS_LEAVE(pStack->mutex);

    return CAT_STACK_OK;
}

int catStackPeek(CatStack_T pStack, void** pReceiver) {
    if (pStack == NULL) {
        g_config.logger->error("cannot operate on a NULL stack");
        return CAT_STACK_ERR;
    }

    CATCS_ENTER(pStack->mutex);
    if (_isCatStackEmpty(pStack)) {
        CATCS_LEAVE(pStack->mutex);
        return CAT_STACK_ERR;
    }
    *pReceiver = pStack->valueArray[(pStack->top)-1];
    CATCS_LEAVE(pStack->mutex);

    return CAT_STACK_OK;
}

static int ensureCATDynamicStack(CatStack_T pStack) {
    if (pStack->top + 1 < pStack->capacity) {
        return CAT_STACK_OK;
    }

    return enlargeDynamicStack(pStack, (pStack->capacity) * 2);
}

static int enlargeDynamicStack(CatStack_T pStack, size_t targetCapacity) {
    uint64_t targetMemorySize = sizeof(void*) * targetCapacity;
    void** newValueArray = malloc(targetMemorySize);
    if (newValueArray == NULL) {
        g_config.logger->error("failed to malloc %ld memory to enlarge cat dynamic queue", targetMemorySize);
        return CAT_STACK_ERR;
    }

    memset(newValueArray, 0, targetMemorySize);

    for (int i = 0; i < pStack->top; ++i) {
        newValueArray[i] = pStack->valueArray[i];
    }
    void** oldValueArray = pStack->valueArray;
    pStack->valueArray = newValueArray;
    pStack->capacity = targetCapacity;
    free(oldValueArray);
    return CAT_STACK_OK;
}

int catStackSize(CatStack_T stk) {
    int size = stk->top;
    CATCS_ENTER(stk->mutex);
    size = stk->top;
    CATCS_LEAVE(stk->mutex);

    return size;
}

int catStackGetByIndex(CatStack_T stk, int index, void** receiver) {
    CATCS_ENTER(stk->mutex);
    if (index < 0 || index >= stk->top) {
        CATCS_LEAVE(stk->mutex);
        return CAT_STACK_ERR;
    }
    *receiver = stk->valueArray[stk->top - 1 - index];
    CATCS_LEAVE(stk->mutex);

    return CAT_STACK_OK;
}

int catStackClear(CatStack_T stk) {
    CATCS_ENTER(stk->mutex);
    for (int i = 0; i < stk->top; ++i) {
        stk->valueArray[i] = NULL;
    }
    stk->top = 0;
    CATCS_LEAVE(stk->mutex);

    return CAT_STACK_OK;
}

int catStackDestroy(CatStack_T* stk) {
    if (stk == NULL || *stk == NULL) {
        g_config.logger->error("cannot destroy a NULL pointer cat stack");
        return CAT_STACK_ERR;
    }

    free((*stk)->valueArray);
    CatDeleteCriticalSection((*stk)->mutex);
    free((*stk));
    *stk = NULL;

    return CAT_STACK_OK;
}


