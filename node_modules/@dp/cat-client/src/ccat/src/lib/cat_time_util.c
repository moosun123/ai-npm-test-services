#include "cat_time_util.h"

#ifdef WIN32
#define THREADLOCAL __declspec(thread)
#elif defined(__linux__) || defined(__APPLE__)
#define THREADLOCAL __thread
#else
#define THREADLOCAL
#endif

/* This is a safe version of localtime() which contains no locks and is
 * fork() friendly. Even the _r version of localtime() cannot be used safely
 * in Redis. Another thread may be calling localtime() while the main thread
 * forks(). Later when the child process calls localtime() again, for instance
 * in order to log something to the Redis log, it may deadlock: in the copy
 * of the address space of the forked process the lock will never be released.
 *
 * This function takes the timezone 'tz' as argument, and the 'dst' flag is
 * used to check if daylight saving time is currently in effect. The caller
 * of this function should obtain such information calling tzset() ASAP in the
 * main() function to obtain the timezone offset from the 'timezone' global
 * variable. To obtain the daylight information, if it is currently active or not,
 * one trick is to call localtime() in main() ASAP as well, and get the
 * information from the tm_isdst field of the tm structure. However the daylight
 * time may switch in the future for long running processes, so this information
 * should be refreshed at safe times.
 *
 * Note that this function does not work for dates < 1/1/1970, it is solely
 * designed to work with what time(NULL) may return, and to support Redis
 * logging of the dates, it's not really a complete implementation. */
static int is_leap_year(time_t year) {
    if (year % 4) return 0;         /* A year not divisible by 4 is not leap. */
    else if (year % 100) return 1;  /* If div by 4 and not 100 is surely leap. */
    else if (year % 400) return 0;  /* If div by 100 *and* 400 is not leap. */
    else return 1;                  /* If div by 100 and not by 400 is leap. */
}

struct tm cat_nolocks_localtime(time_t t) {
    struct tm tmp;

    struct timeval tv;
    struct timezone tzone;

    time_t tz = -8 * 3600UL;//
    int dst = 0UL;//
    const time_t secs_min = 60;
    const time_t secs_hour = 3600;
    const time_t secs_day = 3600 * 24;

    t -= tz;                            /* Adjust for timezone. */
    t += 3600 * dst;                      /* Adjust for daylight time. */
    time_t days = t / secs_day;         /* Days passed since epoch. */
    time_t seconds = t % secs_day;      /* Remaining seconds. */

    tmp.tm_isdst = dst;
    tmp.tm_hour = seconds / secs_hour;
    tmp.tm_min = (seconds % secs_hour) / secs_min;
    tmp.tm_sec = (seconds % secs_hour) % secs_min;

    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
     * where sunday = 0, so to calculate the day of the week we have to add 4
     * and take the modulo by 7. */
    tmp.tm_wday = (days + 4) % 7;

    /* Calculate the current year. */
    tmp.tm_year = 1970;
    while (1) {
        /* Leap years have one day more. */
        time_t days_this_year = 365 + is_leap_year(tmp.tm_year);
        if (days_this_year > days) break;
        days -= days_this_year;
        tmp.tm_year++;
    }
    tmp.tm_yday = days;  /* Number of day of the current year. */

    /* We need to calculate in which month and day of the month we are. To do
     * so we need to skip days according to how many days there are in each
     * month, and adjust for the leap year that has one more day in February. */
    int mdays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    mdays[1] += is_leap_year(tmp.tm_year);

    tmp.tm_mon = 0;
    while (days >= mdays[tmp.tm_mon]) {
        days -= mdays[tmp.tm_mon];
        tmp.tm_mon++;
    }

    tmp.tm_mday = days + 1;  /* Add 1 since our 'days' is zero-based. */
    tmp.tm_year -= 1900;   /* Surprisingly tm_year is year-1900. */
    return tmp;
}

char *GetTimeString(u_int64 srcTime) {

    //tm数据结构解释
    //struct tm
    //{
    //	int tm_sec; /* 秒取值区间为[0,59] */
    //	int tm_min; /* 分 - 取值区间为[0,59] */
    //	int tm_hour; /* 时 - 取值区间为[0,23] */
    //	int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */
    //	int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */
    //	int tm_year; /* 年份，其值从1900开始 */
    //	int tm_wday; /* 星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */
    //	int tm_yday; /* 从每年的1月1日开始的天数取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */
    //	int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/
    //	long int tm_gmtoff; /*指定了日期变更线东面时区中UTC东部时区正秒数或UTC西部时区的负秒数*/
    //	const char *tm_zone; /*当前时区的名字(与环境变量TZ有关)*/
    //};

    time_t t = 0;
    if (srcTime == 0) {
        t = time(0);
    } else {
        t = srcTime / 1000;
    }

    static THREADLOCAL char *tmp = NULL;
    if (tmp == NULL) {
        tmp = (char *) malloc(128);
    }

#pragma warning( push )
#pragma warning( disable : 4996 )
    strftime(tmp, 64, "%Y-%m-%d_%H-%M-%S", localtime(&t));
#pragma warning( pop )
    return tmp;
}

char *GetDetailTimeString(u_int64 srcTime) {
    time_t t = 0;
#if defined(WIN32)
    struct __timeb64 timeBuf;
    if (srcTime == 0)
    {
        t = time(0);
        _ftime64_s(&timeBuf);
    }
    else
    {
        t = srcTime / 1000;
        timeBuf.millitm = srcTime % 1000;
    }
#elif defined(__linux__) || defined(__APPLE__)

    struct timeval tv;

    if (srcTime == 0) {
        gettimeofday(&tv, NULL);
        t = tv.tv_sec;
    } else {
        t = srcTime / 1000;
        tv.tv_usec = (srcTime % 1000) * 1000;
    }
#endif
    static THREADLOCAL char *tmp = NULL;
    if (tmp == NULL) {
        tmp = (char *) malloc(128);
    }

#pragma warning( push )
#pragma warning( disable : 4996 )
    strftime(tmp, 128, "%Y-%m-%d_%H-%M-%S", localtime(&t));
#pragma warning( pop )
    size_t timeBufLen = strlen(tmp);
#if defined(WIN32)
    sprintf_s(tmp + timeBufLen, 128 - timeBufLen, "-%03d", timeBuf.millitm);
#else
    snprintf(tmp + timeBufLen, sizeof(tmp) - timeBufLen, "-%03d", (int) (tv.tv_usec / 1000));
#endif
    return tmp;
}

char *GetCatTimeString(u_int64 srcTime) {
    time_t t = 0;
#if defined(WIN32)
    struct __timeb64 timeBuf;
    if (srcTime == 0)
    {
        t = time(0);
        _ftime64_s(&timeBuf);
    }
    else
    {
        t = srcTime / 1000;
        timeBuf.millitm = srcTime % 1000;
    }
#elif defined(__linux__) || defined(__APPLE__)

    struct timeval tv;

    if (srcTime == 0) {
        gettimeofday(&tv, NULL);
        t = tv.tv_sec;
    } else {
        t = srcTime / 1000;
        tv.tv_usec = (srcTime % 1000) * 1000;
    }
#endif
    static THREADLOCAL char *tmp = NULL;
    if (tmp == NULL) {
        tmp = (char *) malloc(128);
    }

#pragma warning( push )
#pragma warning( disable : 4996 )
    strftime(tmp, 128, "%Y-%m-%d_%H:%M:%S", localtime(&t));
#pragma warning( pop )
    size_t timeBufLen = strlen(tmp);
#if defined(WIN32)
    sprintf_s(tmp + timeBufLen, 128 - timeBufLen, ".%03d", timeBuf.millitm);
#else
    snprintf(tmp + timeBufLen, sizeof(tmp) - timeBufLen, ".%03d", (int) (tv.tv_usec / 1000));
#endif
    return tmp;

}