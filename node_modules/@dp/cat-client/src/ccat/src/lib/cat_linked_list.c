
#include "cat_linked_list.h"
#include "cat_mutex.h"
#include "cat/client_config.h"

typedef struct _CatLinkedListNode {
    struct _CatLinkedListNode* prev;
    struct _CatLinkedListNode* next;
    void* data;
} CatLinkedListNode;

struct _CatLinkedList_T {
    CatLinkedListNode * head;
    CatLinkedListNode * tail;
    uint64_t size;
    CatCriticalSection mutex;
    catLinkedListDataDestroy dataDestroyer;
};

static void catLinkedListDefaultDataDestroyer(void* data) {

}

int newCatLinkedList(CatLinkedList_T* receiver, catLinkedListDataDestroy dataDestroyer) {
    CatLinkedList_T list = (CatLinkedList_T) malloc(sizeof(struct _CatLinkedList_T));
    if (list == NULL) {
        g_config.logger->error("failed to malloc for CatLinkedList_T");
        *receiver = NULL;
        return 0;
    }

    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
    list->mutex = CatCreateCriticalSection();
    list->dataDestroyer = catLinkedListDefaultDataDestroyer;
    if (dataDestroyer != NULL) {
        list->dataDestroyer = dataDestroyer;
    }
    *receiver = list;
    return 1;
}

int catLinkedListAdd(CatLinkedList_T list, void* data) {
    if (list == NULL) {
        return 0;
    }
    CatLinkedListNode * node = (CatLinkedListNode*)malloc(sizeof(CatLinkedListNode));
    if (node == NULL) {
        g_config.logger->error("failed to malloc for CatLinkedListNode");
        return 0;
    }

    node->data = data;

    CATCS_ENTER(list->mutex);
    if (list->head == NULL && list->tail == NULL) {
        list->head = node;
        list->tail = node;
        node->prev = node;
        node->next = node;
        list->size = 1;
    } else {
        list->tail->next = node;
        node->prev = list->tail;
        node->next = list->head;
        list->tail = node;
        list->head->prev = list->tail;
        list->size += 1;
    }
    CATCS_LEAVE(list->mutex);

    return 1;
}

int catLinkedListRemove(CatLinkedList_T list, void* data) {
    if (list == NULL) {
        return 0;
    }

    CATCS_ENTER(list->mutex);
    if (list->head == NULL) {
        CATCS_LEAVE(list->mutex);
        return 0;
    }

    CatLinkedListNode * node_to_be_examined = list->head;
    for (int i = 0; i < list->size; ++i, node_to_be_examined = node_to_be_examined->next) {
        if (node_to_be_examined->data == data) {
            CatLinkedListNode * prev_node = node_to_be_examined->prev;
            CatLinkedListNode * next_node = node_to_be_examined->next;
            if (node_to_be_examined == list->head) {
                list->head = next_node;
            }
            if (node_to_be_examined == list->tail) {
                list->tail = prev_node;
            }

            prev_node->next = next_node;
            next_node->prev = prev_node;

            free(node_to_be_examined);
            list->size -= 1;
            CATCS_LEAVE(list->mutex);
            return 1;
        }
    }

    CATCS_LEAVE(list->mutex);
    return 0;
}

int catLinkedListSize(CatLinkedList_T list) {
    if (list == NULL) {
        return 0;
    }
    int size;
    CATCS_ENTER(list->mutex);
    size = list->size;
    CATCS_LEAVE(list->mutex);

    return size;
}

int catLinkedListDestroy(CatLinkedList_T list) {
    if (list == NULL) {
        return 0;
    }

    CATCS_ENTER(list->mutex);
    if (list->head != NULL) {

        void** node_pointers = (void **)malloc(sizeof(void*) * list->size);
        if (node_pointers == NULL) {
            g_config.logger->error("failed to allocate for node pointers when destroy CatLinkedList");
            CATCS_LEAVE(list->mutex);
            return 0;
        }
        CatLinkedListNode * cursor_node = list->head;
        for (int i = 0; i < list->size; ++i) {
            node_pointers[i] = cursor_node;
            cursor_node = cursor_node->next;
        }

        for (int i = 0; i < list->size; ++i) {
            CatLinkedListNode * node = (CatLinkedListNode*)node_pointers[i];
            list->dataDestroyer(node->data);
            free(node_pointers[i]);
        }

        free(node_pointers);
    }

    CATCS_LEAVE(list->mutex);
    CatDeleteCriticalSection(list->mutex);
    free(list);
    return 1;
}

/**
 * a memory space is allocated within this function, it is the user's
 * responsibility to free this memory after use.
 * */
extern int catLinkedListToArray(CatLinkedList_T list, void*** receiver, int* length) {
    if (list == NULL) {
        return 0;
    }

    int size;
    CATCS_ENTER(list->mutex);
    size = list->size;
    void** dataArray = (void **) malloc(sizeof(void*) * size);
    CatLinkedListNode * cursor_node = list->head;
    for (int i = 0; i < list->size; ++i) {
        dataArray[i] = cursor_node->data;
        cursor_node = cursor_node->next;
    }
    CATCS_LEAVE(list->mutex);

    *receiver = dataArray;
    *length = size;
    return 1;
}