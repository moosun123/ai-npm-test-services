#include "cat_ccmap.h"
#include <string.h>

extern unsigned int catDictStringCopyHTHashFunction(const void *key);


static int getCCHashMapSlotIndexByKey(CatCCHashMap *pCCHM, void *key) {
    return catDictStringCopyHTHashFunction(key) % pCCHM->m_hashSlotCount;
}

CatCCHashMap *catCreateCCHashMap(catDictType *type, int slotCount, void *privDataPtr) {
    if (type == NULL || slotCount <= 0 || slotCount > CAT_CCHASHMAP_MAXSLOT) {
        return NULL;
    }
    int hashMapSize = sizeof(CatCCHashMap) + slotCount * sizeof(CatCCHashSlot);
    CatCCHashMap *pHashMap = (CatCCHashMap *) malloc(hashMapSize);
    if (pHashMap == NULL) {
        return NULL;
    }
    memset(pHashMap, 0, hashMapSize);
    pHashMap->m_hashSlotCount = slotCount;
    pHashMap->m_privateData = privDataPtr;
    memcpy(&pHashMap->m_type, type, sizeof(catDictType));
    int i = 0;
    for (; i < slotCount; ++i) {
        pHashMap->m_hashSlot[i].m_lock = CatCreateCriticalSection();
    }
    return pHashMap;
}

void *catFindCCHashMap(CatCCHashMap *pCCHM, void *key) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        return NULL;
    }
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
    void *val = pEntry == NULL ? NULL : pEntry->val;
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}

void *catFindCCHashMapDefault(CatCCHashMap *pCCHM, void *key, void *defaultVal) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        return defaultVal;
    }
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
    void *val = pEntry == NULL ? defaultVal : pEntry->val;
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}

void *catFindCCHashMapCreate(CatCCHashMap *pCCHM, void *key, void *createVal) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
        // check again in lock
        if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
            pCCHM->m_hashSlot[idx].m_dict = catDictCreate(&pCCHM->m_type, NULL);
        }
    }
    int rst = catDictAdd(pCCHM->m_hashSlot[idx].m_dict, key, createVal);
    void *val = createVal;
    // if add fails, it means there is already a key-val pair in pCCHM
    if (rst == CAT_DICT_ERR) {
        catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
        val = pEntry == NULL ? NULL : pEntry->val;
    }
    if (rst == CAT_DICT_OK) {
        CAT_ATOMICLONG_INC(&pCCHM->m_count);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}

void *catFindCCHashMapAndOperate(CatCCHashMap *pCCHM, void *key, CatCCHashMapValOptFun optFun, void *param) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        return NULL;
    }
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
    void *val = pEntry == NULL ? NULL : pEntry->val;
    if (val != NULL) {
        // @todo need check
        optFun(pCCHM, key, &pEntry->val, param);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}


void *catFindCCHashMapCreateByFun(CatCCHashMap *pCCHM, void *key, CatCCHashMapCreateValFun createFun, void *createParam) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        // check again in lock
        if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
            pCCHM->m_hashSlot[idx].m_dict = catDictCreate(&pCCHM->m_type, NULL);
        }
    }
    catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
    void *val = pEntry == NULL ? NULL : pEntry->val;
    if (pEntry == NULL) {
        // @todo need check
        val = createFun(pCCHM, key, createParam);
        catDictAdd(pCCHM->m_hashSlot[idx].m_dict, key, val);
        CAT_ATOMICLONG_INC(&pCCHM->m_count);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}

void *
catFindCCHashMapCreateByFunAndOperate(CatCCHashMap *pCCHM, void *key, CatCCHashMapCreateValFun createFun, void *createParam,
                                      CatCCHashMapValOptFun optFun, void *optParam) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        // check again in lock
        if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
            pCCHM->m_hashSlot[idx].m_dict = catDictCreate(&pCCHM->m_type, NULL);
        }
    }
    catDictEntry *pEntry = catDictFind(pCCHM->m_hashSlot[idx].m_dict, key);
    void *val = pEntry == NULL ? NULL : pEntry->val;
    if (pEntry == NULL) {
        // @todo need check
        val = createFun(pCCHM, key, createParam);
        // @todo need check
        optFun(pCCHM, key, &val, optParam);
        catDictAdd(pCCHM->m_hashSlot[idx].m_dict, key, val);
        CAT_ATOMICLONG_INC(&pCCHM->m_count);
    } else {
        // @todo need check
        optFun(pCCHM, key, &pEntry->val, optParam);
    }


    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return val;
}


int catPutCCHashMap(CatCCHashMap *pCCHM, void *key, void *pVal) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
            pCCHM->m_hashSlot[idx].m_dict = catDictCreate(&pCCHM->m_type, NULL);
        }
    }
    int rst = catDictAdd(pCCHM->m_hashSlot[idx].m_dict, key, pVal);
    if (rst == CAT_DICT_OK) {
        CAT_ATOMICLONG_INC(&pCCHM->m_count);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return rst;
}

int catReplaceCCHashMap(CatCCHashMap *pCCHM, void *key, void *pVal) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
            pCCHM->m_hashSlot[idx].m_dict = catDictCreate(&pCCHM->m_type, NULL);
        }
    }
    int rst = catDictReplace(pCCHM->m_hashSlot[idx].m_dict, key, pVal);
    // return err means there has contained the key, ok means the key is new
    if (rst == CAT_DICT_OK) {
        CAT_ATOMICLONG_INC(&pCCHM->m_count);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return CAT_CCHASHMAP_OK;
}

int catRemoveCCHashMap(CatCCHashMap *pCCHM, void *key) {
    int idx = getCCHashMapSlotIndexByKey(pCCHM, key);
    if (pCCHM->m_hashSlot[idx].m_dict == NULL) {
        return CAT_CCHASHMAP_ERR;
    }
    CATCS_ENTER(pCCHM->m_hashSlot[idx].m_lock);
    int rst = catDictDelete(pCCHM->m_hashSlot[idx].m_dict, key);
    if (rst == CAT_DICT_OK) {
        CAT_ATOMICLONG_DEC(&pCCHM->m_count);
    }
    CATCS_LEAVE(pCCHM->m_hashSlot[idx].m_lock);
    return rst;
}


catDict **catMoveCCHashMap(CatCCHashMap *pCCHM) {
    catDict **ppDict = (catDict **) malloc(sizeof(catDict *) * (pCCHM->m_hashSlotCount + 1));
    if (ppDict == NULL) {
        return NULL;
    }
    memset(ppDict, 0, sizeof(catDict *) * (pCCHM->m_hashSlotCount + 1));
    int i = 0;
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        CATCS_ENTER(pCCHM->m_hashSlot[i].m_lock);
    }
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        ppDict[i] = pCCHM->m_hashSlot[i].m_dict;
        pCCHM->m_hashSlot[i].m_dict = NULL;
    }
    pCCHM->m_count = 0;
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        CATCS_LEAVE(pCCHM->m_hashSlot[i].m_lock);
    }
    ppDict[i] = NULL;
    return ppDict;
}

void catFreeDictArray(catDict **ppDict) {
    free(ppDict);
}


void catOptEveryCCHashMapItem(CatCCHashMap *pCCHM, CatCCHashMapValOptFun optFun, void *optParam) {
    int i = 0;
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        CATCS_ENTER(pCCHM->m_hashSlot[i].m_lock);
        if (pCCHM->m_hashSlot[i].m_dict != NULL) {
            catDictIterator *iter = catDictGetIterator(pCCHM->m_hashSlot[i].m_dict);
            if (iter != NULL) {
                catDictEntry *pEntry = NULL;
                while ((pEntry = catDictNext(iter)) != NULL) {
                    optFun(pCCHM, pEntry->key, &pEntry->val, optParam);
                }
                catDictReleaseIterator(iter);
            }
        }
        CATCS_LEAVE(pCCHM->m_hashSlot[i].m_lock);
    }
}


void catClearCCHashMap(CatCCHashMap *pCCHM) {
    int i = 0;
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        CATCS_ENTER(pCCHM->m_hashSlot[i].m_lock);
    }
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        if (pCCHM->m_hashSlot[i].m_dict != NULL) {
            catDictEmpty(pCCHM->m_hashSlot[i].m_dict);
        }
    }
    pCCHM->m_count = 0;
    for (i = 0; i < pCCHM->m_hashSlotCount; ++i) {
        CATCS_LEAVE(pCCHM->m_hashSlot[i].m_lock);
    }
}

void catDestroyCCHashMap(CatCCHashMap *pCCHM) {
    int i = 0;
    for (; i < pCCHM->m_hashSlotCount; ++i) {
        CatDeleteCriticalSection(pCCHM->m_hashSlot[i].m_lock);
        if (pCCHM->m_hashSlot[i].m_dict != NULL) {
            catDictRelease(pCCHM->m_hashSlot[i].m_dict);
        }
    }
    free(pCCHM);
}
