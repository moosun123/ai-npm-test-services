# Cat-Client C客户端

# Installation

编译命令：

根目录下

```bash
make clean
make
```

> 若在 osx 平台下编译，请修改 cat.mk 的 LIBS，去掉 -lrt

若使用动态链接库，则将编译后生成的libcatclient.so文件放在LD_LIBRARY_PATH下。

例如在/etc/ld.so.conf下加入/usr/local/lib.

执行ldconfig

test—case编译：

    动态链接库：
    gcc cat_client_test.c -lcatclient -I../src/cat -I../src -I../include -o test
    
    静态链接库：
    gcc cat_client_test.c -g ../lib/libcatclient.a -I../src/cat -I../src -I../include -lpthread -lrt -lm -o test

## 使用 CMake 编译安装

目前支持 osx 和 centos7.

```bash
mkdir -p cmake
cd cmake
cmake .. && make -j && make install
```

如果你是源码依赖于该客户端，还请在测试的时候使用如下的编译命令

```shell
mkdir -p cmake
cd cmake
cmake .. -DCMAKE_BUILD_TYPE=DEBUG
```

在生产阶段，可以使用如下编译选项

```shell
mkdir -p cmake
cd cmake
cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo
```

最主要的目的，还是希望你在运行的时候带有debug info，编译出现问题时排查。

## 运行单元测试

* **OSX** 需要安装 `gcovr` 工具，可以通过 `sudo pip install gcovr` 安装。
* **Linux** 需要安装 `lcov` 工具，安装方法请参考 [Link](http://ltp.sourceforge.net/coverage/lcov.php)

```bash
./unittest.sh
```

# Usage

## Initialization

    引入头文件：#include "cat/client.h"
    
    catClientInit("appkey"); //初始化cat环境
    
    保证/data/appdatas/cat目录有读写权限，并保证该目录下有client.xml文件，例如qa环境文件内容：
    
    <?xml version="1.0" encoding="utf-8"?>
    
    <config mode="client" xmlns:xsi="http://www.w3.org/2001/XMLSchema" xsi:noNamespaceSchemaLocation="config.xsd">
    	<servers>
    		<server ip="10.66.67.17" port="2280"/>
    	</servers>
    </config>
    
    若不存在client.xml文件，则会尝试从远程服务器（cat.dp）获取client配置。

## Integration

    静态库：
    
    gcc your_project -L your_static_lib_dir -lcatclient -I cat_include_dir -pthread -lrt -lm -o your_out_file
    
    动态库（确保libcatclient.so可以被搜索到）：
    
    gcc your_project -lcatclient -I cat_include_dir -o your_out_file

## Transaction

    示例1：
    CatTransaction *trans = newTransaction("type", "name");
    
     // your bussiness
    
    trans->setStatus((CatMessage *) trans, CAT_SUCCESS); // 失败状态则置为CAT_ERROR
    trans->setComplete((CatMessage *) trans);
    
    示例2：
    CatTransaction *trans = newTransaction("type", "name");
    
     // your bussiness
    
    trans->setDurationInMillis(trans, 2000); //自己计算打点时间并填入
    trans->setStatus((CatMessage *) trans, CAT_SUCCESS); // 失败状态则置为CAT_ERROR
    trans->setComplete((CatMessage *) trans);
    
    示例3：
    CatTransaction *trans = newTransactionWithDuration("type", "name", 2000);
    
     // your bussiness
    
    trans->setStatus((CatMessage *) trans, CAT_SUCCESS); // 失败状态则置为CAT_ERROR
    trans->setComplete((CatMessage *) trans);

## Event

    logEvent("type", "name", CAT_SUCCESS, NULL);

## Error

    logError("nullerror", "errorcontent");

## Metric

    logMetricForCount("yourKey");

## Demo

    #include "cat/client.h"
    #include <unistd.h>
    
    int main(int argc, char **argv) {
        catClientInit("appkey");
    
        int i = 0;
        for (i = 0; i < 100; i++) {
            CatTransaction *trans = newTransaction("cclienttest", "simple");
            trans->setStatus((CatMessage *) trans, CAT_SUCCESS);
            trans->setComplete((CatMessage *) trans);
        }
    
        sleep(100000);
        catClientDestroy();
        return 0;
    }

# 使用说明

## 日志

在之前的版本中，ccat都会自己输出到日志到一个固定的路径，如果单台机器只有一个进程接入cat就还好，但是如果有多个进程接入cat，就会出现多个进程写同一个文件的问题，存在潜在的隐患。所以在这个版本中，我们重构了日志的使用方式，允许ccat的使用者自己自定义日志的实现方式，以方便各个进程有自己独立的日志输出。

1. 默认行为
   1. 如果用户没有指定日志的实现，那么ccat仍然有一个默认的实现，它将把日志输出到`/data/applogs/cat/ccat_xxxx_xx_xx.log`下，如果因为一些原因不能写入到这个问题，则会写入到`/tmp/ccat_xxxx_xx_xx.log`中。
   2. 这种做法跟之前的版本的做法是一致的，会出现多个不同进程同时写同一个日志文件的问题。

### 实现自己的日志输出

在新的版本中，我们为ccat的客户端配置增加了一些字段

```c
typedef struct _CatClientConfig {
    uint32_t encoderType;
    uint8_t enableHeartbeat;
    uint8_t enableSampling;
    uint8_t enableMultiprocessing;
    uint8_t enableAutoInitialize;
    uint32_t loggingLevelConfig;
    CatLogger* logger;
    char* componentSwitch;
} CatClientConfig;
```

主要的就是`CatLogger`对象，使用者只要实现自己的CatLogger，并使用相应的`CatClientConfig`来初始化ccat就可以了。`CatLogger`的定义如下：

```c
typedef void (*loggerFunction)(const char *format, ...);

typedef struct _CatLogger {
    loggerFunction info;
    loggerFunction error;
    loggerFunction warning;
    loggerFunction debug;
} CatLogger;
```

默认的CatLogger实现如下：

```c
CatLogger default_cat_logger = {
        .info = default_cat_info_log,
        .error = default_cat_error_log,
        .warning = default_cat_warning_log,
        .debug = default_cat_debug_log,
};

CatClientConfig DEFAULT_CCAT_CONFIG = {
        .encoderType = CAT_ENCODER_BINARY,
        .enableHeartbeat = 1,  // enable heartbeat
        .enableSampling = 1,  // enable sampling
        .enableMultiprocessing = 1, // no longer used
        .loggingLevelConfig = CAT_LOG_INFO,  // only log info level
        .enableAutoInitialize = 0,  // disable auto initialize when forked
        .logger = &default_cat_logger,
        .componentSwitch = CAT_DEFAULT_SUB_COMPONENT_NAME,
};
```

然后使用`catClientInitWithConfig`来初始化ccat就可以了。

## 禁用心跳

从上面CatClientConfig的定义中可以看到，有一个`enableHeartbeat`的配置，可以让用户来决定到底要不要开启该进程的心跳上报，该配置项的主要考量还是针对架构进程来配置的，具体的描述，可以[参考wiki](https://km.sankuai.com/page/238052474)。

## 注册子模块

现在由于架构进程的存在，它要跟业务进程同时运行在同一台机器上，这就会出现在一台linux机器上，既有运行业务的java进程，又有一个架构提供的c进程。有些时候，我们希望对架构进程的cat上报做出控制，以便保护真正业务进程的数据上报。所以，我们在新的配置项中增加了一个`componentSwitch`配置项，当用户注册了该子模块开关的时候，用户就可以通过cat下发配置来打开或者关闭响应子模块的cat上报。

因此，之后的行为就会变成

```c
CatClientConfig my_config = {
        .encoderType = CAT_ENCODER_BINARY,
        .enableHeartbeat = 1,  // enable heartbeat
        .enableSampling = 1,  // enable sampling
        .enableMultiprocessing = 1, // no longer used
        .loggingLevelConfig = CAT_LOG_INFO,  // only log info level, only for default cat logger
        .enableAutoInitialize = 0,  // disable auto initialize when forked
        .logger = &logger_implemented_by_user,
        .componentSwitch = "user_component",
};

catClientInitWithConfig("your-app-key", &my_config);
```



