const { interval } = require('../index')

describe('#interval', () => {
    test('return an object with pause , resume', () => {
        let fn = jest.fn()
        let it = interval(fn, 10)
        expect(typeof it.pause).toBe('function')
        expect(typeof it.resume).toBe('function')
    })
    test('run immediately when third param "isImmediate" is true', () => {
        let fn = jest.fn()
        interval(fn, 1, true)
        expect(fn.mock.calls.length).toBeGreaterThanOrEqual(1)
    })
    test('do not run immediately when third param "isImmediate" is false', () => {
        let fn = jest.fn()
        interval(fn, 1, false)
        expect(fn.mock.calls.length).toBe(0)
    })
    test('run interval', () => {
        let fn = jest.fn()
        interval(fn, 0.001, false)
        return new Promise(resolve => {
            let count = 0
            setTimeout(() => {
                count = fn.mock.calls.length
                expect(count).toBeGreaterThan(1)
            }, 50)
            setTimeout(() => {
                expect(fn.mock.calls.length).toBeGreaterThan(count)
                resolve()
            }, 80)
        })
    })
    test('run function return resolve promise', () => {
        let fn = jest.fn(() => Promise.resolve())
        interval(fn, 0.001, false)
        return new Promise(resolve => {
            let count = 0
            setTimeout(() => {
                count = fn.mock.calls.length
                expect(count).toBeGreaterThan(1)
            }, 50)
            setTimeout(() => {
                expect(fn.mock.calls.length).toBeGreaterThan(count)
                resolve()
            }, 80)
        })
    })
    test('run function return reject promise', () => {
        let fn = jest.fn(() => Promise.reject(new Error()))
        interval(fn, 0.001, false)
        return new Promise(resolve => {
            let count = 0
            setTimeout(() => {
                count = fn.mock.calls.length
                expect(count).toBeGreaterThan(1)
            }, 50)
            setTimeout(() => {
                expect(fn.mock.calls.length).toBeGreaterThan(count)
                resolve()
            }, 80)
        })
    })
    test('pause', () => {
        let fn = jest.fn()
        let it = interval(fn, 0.01, false)
        it.pause()
        return new Promise(resolve => {
            setTimeout(() => {
                expect(fn.mock.calls.length).toBe(0)
                resolve()
            }, 100)
        })
    })
    test('resume immediately', () => {
        let fn = jest.fn()
        let it = interval(fn, 0.01, false)
        it.pause()
        expect(fn.mock.calls.length).toBe(0)
        it.resume(true)
        expect(fn.mock.calls.length).toBe(1)
    })
    test('resume delay', () => {
        let fn = jest.fn()
        let it = interval(fn, 0.01, false)
        it.pause()
        expect(fn.mock.calls.length).toBe(0)
        it.resume(false)
        expect(fn.mock.calls.length).toBe(0)
        return new Promise(resolve => {
            setTimeout(() => {
                expect(fn.mock.calls.length).toBeGreaterThan(0)
                resolve()
            }, 100)
        })
    })
    test('multiple resume do not works', () => {
        let fn = jest.fn()
        let it = interval(fn, 0.01, false)
        expect(fn.mock.calls.length).toBe(0)
        it.pause()
        it.resume(true)
        expect(fn.mock.calls.length).toBe(1)
        it.resume(true)
        expect(fn.mock.calls.length).toBe(1)
        it.resume(true)
        expect(fn.mock.calls.length).toBe(1)
    })
})
