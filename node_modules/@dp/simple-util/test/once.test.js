const { once } = require('../index')

describe('#asyncOnce', () => {
    test('only run once and get the same value', () => {
        // 普通函数返回promise
        let fn = jest.fn()
        fn.mockImplementation(() => Promise.resolve())
        let run = once(fn)
        let v1 = run()
        let v2 = run()
        expect(fn.mock.calls.length).toBe(1)
        expect(v1).toBe(v2)

        // 普通函数返回null值
        let nullValues = [undefined, null, 0, false, '', NaN]
        nullValues.forEach(value => {
            let fn = jest.fn(() => value)
            run = once(fn)
            let v1 = run()
            let v2 = run()
            expect(fn.mock.calls.length).toBe(1)
            expect(v1).toBe(v2)
        })

        // async 函数
        let count = 0
        fn = async function() { if (count++ > 1) { throw new Error() } return 1 }
        run = once(fn)
        v1 = run()
        v2 = run()
        expect(v1).toBe(v2)
    })

    test('called with the same args', () => {
        // 返回原参数数组
        let fn = jest.fn((...args) => args)
        let run = once(fn)
        let args = [Math.random(), Math.random(), undefined, null]
        expect(run(...args)).toEqual(args)
    })

    test('work with class', () => {
        class A {
            constructor() {
                this.x = 1
                this.init = once(this._init.bind(this))
            }
            _init() {
                this.x++
            }
        }
        let a = new A()
        a.init()
        a.init()
        expect(a.x === 2)
    })

    test('`this`', () => {
        let self = this
        let fn = () => {
            expect(this).toBe(self)
        }
        let onceFn = once(fn)
        onceFn()
    })
})
