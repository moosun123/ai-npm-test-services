const os = require('os')
const fs = require('fs')
const net = require('net')
const childProcess = require('child_process')

const crypto = require('crypto')
const httpclient = require('co-request')
const LOCAL_IP = require('ip').address()

let LINUX_KMS
const Env = require('@dp/server-env')
const SimpleUtil = require('@dp/simple-util')

const Logger = require('./lib/logger')

const FALLBACK_URL_ONLINE = 'http://kms.sankuai.com/api/platformV2/fallbackGetKey'
const FALLBACK_URL_OFFLINE = 'http://kms.test.sankuai.com/api/platformV2/fallbackGetKey'
const FALLBACK_URL_PAY = 'http://kms.pay.sankuai.com/api/platformV2/fallbackGetKey'

const KMS_PORT = 5269
const cat = require('@mtfe/cat')
cat.initCatAppKey()
const LOCAL_CACHE = {}
const LOCAL_CACHE_PAY = {}

let KMS_TYPE = 2 // 1 正常运行的linux环境 ， 2 mac环境或者非正常运行的linux环境
let portInUse = false

function getPort() {
    return new Promise((resolve)=>{
        if (portInUse === true) {
            resolve(true)
        } else {
            let timer = setTimeout(() => {
                resolve(false)
                cat.logError('KMS.Node',`timeout error`)
            }, 5000)
            let port = childProcess.execSync("lsof -i -P -n | grep ':5269 (LISTEN)' | wc -l ").toString()
            // 一些场景如 Nest 通过上面方式无法获取监听情况，直接用telnet
            let telnetResult = -1
            try {
                telnetResult = childProcess.execSync("echo '' | telnet 127.0.0.1 5269 | grep 'Connected to 127.0.0.1'").toString().indexOf("Connected to 127.0.0.1")
            } catch (e) {
                Logger.info("[NODE-KMS] KMS_PORT not found")
                cat.logError('KMS.Node',`KMS_PORT not found ${e}`)
            }
            clearTimeout(timer)
            if(parseInt(port) > 0 || telnetResult > -1) {
                portInUse = true
                Logger.info('[NODE-KMS] KMS_PORT is listen')
                resolve(true)
            } else {
                Logger.info('[NODE-KMS] KMS_PORT is unavailable.')
                resolve(false)
            }
        }
    })
}

function _init() {
    let soExist = fs.existsSync('/opt/meituan/kms/libs/libNodeKms.so')
    if (!soExist || os.platform() === 'darwin') {
        Logger.info('[NODE-KMS] KMS_TYPE : ' + KMS_TYPE)
        SimpleUtil.interval(() => {
            RefreshValueTask().catch(err => Logger.error('[NODE-KMS] RefreshValueTask error', err))
        }, 60)
        return Promise.resolve(true)
    }

    return getPort().then(portInUse => {
        if (portInUse && os.platform() === 'linux') {
            KMS_TYPE = 1
            try {
                LINUX_KMS = require('./lib/linux_kms')
            } catch (e) {
                Logger.info('[NODE-KMS] require kms lib error', e)
                KMS_TYPE = 2
            }
        }

        Logger.info('[NODE-KMS] KMS_TYPE : ' + KMS_TYPE)

        if (KMS_TYPE === 2) {
            SimpleUtil.interval(() => {
                RefreshValueTask().catch(err => Logger.error('[NODE-KMS] RefreshValueTask error', err))
            }, 60)
        }
    })
}

const init = SimpleUtil.once(_init)

function getKeyByName(appname, name, isPayCluster = false) {
    const trans = cat.newTransaction('KMS.Node',`getKeyByName.${KMS_TYPE}`)
    return init().then(() => {
            let val = null
            if (KMS_TYPE === 1) {
                val = Promise.resolve(LINUX_KMS.getKeyByName(appname, name, isPayCluster))
            } else {
                val = getFromCache(appname, name, isPayCluster)
            }
            if (val !== null) {
                trans.setStatus(cat.STATUS.SUCCESS)
            } else {
                trans.setStatus(`getKeyByName error`)
            }
            trans.complete()
            return val
    }).catch(e=>{
        trans.setStatus(`getKeyByName error ${e}`)
        trans.complete()
    })
}

function getFallbackUrl(isPayCluster) {
    let env = Env.getServerProperties().env
    if (env === 'prod' || env === 'staging' || env === 'product') {
        return isPayCluster ? FALLBACK_URL_PAY : FALLBACK_URL_ONLINE
    } else {
        return FALLBACK_URL_OFFLINE
    }
}

function fallbackRequest(appkey, name, isPayCluster) {
    let url = getFallbackUrl(isPayCluster)
    let env = Env.getServerProperties().env

    if (!env) {
        Logger.error('[NODE-KMS] `env` is missing in `/data/webapps/appenv`');
        return Promise.resolve(null);
    }

    // 兼容env为product的情况
    if (env === 'product') {
        env = 'prod'
    }

    let finalUrl = `${url}?appKey=${appkey}&env=${env}&name=${name}&ip=${LOCAL_IP}&host=${os.hostname()}&sdkVersion=node-sdk`
    return new Promise((resolve) => {
        httpclient({
            url: finalUrl,
            method: 'POST'
        }).then(res => {
            if (res && res.body) {
                return resolve(JSON.parse(res.body))
            }
        }).catch(e => {
            Logger.error('[NODE-KMS] FALLBACK_URL post error', e)
            cat.logError('KMS.Node',`get ${name} error ${e} `)
            resolve(null)
        })
    })
}

function getNameStore(appkey, name, isPayCluster) {
    return fallbackRequest(appkey, name, isPayCluster).then(res => {
        if (!res || res.code !== 200) {
            return null
        }
        return {
            appKey: res.data.AppKey,
            name: res.data.Name,
            rand: res.data.Rand,
            skey: Buffer.from(res.data.Skey, 'base64'),
            schema: res.data.Schema,
            version: res.data.Version
        }
    })
}

function getFromCache(appkey, name, isPayCluster) {
    let key = appkey + ':' + name
    let value
    if (isPayCluster) {
        value = LOCAL_CACHE_PAY[key]
    } else {
        value = LOCAL_CACHE[key]
    }
    if (!value) {
        return getNameStore(appkey, name, isPayCluster).then(value => {
            if (isPayCluster) {
                LOCAL_CACHE_PAY[key] = value
            } else {
                LOCAL_CACHE[key] = value
            }
            return value
        }).then(value => {
            if (!value) {
                // Logger.error(`[NODE-KMS] Secret info：${appkey} ${name}，not exist or remote call error`)
                // throw new Error('secret is empty')
                return Promise.resolve(null)
            } else {
                return Promise.resolve(aesDecrypt(value.skey, value.rand))
            }
        })
    } else {
        return Promise.resolve(aesDecrypt(value.skey, value.rand))
    }
}

function aesDecrypt(skey, rand) {
    const cipher = crypto.createDecipheriv('aes-128-ecb', rand, '')
    let res = cipher.update(skey, 'base64', 'utf8')
    res += cipher.final('utf8')
    return res
}

function RefreshValueTask() {
    return Promise.resolve().then(() => {
        let promiseArr = []
        for (let key in LOCAL_CACHE) {
            let arr = key.split(':')
            promiseArr.push(getNameStore(arr[0], arr[1], false))
        }
        return Promise.all(promiseArr)
    }).then(res => {
        if (res && res.length) {
            for (let data of res) {
                if (data && data.appKey && data.name) {
                    LOCAL_CACHE[data.appKey + ':' + data.name] = data
                }
            }
        }

        let promiseArr = []
        for (let key in LOCAL_CACHE_PAY) {
            let arr = key.split(':')
            promiseArr.push(getNameStore(arr[0], arr[1], false))
        }
        return Promise.all(promiseArr)
    }).then(res => {
        if (res && res.length) {
            for (let data of res) {
                if (data && data.appKey && data.name) {
                    LOCAL_CACHE_PAY[data.appKey + ':' + data.name] = data
                }
            }
        }
    })
}

//  启动时预读取kms port，避免第一次读取时阻塞
getPort()

module.exports = {
    getKeyByName
}
