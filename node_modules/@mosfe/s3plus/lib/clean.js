const { debuglog } = require('util');

const path = require('path');
const proto = exports;

const debug = debuglog('cdnplus');

/**
 * 清理bucket 中的资源
 */
proto.cleanStatic = async function () {
    const { mss } = this;

    const { code, data } = await mss.getBuffer(this.uselessFileName);

    if (code !== 200) {
        console.log(`file ${this.uselessFileName}  do not exist`);
        return false;
    }

    const result = JSON.parse(data.content);
    const deleteList = [];

    for (let key in result) {
        deleteList.push(result[key]);
    }

    const useData = await mss.getBuffer(this.useFileName);
    const res = deleteList.map(async (file) => {
        // 加逻辑 确认下资源是否无用了
        // const objectKey = await this.objectKeyIsExits(file.key);
        const { code, data } = useData;

        if (code === 200) {
            const content = JSON.parse(data.content);
            if (content[file.key]) {
                return {
                    success: true,
                    file: ''
                }
            }
        }

        const result = await mss.deleteObject(file.key);
        if (result.code === 200) {
            console.log(`> file ${file.key} delete success`);
        } else {
            console.log(`> file ${file.key} delete failure`);
        }
        return {
            success: result.code === 200,
            file: file.key
        };
    });

    // 删除资源后更新废弃资源列表
    await this.collectAbandonedResources();

    return Promise.all(res).then((ret) => {
        debug('source clear done');
        const success = ret.every((item) => {
            return item.success;
        });
        const files = ret.filter((item) => {
            return !item.success;
        }).map((item => {
            return item.file;
        }));

        return {
            success,
            files
        };
    });
}

/**
 * 生成废弃资源收集记录
 * 删除资源以useless_resources_{bucket md5}.json文件为准，必须保证准确性
 */
proto.collectAbandonedResources = async function () {
    // 读取 useless_resources_{bucket md5}.json
    // 判断资源是否存在，存在则在列表中删除   暂定
    // 计算本次发布产生的废弃资源
    // 合并进 json
    const { mss } = this;
    const useLessFile = {};
    const result = await this.getNeedCleanFile();
    result.forEach((file) => {
        if (this.ignoreFile.indexOf(file.key) === -1) {
            useLessFile[file.key] = file;
        }
    });
    // console.log(useLessFile);
    // 获取累计保存的待删除资源
    // 当前废弃资源应该是总废弃资源的一个子集
    const { code, data } = await mss.getBuffer(this.uselessFileName);

    if (code === 200) {
        try {
            const content = JSON.parse(data.content);
            Object.assign(useLessFile, content);
            debug('useless file object %j', useLessFile);
        } catch (e) {
            throw new Error(e);
        }
    }

    // 清理一波资源
    const s3ObjectList = await this.listObject();

    for(let key in useLessFile) {
        const fileStatus = s3ObjectList.some((file) => {
            return key === file.key;
        });

        // 清理不存在资源
        if (!fileStatus) {
            delete useLessFile[key];
            console.log(`> delete key ${key}`);
        }

        // 清理未废弃资源
        try {
            const { code, data } = await mss.getBuffer(this.useFileName);
            if (code !== 200) {
                return false;
            }
            const content = JSON.parse(data.content);
            if (content[key]) {
                delete useLessFile[key];
                console.log(`> delete key ${key}`);
            }
        } catch (e) {
            throw new Error(e);
        }
    }

    

    // 存档
    return await this.objectToStringPut(useLessFile, this.uselessFileName);
}

/**
 * 生成线上资源收集记录
 * @param {*} files 
 */
proto.collectResources = async function (files) {
    const useFile = {};
    files.forEach((file) => {
        if (this.ignoreFile.indexOf(file.key) === -1) {
            useFile[file.key] = file;
        }
    });

    return await this.objectToStringPut(useFile, this.useFileName);
}

/**
 * 部署失败时记录已上传资源
 * @param {*} files 
 */
proto.collectSuccessResources = async function (files) {
    const successFile = {};
    files.forEach((file) => {
        if (this.ignoreFile.indexOf(file.key) === -1) {
            successFile[file.key] = file;
        }
    });

    return await this.objectToStringPut(successFile, this.deployFailSuccessFileName);
}

proto.cleanDeployFailSuccessResources = async function () {
    const { mss } = this;

    const { code, data } = await mss.getBuffer(this.deployFailSuccessFileName);

    if (code !== 200) {
        console.log(`file ${this.deployFailSuccessFileName}  do not exist`);
        return false;
    }

    const result = JSON.parse(data.content);
    const deleteList = [];

    for (let key in result) {
        deleteList.push(result[key]);
    }

    const useFileData = await mss.getBuffer(this.deployFailSuccessFileName);

    const res = deleteList.map(async (file) => {
        // 加逻辑 确认下资源是否无用了
        const { code, data } = useFileData;

        if (code === 200) {
            const content = JSON.parse(data.content);
            if (content[file.key]) {
                return {
                    success: true,
                    file: ''
                }
            }
        }

        const result = await mss.deleteObject(file.key);
        if (result.code === 200) {
            console.log(`> file ${file.key} delete success`);
        } else {
            console.log(`> file ${file.key} delete failure`);
        }
        return {
            success: result.code === 200,
            file: file.key
        };
    });

    return Promise.all(res).then(async (ret) => {
        debug('source clear done');
        await this.collectSuccessResources([]);
        const success = ret.every((item) => {
            return item.success;
        });
        const files = ret.filter((item) => {
            return !item.success;
        }).map((item => {
            return item.file;
        }));

        return {
            success,
            files
        };
    });
}



/**
 * 将存储对象转化为字符串并上传存档
 * @param {*} fileObject 需要存储的字符串
 * @param {*} fileName 上传文件objectKey
 */
proto.objectToStringPut = async function (fileObject, fileName) {
    const { mss } = this;
    const fileBuffer = new Buffer(JSON.stringify(fileObject));
    const putFile = await mss.putObject(fileName, fileBuffer, {
        headers: {
            'Content-Type': 'application/json'
        }
    });
    if (putFile.code === 200) {
        // 上传成功
        console.log(`> ${fileName} upload success`);
    }
    // 处理异常情况 失败了 怎么搞
    return putFile.code === 200;
}