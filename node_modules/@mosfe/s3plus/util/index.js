const fs = require('fs');
const path = require('path');
const cryptoLib = require('crypto');
const moment = require('moment');
/**
 *  获取目标资源文件
 * @param {*} root 
 */
exports.getFile = async function (root) {
    // this.cache = this.cache || {};
    // if (this.cache.files) {
    //     return this.cache.files;
    // }
    const files = [];
    // this.cache.files = files;
    const travel = (root, rootBase) => {
        fs.readdirSync(root).forEach(async (file) => {
            const pathname = path.join(root, file);
    
            if (fs.statSync(pathname).isDirectory()) {
                travel(pathname, rootBase);
            } else {
                const fileBuffer = fs.readFileSync(pathname);
                const etag= this.md5(fileBuffer, 'hex');
                const filePath = pathname.replace(`${rootBase}/`, '');
                files.push({
                    keyLocal: filePath,
                    key: this.buildPath(filePath),
                    etag: `"${etag}"`
                });
            }
        });
    }
    travel(root, root);
    return files;
};

/**
 * 判断bucket是否存在
 * @param {*} bucket 
 */
exports.bucketIsExits = async function (bucket) {
    const { mss } = this;
    const { code } = await mss.getBucket(bucket);
    return code === 200;
};

/**
 * 判断一个本地文件是否存在bucket 中
 * @param {*} pathname 文件名 key
 * @param {*} rootBase 资源目录
 */
exports.fileIsExits = async function (pathname, rootBase) {
    const fileBuffer = fs.readFileSync(path.join(rootBase, pathname));
    const etag= await this.md5(fileBuffer, 'hex');
    const filePath = pathname.replace(`${rootBase}/`, '');
    const files = [
        {
            key: filePath,
            etag: `"${etag}"`
        }
    ];
    const s3ObjectList = await this.listObject();
    const result = await this.fileDifference(files, s3ObjectList);
    console.log('-=', result);
    return result.length === 0;
}

/**
 * 判断bucket 中是否存在该资源，之判断名字，etag 不做对比
 * @param {*} key objectKey
 */
exports.objectKeyIsExits = async function (key) {
    const { mss } = this;
    const { code } = await mss.getBuffer(key);
    return code === 200;
}

/**
 * 获取当前bucket下的object key
 */
exports.listObject = async function (opts) {
    let startKey = '';
    opts = opts || {};

    const { mss } = this;

    const whileObjectFn = async function () {
        const list = [];

        async function whileList () {
            opts.query = opts.query || {};
            Object.assign(opts.query, {
                Marker: startKey,
                prefix: this.customPath
            });
            const res = await mss.listObject(opts);
            const { code, data, error } = res;
            if (code !== 200) {
                throw new Error(error.Message);
            }
            list.push(res);
            const { Contents } = data;

            const len = Contents.length;
            if (len !== 0) {
                startKey = Contents[len - 1].Key;
                await whileList();
            }
        }
        await whileList();
        return list;
    };
    const whileObject = await whileObjectFn();
    return Promise.all(whileObject).then((res) => {
        return res.reduce((list, objList) => {
            const { code, data } = objList;
            const { Contents } = data;
            return list.concat(Contents);
        }, []).map((key) => {
            return {
                key: key.Key,
                etag: key.ETag,
                lastModified: moment(key.LastModified).format('YYYY-MM-DD HH:mm:ss')
            }
        }).filter((item) => {
            return item.key.indexOf(this.customPath) > -1;
        });
    });
}

/**
 * 删除objectKey
 * @param {Array} list 
 */
exports.deleteObject = async function (list) {
    const { mss } = this;
    const result = list.map(async (file) => {
        const { code } = await mss.deleteObject(file.key);
        return {
            success: code === 200,
            key: file.key
        };
    });
    return Promise.all(result).then((res) => {
        const errorFile = res.filter((file) => {
            return !file.success;
        });
        return {
            success: errorFile.length === 0,
            files: errorFile
        }
    });
}

/**
 * 获取bucket cors
 * @param {*} bucket 
 */
exports.getBucketCors = async function (bucket) {
    const { mss } = this;
    const { code, data } = await mss.getBucketCors(bucket);
    if (code === 200) {
        const { CORSRule } = data;
        return CORSRule;
    }
    return [];
}

/**
 * 设置bucket cors
 * @param {*} bucket 
 * @param {*} CORSConfiguration 
 */
exports.putBucketCors = async function (bucket, CORSConfiguration) {
    const { mss } = this;
    const { code } = await mss.putBucketCors(bucket, {
        CORSConfiguration
    });
    return code === 200;
}

/**
 * 删除bucket cors
 * @param {*} bucket 
 */
exports.deleteBucketCors = async function (bucket) {
    const { mss } = this;
    const { code } = await mss.deleteBucketCors(bucket);
    return code === 200;
}

/**
 * 对比待发布资源于s3 bucket 上的已发布资源差异
 * @param {*} files 
 */
exports.getIncrementFile = async function (files, opts) {
    opts = opts || {};
    files = files || await this.getFile(this.deployCatalog);
    const s3ObjectList = await this.listObject();
    const result = await this.fileDifference(files, s3ObjectList, opts);
    return result;
}

/**
 * 检查资源部署情况
 */
exports.checkDeploy = async function (opts) {
    opts = opts || {};
    let files = await this.getFile(this.deployCatalog);
    const s3ObjectList = await this.listObject();
    const result = await this.fileDifference(files, s3ObjectList, opts);
    return result.length === 0;
}

/**
 * 获取bucket 中不存在的本地待发布资源
 */
exports.getFailFile = async function () {
    let files = await this.getFile(this.deployCatalog);
    const s3ObjectList = await this.listObject();
    const result = await this.fileDifference(files, s3ObjectList)
    return result;
}

/**
 * 根据本地和bucket 中资源对比，对比出bucket 中需要删除的资源key list
 */
exports.getNeedCleanFile = async function () {
    let files = await this.getFile(this.deployCatalog);
    const s3ObjectList = await this.listObject();
    const result = await this.fileDifference(s3ObjectList, files);
    return result;
}

/**
 * a - a ∩ b
 * @param {*} a 
 * @param {*} b 
 * @param {*} opts 
 */
exports.fileDifference = async function (a, b, opts) {
    opts = opts || {};
    const differenceKey = [];
    a.forEach((aItem) => {
        let aItemStatus = false;
        if (this.increment) {
            aItemStatus = b.some((bItem) => {
                const keyStatus = aItem.key === bItem.key;
                return keyStatus && (aItem.etag === bItem.etag);
            });
        } else {
            aItemStatus = b.some((bItem) => {
                const keyStatus = aItem.key === bItem.key;
                return keyStatus;
            });
        }

        !aItemStatus && differenceKey.push(aItem);
    });
    return differenceKey;
}

/**
 * 生成md5
 * @param {*} data 
 * @param {*} digest 
 */
exports.md5 = function (data, digest) {
    if (!digest) {
        digest = 'binary';
    }
    if (digest === 'buffer') {
        digest = undefined;
    }
    if (typeof data === 'string') {
        data = new Buffer(data);
    }
    return cryptoLib.createHash('md5').update(data).digest(digest);
}

const deployHotCDN = require('./deployHotCDN');
exports.deployHotCDN = async function (opts) {
    const { MSS_APP_KEY, MSS_APP_SECRET, fuceCDN, CDNHost, tenantId, action = 'prefetch' } = opts || {};
    const result = await this.getFile(this.deployCatalog);
    const files = result.map((file) => {
        return `v1/mss_${tenantId}/${this.mss.options.bucket}/${file.key}`;
    });
    // 私有云 key secret
    const hotCDNOptions = {
        fuceCDN,
        mssKey: MSS_APP_KEY,
        mssSecret: MSS_APP_SECRET,
        files,
        CDNHost,
        action
    }
    const hotCDN = await deployHotCDN(hotCDNOptions);
    return hotCDN;
}