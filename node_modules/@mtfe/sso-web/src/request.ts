/**
 * Created by leon on 6/14/18.
 */
import locale from './locale/en_GB';

const { SYS_ERROR } = locale;
interface SSOError {
    code: number;
    data: {
        msg: string;
    }
}
function advancedFetch(originalFetch: Promise<any>, timeout?: number): Promise<any> {
    let abortFunc: Function;

    let abortPromise = new Promise((res, rej) => {
        abortFunc = () => {
            rej('timeout, and abort promise');
        }
    });

    let highOrderFetch = Promise.race([
        originalFetch,
        abortPromise,
    ]);

    setTimeout(() => {
        abortFunc();
    }, timeout || 10 * 1000);

    return highOrderFetch;
}

const resStatusMW = (res: any) => {
    let { reject } = Promise;
    reject = reject.bind(Promise);

    return res.status === 200 ? res.json() : reject({ code: res.status });
};

const resCatchError = (err: Error) => {
    // @ts-ignore
    const ssoError = err as SSOError;
    if (ssoError.data && ssoError.data.msg) {
        return { msg: ssoError.data.msg };
    }

    // 处理未知错误
    if (err.stack || typeof err === 'string') {
        console.error(err.stack || err);
    }

    return { msg: SYS_ERROR };
};

export function fetchRequest(url: string, opts: any) {
    const options = {
        method: 'POST',
    };
    let { resolve, reject } = Promise;
    resolve = resolve.bind(Promise);
    reject = reject.bind(Promise);

    const fetchOptions = Object.assign({}, options, opts);

    return advancedFetch(fetch(url, fetchOptions))
        .then(resStatusMW)
        .then((res: any) => {
            if (res.code === 200) {
                return resolve(res.data);
            }

            return reject(res);
        })
        .catch(resCatchError);
}
