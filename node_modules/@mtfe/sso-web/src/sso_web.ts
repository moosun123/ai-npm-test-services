/**
 * @Desc
 * @Author leon <leondwong@gmail.com>
 * @Date 6/13/18
 */
import 'whatwg-fetch';

import { SSO_SPECIAL_ROUTE, HARD_CODE_METHOD } from './config/const';
import { ConfigClient, ConfigClientModel } from './config_client';
import {
  Logger,
  urlObj,
  whiteListAndBlackListCheck,
  hasSchema,
  LoggerModel,
} from './util/common_util';
import locale from './locale/en_GB';
import { RestClientModel, RestClient } from './rest_client';
import { Storage } from './storage';
import { generateState } from './util/store_util';
import { cryptoGenerateRandom, sha256Crypto } from './util/crypto_util';
import { SSOWebConfig } from './types';

const {
  SHOULD_NO_SCHEMA_IN_ORIGINAL_URL,
  ORIGINAL_URL_LOST,
  PROTOCOL_UNDEFINED,
  STATE_ERROR,
} = locale;

// 对外暴露的接口
interface SSOWebModel {
  init(): Promise<void>;
  login(): Promise<string | { type: string, message: string }>;
  logout(token?: string): Promise<void>;
  getLoginUrl(redirectUrl?: URL): string;
  createRedirectUrl(originalUrl: string): URL;
}

class SSOWeb implements SSOWebModel {
  clientId: string;
  accessEnv: string;
  isInitial: boolean;
  SSO_URL: {
    SSO_API_URL: string;
    SSO_LOGIN_URL: string;
  };
  logoutUrl: string;
  callbackUrl: string;
  loginUrl: string;
  rewriteLocation?: string;
  schema: string;
  sameSite: boolean; //cookie是否限制第三方站点传输，默认是true
  isDebug: boolean; //是否开启debug模式，对关键步骤进行输出log日志
  excludedUriList: string[];
  includedUriList: string[];

  configClient: ConfigClientModel;
  logger: LoggerModel;
  client: RestClientModel;
  store: Storage;

  constructor(configs: SSOWebConfig) {
    const { clientId, accessEnv } = configs;

    this.clientId = clientId;
    this.accessEnv = accessEnv;

    this.configClient = new ConfigClient(configs);

    this.isInitial = false;
  }

  async init() {
    await this.configClient.init();

    await this.initConfig(this.configClient.getConfig());

    // defined logger at very beginning, for tracking all log
    this.logger = new Logger('SSOClient');
  }

  private async initConfig({
    clientId,
    logoutUri,
    loginUrl,
    rewriteLocation,
    schema,
    sameSite,
    isDebug,
    excludedUriList,
    includedUriList,
    openApiHost,
    ssoSvHost,
    callbackUrl, // special in web SSO SDK
  }) {
    this.logoutUrl = logoutUri || SSO_SPECIAL_ROUTE.logoutUrl;
    this.callbackUrl = callbackUrl || SSO_SPECIAL_ROUTE.callbackUrl;
    this.loginUrl = loginUrl;
    this.SSO_URL = {
      SSO_API_URL: openApiHost,
      SSO_LOGIN_URL: ssoSvHost,
    };
    this.isInitial = true;
    // correct path: /path/ , /path , path/ , path => /path
    this.rewriteLocation = rewriteLocation ? '/' + rewriteLocation.replace(/^\/+/, '').replace(/\/+$/, '') : ''; // avoid null
    this.schema = schema && schema.slice(-1) !== ':' ? `${schema}:` : schema;
    this.sameSite = sameSite !== false;
    this.isDebug = isDebug === true; //默认为false
    this.excludedUriList =
      excludedUriList && excludedUriList.length > 0
        ? excludedUriList.split(',')
        : excludedUriList;
    this.includedUriList =
      includedUriList && includedUriList.length > 0
        ? includedUriList.split(',')
        : includedUriList;

    this.client = new RestClient({
      apiUrlLogin: this.SSO_URL.SSO_LOGIN_URL,
      apiUrlOpen: this.SSO_URL.SSO_API_URL,
    });
    this.store = new Storage({
      clientId,
      method: HARD_CODE_METHOD,
    });
  }

  async login() {
    if (!this.isInitial) await this.init();

    let {
      logoutUrl,
      callbackUrl,
      rewriteLocation,
      includedUriList,
      excludedUriList,
    } = this;
    let { stateStore, verifier, tokenStore } = this.store;
    // IMPORTANT!!!,看getSearchString方法内的注释
    let code = urlObj.getSearchString('code');
    let originalUrl = urlObj.getSearchString('original-url');
    let token = tokenStore.getToken();
    let href = location.href;
    let origin = location.origin;
    let reqPath = code?decodeURIComponent(
      urlObj.getReqPath(href, origin, rewriteLocation),
    ):urlObj.getReqPath(href, origin, rewriteLocation); // decode for hash router in callback url
    if(this.isDebug){
      console.log("================== ssoweb debug =================")
      console.log("logoutUrl: ",this.logoutUrl)
      console.log("callbackUrl: ",this.callbackUrl)
      console.log("href: ",decodeURIComponent(href))
      console.log("origin: ",origin)
      console.log("rewriteLocation: ",rewriteLocation)
      console.log("reqPath: ",reqPath)
      console.log("originalUrl: ",originalUrl)
      console.log("code: ",code)
      console.log("token: ",token)
      console.log("=================================================")
    }
    const {
      callbackUrl: defaultCallbackUrl,
      logoutUrl: defaultLogoutUrl,
      robotUrl: defaultRobotUrl,
    } = SSO_SPECIAL_ROUTE;

    const defaultCheckPath = [
      defaultCallbackUrl,
      defaultLogoutUrl,
      defaultRobotUrl,
      logoutUrl,
      callbackUrl,
    ];

    if (
      !defaultCheckPath.includes(reqPath) &&
      whiteListAndBlackListCheck(reqPath, excludedUriList, includedUriList)
    ) {
      return { type: 'info', message: 'no need to check' };
    }

    if (code && this.isCallbackPath(reqPath)) {
      let state = urlObj.getSearchString('state');
      let webNewUuid = urlObj.getSearchString('webNewUuid');
      let stateInBrowser = stateStore.getState();

      if (hasSchema(originalUrl)) {
        this.logger.error('error', new Error(SHOULD_NO_SCHEMA_IN_ORIGINAL_URL));

        return { type: 'error', message: SHOULD_NO_SCHEMA_IN_ORIGINAL_URL };
      }

      if (!state || state !== stateInBrowser) {
        this.logger.error('error', new Error(STATE_ERROR));

        return { type: 'error', message: STATE_ERROR };
      }

      const codeVerifier = verifier.getCodeVerifier();

      const result = await this.getToken(code, codeVerifier);

      if (typeof result === 'string') {
        this.logger.error(result);

        return { type: 'error', message: result };
      }

      let { accessToken } = result;

      if (!originalUrl) {
        this.logger.error('error', new Error(ORIGINAL_URL_LOST));

        originalUrl = `${rewriteLocation}/`;
      }

      tokenStore.setToken(accessToken, this.sameSite);

      if(webNewUuid) {
        tokenStore.setCookieStr('webNewUuid', webNewUuid);
      }

      token = accessToken;

      // 解决firefox可能不跳转的bug
      setTimeout(() => {
        location.href = originalUrl;
      }, 1);
    } else if (this.isLogoutPath(reqPath) || !token) {
      let redirectUrlObj: URL = this.createRedirectUrl(
        `${rewriteLocation}${reqPath}`,
      );

      if (this.isLogoutPath(reqPath)) {
        await this.logout(token);
        redirectUrlObj = this.createRedirectUrl(`${rewriteLocation}/`);
      }

      const loginUrl = this.getLoginUrl(redirectUrlObj);
      // 解决firefox可能不跳转的bug
      setTimeout(() => {
        location.href = loginUrl;
      }, 1);
      return { type: 'info', message: `redirect to ${loginUrl}` };
    }

    return token;
  }

  async logout(token?: string) {
    if (!this.isInitial) throw Error('should init first');
    if (!token) {
      token = this.store.tokenStore.getToken();
    }
    const { clientId } = this;
    const { tokenStore } = this.store;
    await this.client.logout(token, clientId);
    tokenStore.clearToken();
  }

  /**
   * 获得登录页地址
   * @param redirectUrlObj 
   * @see [getLoginUrl](https://docs.sankuai.com/mt/it/web-sso-sdk/docs/apis/#getloginurlredirecturl-url)
   */
  getLoginUrl(redirectUrlObj?: URL) {
    if (!this.isInitial) throw Error('should init first');

    const { rewriteLocation } = this;
    if (!redirectUrlObj) {
      let reqPath = urlObj.getReqPath(location.href, location.origin, rewriteLocation);
      redirectUrlObj = this.createRedirectUrl(`${rewriteLocation}${reqPath}`);
    }
    const loginUrlObj = new URL(this.loginUrl, location.origin);
    const { verifier, stateStore } = this.store;
    const state = generateState();
    const codeVerifier = cryptoGenerateRandom();
    stateStore.clearState();
    stateStore.setState(state);

    verifier.clearCodeVerifier();
    verifier.setCodeVerifier(codeVerifier);
    const codeChallengeMethod = verifier.getCodeChallengeMethod();
    const codeChallenge = verifier.isSha256()
      ? sha256Crypto(codeVerifier)
      : codeVerifier;

    // // 解决pathname中`#`自动被编码问题
    const redirectUrl = `${redirectUrlObj.origin}${decodeURIComponent(redirectUrlObj.pathname)}${redirectUrlObj.search}`

    loginUrlObj.search = `client_id=${
      this.clientId
      }&redirect_uri=${encodeURIComponent(
        redirectUrl
      )}&state=${state}&code_challenge=${encodeURIComponent(
        codeChallenge,
      )}&code_challenge_method=${codeChallengeMethod}`;

      if(this.isDebug){
        console.log("================== ssoweb debug =================")
        console.log("redirect_uri origin: ",redirectUrlObj.origin)
        console.log("redirect_uri pathname: ",redirectUrlObj.pathname)
        console.log("redirect_uri search: ",decodeURIComponent(redirectUrlObj.search));
        console.log("redirect_uri: ",decodeURIComponent(redirectUrl));
        console.log("=================================================")
      }
    return loginUrlObj.href;
  }
  /**
   * 获得redirectUrl的URL对象
   * @description 
   *   redirectUrl的地址是 `域名{{callbackUrl}?original-url={{originalUrl}}`
   * @param originalUrl 只能是相对路径
   * @see [createRedirectUrl](https://docs.sankuai.com/mt/it/web-sso-sdk/docs/apis/#createredirecturloriginalurlstring)
   * @example
   * 
   * ``` js
   * location.href = ssoWeb.getLoginUrl(ssoWeb.createRedirectUrl('/abc'))
   * // 当从sso登录页跳转回来,最终停留在  '{你的域名}/abc'
   * ```
   * 
   */
  createRedirectUrl(originalUrl: string) {
    const redirectUrlObj = new URL(location.origin);
    const { callbackUrl: defaultCallbackUrl } = SSO_SPECIAL_ROUTE;
    const { schema, rewriteLocation, callbackUrl } = this;

    if (schema) redirectUrlObj.protocol = schema;

    if (!redirectUrlObj.protocol) {
      console.warn(PROTOCOL_UNDEFINED);

      // set default protocol
      redirectUrlObj.protocol = 'http:';
    }

    redirectUrlObj.pathname = `${rewriteLocation}${callbackUrl ||
      defaultCallbackUrl}`;
    redirectUrlObj.search = `original-url=${encodeURIComponent(originalUrl)}`;

    return redirectUrlObj;
  }

  private isLogoutPath(reqPath: string): boolean {
    const { logoutUrl } = this;
    const { logoutUrl: defaultLogoutUrl } = SSO_SPECIAL_ROUTE;

    return (
      reqPath.startsWith(logoutUrl) || reqPath.startsWith(defaultLogoutUrl)
    );
  }

  private isCallbackPath(reqPath: string): boolean {
    const { callbackUrl } = this;
    const { callbackUrl: defaultCallbackUrl } = SSO_SPECIAL_ROUTE;

    return (
      reqPath.startsWith(callbackUrl) || reqPath.startsWith(defaultCallbackUrl)
    );
  }

  private getToken(code, verifier) {
    const { clientId } = this;
    return this.client.getToken(code, verifier, clientId);
  }
}

let ssoInstance: SSOWeb;

// add singleton mode for web SDK to avoid too many instance in use

/**
 * 构造SSOWeb对象
 * @param configs SDK配置
 * @see [配置项文档](https://docs.sankuai.com/mt/it/web-sso-sdk/docs/configuration/)
 */
export default function singletonWrapper(configs: SSOWebConfig): SSOWeb {
  // @ts-ignore
  if(configs.accessEnv==='ppe') {
    console.error('sso beta环境即将下线，请切换至test环境，详情参考 https://km.sankuai.com/page/173996827')
  }
  if (!ssoInstance) {
    ssoInstance = new SSOWeb(configs);
  }

  return ssoInstance;
}

/**
 * 仅用于单元测试
 */
// tslint:disable-next-line
export const _dispose = () => {
  // tslint:disable-next-line
  ssoInstance = null;
};
