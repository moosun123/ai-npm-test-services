/**
 * @Desc
 * @Author leon <leondwong@gmail.com>
 * @Date 8/2/18
 */
import minimatch from 'minimatch';

export interface LoggerModel {
    log(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
}

export class Logger implements LoggerModel {
    private moduleName: string;

    constructor(name: string) {
        this.moduleName = name;
    }

    log(...args) {
        console.log(`[LOG] ${this.moduleName} - `, ...args);
    }

    warn(...args) {
        console.warn(`[WARN] ${this.moduleName} - `, ...args);
    }

    error(...args) {
        console.error(`[ERROR] ${this.moduleName} - `, ...args);
    }
}

export interface UrlModel {
    getSearchString(name: string): string;
    getReqPath(href: string, original: string, prefix?: string): string;
}

class Url implements UrlModel {
    getSearchString(name) {
        let reg = new RegExp(`(\/?|&)${name}=([^&]*)(&|$)`, 'i');
        let url = location.href.split(location.host).splice(1).join(location.host);
        let result = url.match(reg);
        if (result != null) {
            /*  IMPORTANT!!  
                sso异地部署版本后,code格式修改,其内容会有百分号
                web sdk获取到code后在这里decodeURIComponent,导致换取token时用的code参数被修改,后端异常
                与后端协商后,后端对pcke换token接口特别处理,而前端这里要保留decodeURICompoent操作
            */
            return decodeURIComponent(result[2])
        }

        return null
    }
    getReqPath(href, origin, prefix = '') {
        return href.replace(origin, '').replace(prefix, '');
    }
}

export let urlObj: UrlModel = new Url();


// support java ant style matcher by minimatch
export const whiteListAndBlackListCheck = (url: string, whiteLists: string[] = [], includeUrlList: string[] = []): boolean => {
    // if (typeof whiteLists === 'function') return whiteLists(url);
    if (includeUrlList && includeUrlList.length > 0) return !includeUrlList.some(il => minimatch(url, il));

    // avoid null
    if (!whiteLists) whiteLists = [];

    return whiteLists.some(wl => minimatch(url, wl));
};

/**
 * check original url for not allow schema
 *
 * @param {string} url - original url
 * */
export const hasSchema = (url: string): boolean => {
    const schemaReg = /^(http|https|ftp):/;
    const noSchemaReg = /^(\/|\\)(\/|\\)/;

    return schemaReg.test(url) || noSchemaReg.test(url);
};


/**
 * 获取浏览器的版本--仅大版本
 * Chrome
 */
export const getBrowserVersion = (browser) => {
    const userAgent = navigator.userAgent.toLowerCase();
    const returnObj = {};
  
    if (userAgent.indexOf("chrome") > -1 && userAgent.indexOf("safari") > -1) {
      returnObj['chrome'] = parseInt(userAgent.match(/chrome\/([\d.]+)/)[1], 10);
    }
    return browser ? returnObj[browser] : returnObj;
  };