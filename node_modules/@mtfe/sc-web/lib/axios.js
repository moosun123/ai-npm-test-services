import axios from "axios";
import { DEFAULT_SC_ACCESS_CONFIG, PROXY_PATH, LOGIN_COUNTER } from "./config/const";
import { loginIframe } from "./util/iframe_util";
import { localHostTips } from "./util/local_tips";
let requestEvents = [];
let isLogining = false;
let loginCounter = LOGIN_COUNTER;
let loginTimestamp = +new Date();
let isShowLoginConfirm = false;
let accessToken = '';
const testClient = '7c4be9d597';
const prodClient = 'c0cd718bba';
const isLocal = (window.location.host.includes('localhost') ||
    window.location.host.includes('127.0.0.1'));
function clearLoginStatus() {
    isLogining = false;
    isShowLoginConfirm = false;
}
export function axiosSet(configs) {
    const netEnv = (configs.accessEnv === "production" && configs.netEnv === "out") ?
        ((window.location.host.includes('meituan.com') && !(configs.version > 0)) ? "_out_mt" : "_out_sk") : "";
    const ssoidName = configs.netEnv === 'test'
        ? `sc_${testClient}_ssoid`
        : `sc_${prodClient}_ssoid`;
    const _loginUrl = `loginUrl${netEnv}`;
    const _loginOrigin = `loginOrigin${netEnv}`;
    const _apiHost = `apiHost${netEnv}`;
    const accessConfig = DEFAULT_SC_ACCESS_CONFIG[configs.accessEnv];
    const loginUrl = `${accessConfig[_loginUrl]}?origin=${window.location.origin}`;
    let fetch;
    configs.loginImmediately && loginIframe(loginUrl, netEnv, loginTimestamp, configs).send().then((event) => {
        accessToken = event.data.token;
        localStorage.setItem(`${ssoidName}`, event.data.token);
    });
    fetch = axios.create({
        baseURL: `${accessConfig.http[_apiHost]}/${PROXY_PATH}`,
        timeout: 60000,
        headers: {
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "X-Sc-Component-Id": configs.componentId,
            "X-Sc-Access-Env": configs.accessEnv,
        },
        responseType: configs.responseType || "json"
    });
    fetch.interceptors.request.use((config) => {
        if (config.method === "post" ||
            config.method === "put" ||
            config.method === "delete") {
            if (config.data instanceof FormData) {
                config.headers["Content-Type"] = "application/x-www-form-urlencoded";
            }
            else {
            }
        }
        config.headers["access-token"] = localStorage.getItem(`${ssoidName}`) || `${accessToken}`;
        return config;
    });
    fetch.interceptors.response.use((res) => {
        const data = res.data;
        const config = res.config || {};
        if (!data) {
            console.error(`error: 接口异常，返回体data为空`);
            return Promise.reject(data);
        }
        if (data.action === 'callReloginBySC' || data.status == 401) {
            localStorage.removeItem(`${ssoidName}`);
            if (!isLogining) {
                if (--loginCounter < 0) {
                    return Promise.reject(data);
                }
                isLogining = true;
                setTimeout(() => { clearLoginStatus(); }, 1000);
                if ((configs.accessEnv === 'test') && isLocal && !accessToken && !isShowLoginConfirm) {
                    isShowLoginConfirm = true;
                    return localHostTips({
                        loginUrl: accessConfig[_loginUrl],
                        loginOrigin: accessConfig[_loginOrigin]
                    }).then((event) => {
                        accessToken = event.data.token;
                        localStorage.setItem(`${ssoidName}`, event.data.token);
                        requestEvents.forEach((fn) => {
                            fn(config);
                        });
                        requestEvents = [];
                        return fetch(config);
                    });
                }
                loginTimestamp = +new Date();
                return loginIframe(loginUrl, netEnv, loginTimestamp, configs).send().then((event) => {
                    accessToken = event.data.token;
                    localStorage.setItem(`${ssoidName}`, event.data.token);
                    requestEvents.forEach((fn) => {
                        fn(config);
                    });
                    requestEvents = [];
                    clearLoginStatus();
                    return fetch(config);
                }, () => {
                    return Promise.reject(data);
                });
            }
            else {
                return new Promise((resolve) => {
                    requestEvents.push(() => {
                        resolve(fetch(config));
                    });
                });
            }
        }
        loginCounter = LOGIN_COUNTER;
        return res;
    }, (error) => {
        console.error("请求出错了: ", error.message);
        return Promise.reject(error);
    });
    return fetch;
}
//# sourceMappingURL=axios.js.map