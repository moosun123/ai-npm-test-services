import VueRouter, { NavigationGuardNext, Route } from 'vue-router'
import { getProjectId } from '../api/space'
import { APP_TYPE } from '../auth/constants'
import { getProjectIdFromCache, setProjectIdToCache } from './cache'

const PERSONAL_PROJECT_ID = 0

/** 当前是否是邮报或者portal系统 */
function isMailOrPortal() {
  return window.location.pathname.indexOf('/mail') === 0 || window.location.pathname.indexOf('/portal') === 0
}

export interface AuthRouteMeta {
  resourceConfig?: ResourceConfigInMeta
  authConfig?: AuthConfigInMeta
}

export interface ResourceConfigInMeta {
  /** 路由params参数中哪个字段代表资源Id */
  resourceIdKey?: string
  /** 与resourceIdKey2选1，用于从路由中获取resourceId */
  resourceId?: (route: Route) => string
  resourceType: APP_TYPE
}

export interface AuthConfigInMeta {
  /** 是否需要记录当前页所处工作空间，下一次进入本路由时，不管url中工作空间是多少，均恢复缓存工作空间参数，一个缓存生效一次 */
  isRecorvery?: boolean
  /** 是否忽略url中工作空间参数，而是根据资源获取后端实际工作空间（需要路由meta中配置了资源meta） */
  isCheckResource?: boolean
  useLocalStorageWhenCheckResource?: boolean
}

class SpaceManager {
  /** project为0时说明是个人工作空间 */
  private projectInfo = {
    id: PERSONAL_PROJECT_ID,
  }
  private updateProjectPromise: null | Promise<void> = null
  private router: VueRouter | null = null
  private curRoute: Route | null = null
  /**
   * 列表页projectId
   * 这是一个兼容逻辑
   * 由于个人空间可以查看到项目组的资源，当查看或编辑这类资源，再跳转回列表页时需要回到列表页，所以特别记录
   */
  private listPageProjectId?: number

  private async getProjectIdByResource(resourceId: string, appType: APP_TYPE, useLocalStorage?: boolean) {
    const projectIdFromCache = getProjectIdFromCache(resourceId, appType, useLocalStorage)

    if (projectIdFromCache !== null) {
      return projectIdFromCache
    }

    const res = await getProjectId({ id: resourceId, appType: appType })
    const projectIdFromApi = res.data || 0
    setProjectIdToCache(resourceId, appType, projectIdFromApi)

    return projectIdFromApi
  }

  private saveListProjectId(to: Route) {
    const meta = (to.meta || {}) as AuthRouteMeta
    if (meta.authConfig?.isRecorvery) {
      this.listPageProjectId = this.projectInfo.id
    }
  }

  private getListProjectIdForNavigationGuard(to: Route) {
    const meta = (to.meta || {}) as AuthRouteMeta

    if (!meta.authConfig?.isRecorvery) {
      return null
    }

    if (this.listPageProjectId === undefined) {
      return null
    }
    const listPageProjectId = this.listPageProjectId
    this.listPageProjectId = undefined
    return listPageProjectId
  }

  private getProjectIdByResourceForNavigationGuard(to: Route) {
    const meta = (to.meta || {}) as AuthRouteMeta

    if (!meta.resourceConfig) {
      throw new Error(`路由「${to.path}」meta中没有设置resourceConfig`)
    }

    const params = to.params

    const reousceId = meta.resourceConfig.resourceId
      ? meta.resourceConfig.resourceId(to)
      : meta.resourceConfig.resourceIdKey
      ? params[meta.resourceConfig.resourceIdKey]
      : null

    if (!reousceId) {
      return null
    }

    return this.getProjectIdByResource(
      reousceId,
      meta.resourceConfig.resourceType,
      meta.authConfig?.useLocalStorageWhenCheckResource,
    )
  }

  /** 路由拦截器中更新projectId */
  private updateProjectIdForNavigationGuard(newProjectId: number, to: Route, next: NavigationGuardNext<Vue>) {
    this.projectInfo.id = newProjectId
    this.saveListProjectId(to)
    next()
  }

  /** 包装vue-router，每次路由切换时自动处理工作空间相关的参数 */
  wrapRouter(router: VueRouter) {
    router.beforeEach(async (to, from, next) => {
      // 如果路径一致，则不需要处理，因为第一次进入已经处理好工作空间参数，同时加此判断可以避免陷入循环
      if (to.path === from.path) {
        next()
        return
      }

      // 邮报和portal只有个人空间
      if (isMailOrPortal()) {
        this.updateProjectIdForNavigationGuard(PERSONAL_PROJECT_ID, to, next)
        return
      }

      let newProjectId = this.getListProjectIdForNavigationGuard(to)
      if (newProjectId !== null) {
        this.updateProjectIdForNavigationGuard(newProjectId, to, next)
        return
      }

      const meta = (to.meta || {}) as AuthRouteMeta
      if (meta.authConfig?.isCheckResource) {
        newProjectId = await this.getProjectIdByResourceForNavigationGuard(to)

        if (newProjectId !== null) {
          this.updateProjectIdForNavigationGuard(newProjectId, to, next)
          return
        }
      }

      newProjectId = Number(to.query.projectId)
      if (Number.isNaN(newProjectId) || newProjectId < PERSONAL_PROJECT_ID) {
        newProjectId = this.projectInfo.id || PERSONAL_PROJECT_ID
      }
      this.updateProjectIdForNavigationGuard(newProjectId, to, next)
    })
    router.afterEach((to) => {
      this.curRoute = to
    })
    this.router = router
  }

  /** 当前是否处于个人空间 */
  isInPersonalSpace() {
    return this.projectInfo.id === PERSONAL_PROJECT_ID
  }

  /** 有些场景需要从外面设置projectId */
  setProjectId(projectId: number) {
    if (this.projectInfo.id === projectId) {
      return
    }

    this.projectInfo.id = projectId

    if (!this.curRoute) {
      throw new Error('路由query参数替换失败：无法获取当前路由')
    }

    this.saveListProjectId(this.curRoute)

    if (!this.router) {
      return
    }

    if (Number(this.curRoute.query.projectId) === projectId) {
      // 无需替换路由参数
      return
    }

    this.router
      .replace({
        path: this.curRoute.path,
        query: {
          ...this.curRoute.query,
          projectId: `${this.projectInfo.id}`,
        },
      })
      .catch((err) => console.log(err))

    return true
  }

  getProjectId() {
    return this.projectInfo.id
  }

  getProjectInfo() {
    return this.projectInfo
  }

  updateProjectIdByResourceId(resourceId: string, appType: APP_TYPE) {
    const updateProjectPromise = this.getProjectIdByResource(resourceId, appType).then((projectId) => {
      // promise不相等，说明有新的更新在处理，丢弃旧的
      if (this.updateProjectPromise !== updateProjectPromise) {
        return
      }
      this.projectInfo.id = projectId
      this.updateProjectPromise = null
    })

    this.updateProjectPromise = updateProjectPromise
    return updateProjectPromise
  }

  // 如果工作空间参数处于更新中，调用此函数等待工作参数就绪，建议强依赖工作空间参数的场景均先调用此函数
  async awaitReady() {
    if (this.updateProjectPromise) {
      await this.updateProjectPromise
    }
  }

  async getProjectIdAsync() {
    await this.awaitReady()
    return this.projectInfo.id
  }
}

export default new SpaceManager()
