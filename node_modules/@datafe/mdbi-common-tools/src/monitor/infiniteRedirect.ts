import Base from './base'
import { getSessionStorage, setSessionStorage, getLocalStorage, StorageData, setLocalStorage } from '../utils/storage'
import { InfiniteRedirectErrorFlag, infiniteRedirectErrorKey, storageKey } from './constants'

function isInvalidParentUrl(url: string) {
  return url.includes('bi.sankuai.com') || url.includes('ssosv.sankuai.com')
}

function setInfiniteRedirectErrorKey(flag: InfiniteRedirectErrorFlag) {
  setLocalStorage(infiniteRedirectErrorKey, {
    flag,
    timestamp: Date.now(),
  })
}
function getInfiniteRedirectErrorKey() {
  return (getLocalStorage(infiniteRedirectErrorKey) || {
    flag: InfiniteRedirectErrorFlag.FALSE,
  }) as {
    flag: InfiniteRedirectErrorFlag
    timestamp?: number
  }
}
export class InfiniteRedirect extends Base {
  private timeThreshold: number
  private countThreshold: number

  constructor(timeThreshold: number = 3, countThreshold: number = 10) {
    super()
    // 时间间隔阈值, 单位: 毫秒
    this.timeThreshold = timeThreshold * 1000
    // 次数阈值
    this.countThreshold = countThreshold
  }
  // 页面跳转记录
  public record() {
    try {
      const currentURL = window.location.origin + window.location.pathname
      const currentTimestamp = Date.now()
      this.checkCurrentURL(currentURL, currentTimestamp)
      this.launchInfiniteRedirectFinshedTimer()
    } catch (err) {
      this.addError(err)
    }
  }
  private launchInfiniteRedirectFinshedTimer() {
    setTimeout(() => {
      const infiniteRedirectError = getInfiniteRedirectErrorKey()
      // 获取本地缓存用户信息
      const { misId, userId } = getLocalStorage('userInfo')
      if (infiniteRedirectError.flag === InfiniteRedirectErrorFlag.TRUE) {
        this.addError('无限重定向异常恢复', {
          level: 'info',
          category: 'jsError',
          tags: {
            timestamp: infiniteRedirectError.timestamp,
            _misId: misId,
            userId,
          },
        })
        setInfiniteRedirectErrorKey(InfiniteRedirectErrorFlag.FALSE)
      }
      // 等待双倍的过期时间，保证此时页面确实稳定不再重定向
    }, this.timeThreshold * 2)
  }
  private recordParentUrl() {
    const FIRST_REFERRER_KEY = 'firstReferrer'
    let parentUrl: StorageData = {
      url: '',
      timestamp: 0,
    }
    try {
      const curReferrer = window.document.referrer

      if (isInvalidParentUrl(curReferrer)) {
        const parentUrlInfoInStorage = getLocalStorage(FIRST_REFERRER_KEY)
        parentUrl = parentUrlInfoInStorage || parentUrl
      } else {
        parentUrl = {
          url: curReferrer,
          timestamp: Date.now(),
        }
        setLocalStorage(FIRST_REFERRER_KEY, parentUrl)
      }
    } catch (error) {
      parentUrl = {
        url: `获取异常: ${error.message}`,
        timestamp: 0,
      }
    }
    return parentUrl
  }
  // 当前路径 重定向 监控检测
  private checkCurrentURL(currentURL: string, currentTimestamp: number) {
    const urlRecords = getSessionStorage(storageKey)
    const urlRecord = urlRecords[currentURL] as StorageData
    const curParentUrl = this.recordParentUrl()
    let referrerList = [document.referrer]
    let _count = 1
    if (urlRecord) {
      const { count, timestamp } = urlRecord
      const referrerListFromStorage = (urlRecord.referrerList as string[]) || []
      referrerList = [...referrerListFromStorage, document.referrer]
      // 与上次时间间隔小于 时间阈值, 且 累计次数 超过 次数阈值倍数, 做报警处理
      if (currentTimestamp - Number(timestamp) <= this.timeThreshold) {
        _count = (count as number) + 1
        if (_count % this.countThreshold === 0) {
          // 获取本地缓存用户信息
          const { misId, userId } = getLocalStorage('userInfo')
          setInfiniteRedirectErrorKey(InfiniteRedirectErrorFlag.TRUE)
          this.addError('无限重定向异常', {
            level: 'warn',
            category: 'jsError',
            tags: {
              count: _count,
              timestamp: currentTimestamp,
              referrerList,
              _misId: misId,
              userId,
              currentURL,
              parentUrl: curParentUrl.url,
              parentUrlRecordTime: curParentUrl.timestamp,
            },
          })
        }
      }
    }
    urlRecords[currentURL] = {
      count: _count,
      timestamp: currentTimestamp,
      referrerList,
    }
    setSessionStorage(storageKey, urlRecords)
  }
}
