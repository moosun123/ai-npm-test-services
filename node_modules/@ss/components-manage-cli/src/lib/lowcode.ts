const fs = require('fs');
const path = require('path');
const upperCamelCase = require('uppercamelcase');
import { fatalLog, publishLowcodeApi } from '@ss/components-manage-tools';
import { checkDocAPI, getMaterialVersion } from '../util/common';
import { extractReleaseInfo } from '../util/release';
const execSync = require('child_process').execSync;

export function buildLowcodeLocal() {
    const configPath = path.join(__dirname, '../lowcode/lowcode.config.js');
    try {
        execSync(`npx webpack server --config ${configPath}`, { stdio: 'inherit' });
    } catch (error) {
        fatalLog(error);
    }
}

export function buildLowcode() {
    // buildLowcodeEntry();
    tscLowcode();
}

//产出物料协议js
function tscLowcode() {
    try {
        execSync('cp node_modules/@ss/type-material/tsconfig.lowcode.json tsconfig.lowcode.json', { maxBuffer: 10 * 1000 * 1024 });
        execSync('npx tsc --project tsconfig.lowcode.json', { maxBuffer: 10 * 1000 * 1024 });
        // execSync('cp node_modules/@ss/type-material/lowcode.webpack.config.js lowcode.webpack.config.js');
        
        // 根据 lowcode.config.json 修改 webpackConfig
        replaceLowcodeWebpackConfigTemplate();
        execSync('npx --max_old_space_size=8192 webpack --config lowcode.webpack.config.js', { maxBuffer: 10 * 1000 * 1024 });
        console.log('----- execSync end -----')
        process.exit(0);
    } catch (error) {
        fatalLog(error);
    }
}

function replaceLowcodeWebpackConfigTemplate() {
    const programPath = process.cwd();
    const OUTPUT_PATH = path.join(programPath, './lowcode.webpack.config.js');
    const MtdConfig = require(path.join(programPath, './mtd.config.js'));
    const subPath = '../template/lowcode/lowcodeWebpackConfig.txt';
    const template = fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/LowcodeType/g, MtdConfig.lowcode.outputName);
    console.log("template content is", template);
    fs.writeFileSync(OUTPUT_PATH, template);
    console.log('[build lowcode] DONE:', OUTPUT_PATH);
}

function replaceLowcodeEntryTemplate(componentMetas: string[]) {
    const importComponentMetaStr = componentMetas
        .map(item => {
            const itemName = upperCamelCase(item);
            return `import ${itemName} from './${item}/meta';`;
        })
        .join('\n');
    const listComponentMetaStr = componentMetas.map(item => upperCamelCase(item)).join(',\n    ') + ',';
    const subPath = '../template/lowcode/entry.txt';
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/importComponentMetaStr/g, importComponentMetaStr)
        .replace(/listComponentMetaStr/g, listComponentMetaStr);
}

function buildLowcodeEntry() {
    const programPath = process.cwd();
    const lowcodePath = path.join(programPath, './lowcode');
    const OUTPUT_PATH = path.join(programPath, './lowcode/index.ts');

    const metaFiles = fs.readdirSync(lowcodePath);
    const componentMetas: Array<string> = [];
    metaFiles.forEach(function (item, index) {
        let stat = fs.lstatSync(path.join(lowcodePath, item));
        if (stat.isDirectory()) {
            componentMetas.push(item);
        }
    });
    const tsTemplate = replaceLowcodeEntryTemplate(componentMetas);
    fs.writeFileSync(OUTPUT_PATH, tsTemplate);
    console.log('[build lowcode:entry] DONE:', OUTPUT_PATH);
}

export const publishLowcode = async (options: any) => {
    options.skipVersion = true;
    options.releaseType = 'lowcode';
    if (options.skipCheck) {
        options.skipCheckBranch = true;
        options.skipTest = true;
    }
    const dir = process.cwd();
    checkDocAPI(dir);
    const data = await extractReleaseInfo(options);
    data.releaseType = 'lowcode';
    data.materialVersion = getMaterialVersion();
    await publishLowcodeApi(data);
}
