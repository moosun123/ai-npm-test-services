import { fatalLog, successLog, infoLog, checkLogin, uploadScreenShots, startScreenShot, publishApi } from '@ss/components-manage-tools'
import { checkedVersion } from '../util/fetch'
import { getTemplates, Template } from '../util/template'
import { getBranch, commitVersion, remoteSync } from '../util/git'
import { getProjectConfig } from '../util/common'
import { getGlobalDependencies } from '../util/dependencies'
import semver from 'semver'
import { prompt } from 'inquirer'
import { VERSION_INCREMENTS, SCREEN_SHOTS_PREFIX, execBuffer} from '../util/constant'
import { checkGitStatus } from '../util/git';
import * as path from 'path'
import * as fs from 'fs'
import execa from 'execa'
import childProcess from 'child_process';

async function askVersion() {
    const pkgPath = path.join(process.cwd(), 'package.json')
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'))
    const currentVersion = pkg.version

    let targetVersion: string
    const releases = VERSION_INCREMENTS.map((type) => {
        const preId = type.split(':')
        return `${type} (${semver.inc(currentVersion, preId[0], preId[1])})`
    })
    releases.push('custom')
    const { release } = await prompt<{ release: string }>({
        type: 'list',
        name: 'release',
        message: 'Select release type',
        choices: releases, // versionIncrements.map(i => `${i} (${inc(i)})`).concat(['custom'])
    })
    if (release === 'custom') {
        targetVersion = (
            await prompt<{ version: string }>({
                type: 'input',
                name: 'version',
                message: 'Input custom version',
                initial: currentVersion,
            })
        ).version
    } else {
        targetVersion = release.match(/\((.*)\)/)[1]
    }
    if (!semver.valid(targetVersion)) {
        throw new Error(`invalid target version: ${targetVersion}`)
    }

    return targetVersion
}

async function checkedBuild() {
    await execa('npm', ['run', 'build'])
}

function updatePackage(version: string) {
    const pkgPath = path.join(process.cwd(), 'package.json');
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
    pkg.version = version;
    fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
}

export async function prePublish(tl: any, version: string, screenshots: any, entryName: string, branch?: string) {
    const config = getProjectConfig()
    const globalDep = getGlobalDependencies(entryName)
    const pkgPath = path.join(process.cwd(), 'package.json')
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'))

    const errors: string[] = [];
    const templates = tl.map((tempalteCategory) => {

        return {
            name: tempalteCategory.name,
            cnName: tempalteCategory.cnName,
            templateId: tempalteCategory.id,
            children: tempalteCategory.children.map((template) => {
                if (!template.maintainer) {
                    errors.push(`nav.config.json 文件中，模板： ${template.name} 缺少 'maintainer' 字段值`)
                }
                const dependencies = template.dependencies;
                return {
                    ...template.nav,
                    name: template.name,
                    cnName: template.cnName,
                    screenshots: screenshots[template.key],
                    templateId: template.id,
                    maintainer: template.maintainer,
                    packageDep: { // 子模板依赖
                        dependencies: Object.assign({}, globalDep.dependencies, dependencies.dependencies),
                        devDependencies: Object.assign({}, globalDep.devDependencies, dependencies.devDependencies),
                    },
                }
            })
        }
    })
    if (errors.length) {
        throw new Error(errors.join('\n'))
    }
    const params = {
        id: config.id,
        name: pkg.name,
        version: version,
        branch: branch || 'master',
        token: checkLogin(),
        templates,
    }
    fs.writeFileSync(path.join(process.cwd(), 'component.log'), JSON.stringify(params, null, '  '))
    publishApi(params, 'template', true);
}

export async function publishTemplateLib(options: any) {
    if (options.skipCheck) {
        options.skipCheckBranch = true
        options.skipTest = true
    }
    const cwd = process.cwd()
    const config = getProjectConfig()
    const targetVersion = await askVersion()
    const branch = await checkGitStatus(cwd, options)
    const { yes } = await prompt<{ yes: boolean }>({
        type: 'confirm',
        name: 'yes',
        message: `Releasing v${targetVersion}. Confirm?`
    })
    if (!yes) {
        return
    }
    try {
        checkLogin()
        if (!options.skipVersion) {
            const data = await checkedVersion(targetVersion)
            if (data.code !== 0) {
                fatalLog(data.message)
            }
        }
        console.log('构建检查中');
        await checkedBuild();
        successLog('构建检查成功');

        console.log('模板信息收集中')
        const tl = await getTemplates(options.templatePath)
        const flatTemplates = tl.reduce((state, tl) => {
            const children = tl.children
            state = state.concat(children)
            return state
        }, [] as Template[])
        let screenshots: any = {}
        if (!options.skipScreenshot && config.platform !== 'mobile') {
            const arg: any = {
                cwd,
                templates: flatTemplates,
                framework: config.framework,
                screenShotsPrefix: SCREEN_SHOTS_PREFIX,
                execBuffer: execBuffer,
                screenShotsPort: options.screenshotPort,
                materialType: 'templateLib'
            }
            await startScreenShot(arg)
            successLog('截图生成成功✅')
            infoLog('上传截图中✈️');
            screenshots = await uploadScreenShots(cwd, flatTemplates, SCREEN_SHOTS_PREFIX, 'templateLib');
            childProcess.execSync(`rm -rf ${SCREEN_SHOTS_PREFIX}`, { cwd: arg.cwd });
            successLog('截图上传成功✅️')
        }

        successLog('模板信息收集完成')
        await updatePackage(targetVersion)
        await commitVersion(targetVersion)
        await remoteSync(targetVersion)
        successLog('`git push` 成功')

        await prePublish(tl, targetVersion, screenshots, options.entryName, branch)
        successLog('模板库发布中，发布完成后将会在大象上通知您。')
    } catch (e) {
        fatalLog(e.message);
    }
}
