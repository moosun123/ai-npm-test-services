import { fatalLog, execBuffer } from '@ss/components-manage-tools';
import * as cp from 'child_process';
import { askGitNotCommit, askGitNotPush, askReleaseOnNotMasterBranch } from './questions';
async function gitBranch(cwd: string): Promise<string> {
    return await new Promise((resolve, reject) => {
        const server = cp.exec('git rev-parse --abbrev-ref HEAD', { cwd, maxBuffer: execBuffer });
        server.stdout.on('data', function (log) {
            resolve(log?.trim() ?? '');
        });
        server.once('error', function (error) {
            reject(error.toString());
        });
    });
}

export async function gitStatusMessage(cwd: string): Promise<string> {
    return await new Promise((resolve, reject) => {
        const server = cp.exec('git status', { cwd, maxBuffer: execBuffer });
        server.stdout.on('data', function (log) {
            resolve(log || '');
        });
        server.once('error', function (error) {
            reject(error.toString());
        });
    });
}

export async function lastCommit(cwd: string): Promise<string> {
    try {
        const message: string = await new Promise((resolve, reject) => {
            const server = cp.exec('git log --format="%H" -n 1', { cwd, maxBuffer: execBuffer });
            server.stdout.on('data', function (log) {
                resolve(log || '');
            });
            server.once('error', function (error) {
                reject(error.toString());
            });
        });
        return message.trim();
    } catch (e) {
        throw new Error(e.toString());
    }
}

export async function getCurrentBranch(): Promise<string> {
    try {
        return await new Promise((resolve, reject) => {
            const server = cp.exec('git rev-parse --abbrev-ref HEAD', { maxBuffer: execBuffer });
            server.stdout.on('data', function (log) {
                resolve(log || '');
            });
            server.once('error', function (error) {
                reject(error.toString());
            });
        });
    } catch (e) {
        throw new Error(e.toString());
    }
}

export async function gitURL(cwd: string): Promise<string> {
    try {
        const message: string = await new Promise((resolve, reject) => {
            const server = cp.exec('git remote -v', { cwd, maxBuffer: execBuffer });
            server.stdout.on('data', function (log) {
                resolve(log || '');
            });
            server.once('error', function (error) {
                reject(error.toString());
            });
        });
        return message.split('(fetch)')[0].trim().split('\t')[1].trim();
    } catch (e) {
        throw new Error(e.toString());
    }
}

export async function checkGitStatus(cwd: string, options: any = {}) {
    const branch = await gitBranch(cwd);
    const message = await gitStatusMessage(cwd);

    if (!options.skipCheckBranch && branch !== 'master') {
        const result = await askReleaseOnNotMasterBranch(branch);
        if (!result.isOk) {
            process.exit(0);
        }
    }

    if (message.includes(' to publish your local commits')) {
        const result = await askGitNotPush();
        if (!result.isOk) {
            fatalLog('当前本地有未push的commit，请push再进行发布');
        }
    }

    if (message.includes('git checkout -- <file>...')) {
        const result = await askGitNotCommit();
        if (!result.isOk) {
            process.exit(0);
        }
    }

    return branch;
}

import execa from 'execa'

export async function getBranch() {
    const { stdout: branch } = await execa('git', ['symbolic-ref', '--short', '-q', 'HEAD']);
    return branch
}

export async function commitVersion(version: string) {
    await execa('git', ['add', '.'])
    await execa('git', ['commit', '-m', `feat: release v${version}`])
}

export async function remoteSync(version: string) {
    await execa('git', ['tag', `v${version}`])
    await execa('git', ['push', 'origin', `refs/tags/v${version}`])
    await execa('git', ['push'])
}
