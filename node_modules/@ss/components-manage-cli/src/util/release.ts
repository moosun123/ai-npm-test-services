import fs from 'fs';
import path from 'path';
import { getAPIInfo, getCodeInfo } from './api';
import childProcess from 'child_process';
import { checkLogin, infoLog, successLog, startScreenShot, uploadScreenShots } from '@ss/components-manage-tools';
import { collectCoverage } from './coverage';
import { gitURL, lastCommit, checkGitStatus, gitStatusMessage } from './git';
import { analyzeCompDep, analyzePackageDep } from './analyze';
import { confirmReleaseVersion, commitReleaseVersion, lastReleaseVersion } from './fetch';
import { inspectTemplate, formatComponentName, readProgramConfig, getCMVersion } from './common';
import { readComponentsNavInfo, readDocNavInfo } from './nav';
import { SCREEN_SHOTS_PREFIX, execBuffer} from './constant'

async function getNpmInfo(cwd: string): Promise<any> {
    const packageJSONPath = path.join(cwd, 'package.json');
    if (!fs.existsSync(packageJSONPath)) {
        throw new Error('package.json not exists ðŸ‘¿');
    }
    const packageJSONStr = fs.readFileSync(packageJSONPath).toString();
    try {
        const packageJSON = JSON.parse(packageJSONStr);
        const git = await gitURL(cwd);
        return {
            git: git || '',
            cmVersion: getCMVersion(),
            name: packageJSON.name || '',
            desc: packageJSON.desc || '',
            npmName: packageJSON.name || '',
            keyword: packageJSON.keyword || '',
            version: packageJSON.version || '',
            scaffoldVersion: packageJSON.scaffoldVersion || '',
        };
    } catch (e) {
        throw new Error(e);
    }
}

export async function extractReleaseInfo(options: any = {}): Promise<any> {
    // const { isMock } = options;
    const token = checkLogin();
    const { id } = inspectTemplate();
    const cwd = process.cwd();
    const { platform, framework } = readProgramConfig(cwd);
    const branch = await checkGitStatus(cwd, options);
    const commitInfo: any = {
        branch,
        version: JSON.parse(fs.readFileSync(path.join(cwd, 'package.json'), 'utf-8')).version
    };

    // if (!isMock && !options.skipVersion) {
    if (!options.skipVersion) {
        const lastVersion = await lastReleaseVersion(id);
        const version = await confirmReleaseVersion({
            id,
            lastVersion,
        });
        commitInfo['version'] = version;
    }
    const npmInfo = await getNpmInfo(cwd);
    const componentsInfo: any = {};
    let packageDep: any = {}, coverage: any = {};
    if (options.releaseType !== 'lowcode') {
        infoLog('ä¾èµ–ä¿¡æ¯æå–ä¸­ðŸš€');
        const packageDep = await analyzePackageDep(cwd);
        const componentsDep = await analyzeCompDep(cwd, framework, packageDep);
        successLog('ä¾èµ–ä¿¡æ¯æå–æˆåŠŸâœ…');
        const components: any = {};
        Object.keys(componentsDep).forEach(component => {
            components[component] = component;
        });
        let screenshots = {};
        // if (!options.skipScreenshot && platform !== 'mobile' && framework !== 'react') {
        if (!options.skipScreenshot && platform !== 'mobile') {
            infoLog('æˆªå›¾ç”Ÿæˆä¸­ðŸŒ„');
            await startScreenShot({
                cwd,
                components,
                framework,
                screenShotsPrefix: SCREEN_SHOTS_PREFIX,
                execBuffer: execBuffer,
                screenShotsPort: options.screenshotPort,
                materialType: 'componentLib'
            });
            successLog('æˆªå›¾ç”ŸæˆæˆåŠŸâœ…');

            infoLog('ä¸Šä¼ æˆªå›¾ä¸­âœˆï¸');
            screenshots = await uploadScreenShots(cwd, components, SCREEN_SHOTS_PREFIX, 'componentLib');
            childProcess.execSync(`rm -rf ${SCREEN_SHOTS_PREFIX}`, { cwd });
            successLog('æˆªå›¾ä¸Šä¼ æˆåŠŸâœ…ï¸');
        }

        infoLog('æå–æ–‡æ¡£ä¿¡æ¯ä¸­ðŸ“„');
        const api = getAPIInfo(cwd, components);
        const code = getCodeInfo(cwd, components);
        successLog('æ–‡æ¡£ä¿¡æ¯æå–æˆåŠŸâœ…');

        if (!options.skipTest && platform !== 'mobile' && framework !== 'react') {
            infoLog('æå–æµ‹è¯•è¦†ç›–çŽ‡ä¿¡æ¯â˜•ï¸');
            if (process.env.DISABLE_UNIT_TEST !== 'true') {
                coverage = collectCoverage();
            }
            successLog('æµ‹è¯•è¦†ç›–çŽ‡ä¿¡æ¯æå–æˆåŠŸâœ…');
        }
        Object.entries(api).forEach(([name, apiInfo]: [string, any]) => {
            const tagName = formatComponentName(name);
            componentsInfo[tagName] = {
                doc: apiInfo,
                screenshots: screenshots[name] || '',
                componentDep: componentsDep[name],
                testCoverage: coverage[tagName] || {
                    line: '0%',
                    statement: '0%',
                },
            };
        });
        Object.entries(code).forEach(([name, codeInfo]: [string, any]) => {
            const tagName = formatComponentName(name);
            componentsInfo[tagName] = {
                ...componentsInfo[tagName],
                code: codeInfo
            };
        });
    }
    const message = await gitStatusMessage(cwd);
    if (message.includes('Changes not staged for commit') || message.includes('Changes to be committed')) {
        await commitReleaseVersion(commitInfo);
    }
    const lastCommitMessage = await lastCommit(cwd);
    const componentNavInfo = readComponentsNavInfo(path.join(cwd, 'nav.config.json'));
    const docNavInfo = readDocNavInfo({
        platform,
        framework,
        filePath: path.join(cwd, 'doc.config.json'),
    });
    return {
        id,
        token,
        branch,
        commit: lastCommitMessage,
        techStack: framework,
        testCoverage: coverage.total,
        packageDep,
        docNav: docNavInfo,
        componentNav: componentNavInfo,
        components: componentsInfo,
        ...npmInfo,
    };
}
