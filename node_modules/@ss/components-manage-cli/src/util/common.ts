import * as fs from 'fs';
import chalk from 'chalk';
import * as path from 'path';
import { sync } from 'globby';
import { fatalLog } from '@ss/components-manage-tools';
import * as cp from 'child_process';
import { DISABLE_COMPONENT_NAME_INSPECTION } from '../contant';

const { execSync } = require('child_process');
const inquirer = require('inquirer');

export function extractFileNameList(framework: string): Array<{ fileName: string; filePath: string }> {
    const dir = process.cwd();
    const componentsJson = path.join(dir, 'components.json');
    if (!fs.existsSync(componentsJson)) {
        fatalLog('components.jsonä¸å­˜åœ¨');
    }
    const components = JSON.parse(fs.readFileSync(componentsJson).toString());
    const fileList = Object.entries(components)
        .filter(([name]) => name !== 'infoItem')
        .map(([name, file]) => ({
            filePath: path.join(dir, `${file}/${name}.${framework === 'vue' ? 'vue' : 'tsx'}`),
            fileName: name,
        }));
    if (framework === 'vue' && !DISABLE_COMPONENT_NAME_INSPECTION) {
        const config = fs.existsSync(path.join(dir, './mtd.config.js')) ? require(path.join(dir, './mtd.config.js')) : require(path.join(dir, './config.js'))
        let namespace;
        if (config.namespace) {
            namespace = config.namespace;
        } else {
            namespace = require(path.join(dir, './config.js')).namespace;
        }
        const validComponents: string[] = fileList
            .map(item => item.fileName)
            .filter(name => !name.startsWith(namespace));
        if (validComponents.length > 0) {
            fatalLog(`ä¸‹åˆ—ç»„ä»¶: ${validComponents.join(', ')}å‘½åä¸ç¬¦åˆè§„èŒƒï¼Œéœ€è¦ä»¥${namespace}å¼€å¤´`);
        }
    }
    return fileList;
}

export function toCamelCaseTag(tag: string): string {
    return tag
        .replace(/-(\w)/g, (_: string, b: string) => b.toUpperCase())
        .replace(/^\w/, (a: string) => a.toUpperCase());
}

export function inspectTemplate(): any {
    const directory = process.cwd();
    const templateJSONPath = path.join(directory, './template.json');
    if (!fs.existsSync(templateJSONPath)) {
        throw new Error('template.jsonä¸å­˜åœ¨ï¼Œè¯·å‰å¾€ä¸šåŠ¡ç»„ä»¶ç®¡ç†å¹³å°æ³¨å†Œ ğŸŒš');
    }
    const templateStr = fs.readFileSync(templateJSONPath).toString();
    let templateJSON: any;
    try {
        templateJSON = JSON.parse(templateStr);
    } catch (e) {
        throw new Error('template.jsonæ–‡ä»¶JSONååºåˆ—åŒ–å¤±è´¥');
    }
    if (!templateJSON.id) {
        throw new Error('id not found in template.json');
    }
    if (!templateJSON.framework) {
        throw new Error('framework not found in template.json');
    }
    if (!['vue', 'react'].includes(templateJSON.framework)) {
        throw new Error('frameworkå­—æ®µåªèƒ½ä¸ºvueæˆ–react');
    }
    return templateJSON;
}

export function formatComponentName(name: string) {
    return name.split('/').pop().split('.')[0];
}

export function hyphenToCamelCase(content: string) {
    return content.replace(/-([a-z])/g, g => g[1].toUpperCase());
}

export function readProgramConfig(program: string) {
    const defaultConfig = {
        framework: 'vue',
        technology: 'ts',
        platform: 'pc',
    };
    try {
        const templatePath = path.join(program, './template.json');
        const templateStr = fs.readFileSync(templatePath).toString();
        const templateObj = JSON.parse(templateStr);
        return {
            framework: templateObj.framework || defaultConfig.framework,
            technology: templateObj.technology || defaultConfig.technology,
            platform: templateObj.platform || defaultConfig.platform,
        };
    } catch (e) {
        return defaultConfig;
    }
}

export function getExtFromTechnology(technology: 'es' | 'ts') {
    return technology === 'es' ? 'js' : 'ts';
}

export function checkDocAPI(cwd: string) {
    const componentsPath = path.join(cwd, './components');
    const patterns = ['*/doc/api.json'];
    const fileNameList: string[] = sync(patterns, {
        cwd: componentsPath,
    });
    const fileList = fileNameList
        .filter(name => !name.includes('infoItem'))
        .map(file => path.join(cwd, './components', file));
    const withoutMaintainerFiles: string[] = [];
    const withoutCNNameFiles: string[] = [];
    fileList.forEach(file => {
        try {
            const content = fs.readFileSync(file).toString();
            const doc: any | any[] = JSON.parse(content);
            if (Array.isArray(doc)) {
                if (!doc[0].cnName) {
                    withoutCNNameFiles.push(file);
                }
                if (!doc[0].maintainer) {
                    withoutMaintainerFiles.push(file);
                }
            } else {
                if (!doc.cnName) {
                    withoutCNNameFiles.push(file);
                }
                if (!doc.maintainer) {
                    withoutMaintainerFiles.push(file);
                }
            }
        } catch (e) { }
    });
    if (withoutCNNameFiles.length > 0 || withoutMaintainerFiles.length > 0) {
        if (withoutCNNameFiles.length > 0) {
            console.log(chalk.redBright(`*********************************************`));
            console.log(chalk.redBright(`è¯·ä¸ºä¸‹åˆ—æ–‡ä»¶è¡¥å……ç»„ä»¶ä¸­æ–‡åç§°ï¼Œå¯¹åº”çš„å­—æ®µä¸ºcnName:`));
            withoutCNNameFiles.forEach(file => {
                console.log(chalk.redBright(file));
            });
        }
        if (withoutMaintainerFiles.length > 0) {
            console.log(chalk.redBright(`************************************************`));
            console.log(chalk.redBright(`è¯·ä¸ºä¸‹åˆ—æ–‡ä»¶è¡¥å……ç»„ä»¶ç»´æŠ¤è€…ä¿¡æ¯ï¼Œå¯¹åº”çš„å­—æ®µä¸ºmaintainer:`));
            withoutMaintainerFiles.forEach(file => {
                console.log(chalk.redBright(file));
            });
        }
        process.exit(1);
    }
}

export function getCMVersion(): string {
    try {
        const value = cp.execSync('npm list @ss/mtd-manage-commander', {
            encoding: 'utf-8',
        });
        const regExp = /@ss\/mtd-manage-commander@([\w\d\.-]+)\s/;
        const result = regExp.exec(value);
        if (result) {
            return result[1];
        }
        return '';
    } catch (e) {
        return '';
    }
}

export function handleMaintainer(maintainer: string): string {
    const homeDir = process.env['HOME'];
    const maintainerFileName = path.join(homeDir, '.mtdBCLastOwner');
    if (maintainer) {
        fs.writeFileSync(maintainerFileName, maintainer);
        return maintainer;
    }
    if (fs.existsSync(maintainerFileName)) {
        return fs.readFileSync(maintainerFileName).toString();
    }
    return '';
}

function kebabize(content: string) {
    return content
        .split('')
        .map((letter, idx) => {
            return letter.toUpperCase() === letter ? `${idx !== 0 ? '-' : ''}${letter.toLowerCase()}` : letter;
        })
        .join('');
}

export function removeNamespace(namespace: string, componentName: string) {
    if (componentName.startsWith(namespace)) {
        const nameWithoutPrefix = componentName.replace(namespace, '');
        if (nameWithoutPrefix.startsWith('-')) {
            return kebabize(nameWithoutPrefix.slice(1));
        }
        return kebabize(nameWithoutPrefix);
    }
    return kebabize(componentName);
}

let configCache: any
export function getProjectConfig() {
    if (configCache) {
        return configCache
    }
    const directory = process.cwd()
    const templateJSONPath = path.join(directory, './template.json')
    if (!fs.existsSync(templateJSONPath)) {
        throw new Error('template.jsonä¸å­˜åœ¨ï¼Œè¯·å‰å¾€ä¸šåŠ¡ç»„ä»¶ç®¡ç†å¹³å°æ³¨å†Œ ğŸŒš')
    }
    try {
        const config = require(templateJSONPath)
        checkProjectConfig(config)
        configCache = config
    } catch (e) {
        throw e
    }
    return configCache
}

function checkProjectConfig(config: any) {
    if (!config.id) {
        throw new Error('id not found in template.json')
    }
}

export function getEntry(config: string) {
    return path.join(process.cwd(), 'src', config)
}

export function getFile(file: string) {
    let dir = ''
    let fileName = ''
    const exists = fs.existsSync(file)
    if (exists) {
        const stats = fs.statSync(file)
        if (stats.isDirectory()) {
            dir = file
            fileName = 'index'
        } else {
            return file
        }
    } else {
        const ps = file.split(path.sep)
        dir = ps.slice(0, ps.length - 1).join(path.sep)
        fileName = ps[ps.length - 1]
    }

    const dirChildrens = fs.readdirSync(dir)
    const f = dirChildrens.find((name) => name.indexOf(fileName) === 0)
    if (!f) {
        throw new Error(`unable find file with path: ${file}`)
    }
    return path.join(dir, f)
}

export function getMaterialVersion() {
    const npmInfo = require(path.join(process.cwd(), './node_modules/@ss/type-material/package.json'))
    return npmInfo.version
}

export function getFrameworkVersion(framework: any) {
    const npmInfo = require(path.join(process.cwd(), 'package.json'));
    const reg = /[\^*~]/g;
    switch (framework) {
        case 'vue':
            return npmInfo.devDependencies.vue?.replace(reg, '');
        case 'react':
            return npmInfo.devDependencies.react?.replace(reg, '');
    }
}

export function getVueVersion() {
    let Vue: any;

    try {
        Vue = require('vue');
    } catch (e) {
        console.log(chalk.gray('æœªæ£€æµ‹åˆ° Vue'));
        process.exit(1);
    }

    const vueVersion = Vue?.version;
    let vueVersionMap = 1;
    if (vueVersion && vueVersion.startsWith('2.')) {
        vueVersionMap = 2;
    }
    if (vueVersion && vueVersion.startsWith('3.')) {
        vueVersionMap = 3;
    }

    return { vueVersion, vueVersionMap };
}

export async function chooseNpmTool() {
    const tools = await inquirer.prompt({
        type: 'list',
        message: 'è¯·é€‰æ‹©ä½ çš„ä¾èµ–ç®¡ç†å·¥å…·',
        name: 'type',
        choices: [
            'yarn',
            'npm',
            'å…¶ä»–',
        ]
    });
    switch (tools.type) {
        case 'yarn':
            return `yarn add`;
        case 'npm':
            return `npm install`;
        default:
            console.log(chalk.redBright('è¯·æ‰‹åŠ¨å®‰è£…ä¸Šè¿°æ¨¡æ¿ç¼–è¯‘å·¥å…·åé‡æ–°æ‰§è¡Œå‘½ä»¤'));
            process.exit(1)
    }
}

export async function checkCompiler(vueVersion:string, vueVersionMap: number) {
    switch (vueVersionMap) {
        case 3:
            // vue 3.x æ£€æµ‹æ˜¯å¦æœ‰å¯¹åº”çš„ @vue/compiler-sfc
            const vueCompilerSfcPath = path.join(process.cwd(), 'node_modules', '@vue', 'compiler-sfc');
            try {
                fs.statSync(vueCompilerSfcPath);
            } catch (error) {
                console.log(chalk.blueBright(`æ£€æµ‹åˆ°æ‚¨çš„ Vue ç‰ˆæœ¬ä¸º${vueVersion}, éœ€è¦å®‰è£…å¯¹åº”æ¨¡ç‰ˆç¼–è¯‘å·¥å…· @vue/compiler-sfc`));
                const cmd = await chooseNpmTool();
                console.log(chalk.greenBright(`å¼€å§‹å®‰è£…@vue/compiler-sfc@${vueVersion}...`));
                execSync(`${cmd} @vue/compiler-sfc@${vueVersion}`);
            }
            break;
    
        default:
            //æ£€æµ‹ vue å…¶ä»–ç‰ˆæœ¬æ˜¯å¦æœ‰å¯¹åº”çš„ vue-template-compiler
            const vueTemplateCompilerPath = path.join(process.cwd(), 'node_modules', 'vue-template-compiler');
            try {
                fs.statSync(vueTemplateCompilerPath);
            } catch (error) {
                console.log(chalk.blueBright(`æ£€æµ‹åˆ°æ‚¨çš„ Vue ç‰ˆæœ¬ä¸º${vueVersion}, è¯·å®‰è£…å¯¹åº”æ¨¡ç‰ˆç¼–è¯‘å·¥å…· vue-template-compiler åé‡æ–°æ‰§è¡Œå‘½ä»¤`));
                const cmd = await chooseNpmTool();
                console.log(chalk.greenBright(`å¼€å§‹å®‰è£…vue-template-compiler@${vueVersion}...`));
                execSync(`${cmd} vue-template-compiler@${vueVersion}`);
            }
            break;
    }
}