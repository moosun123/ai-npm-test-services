import * as fs from 'fs';
import * as path from 'path';
import { warningLog } from '@ss/components-manage-tools';
import { Dependencies, getFullDependencies } from './dependencies';
import { getId, updateLockFile } from './lock';
// import { fatalLog } from '@ss/components-manage-tools';
import { getVueVersion } from './common';
// import { compile, ASTElement, ASTNode } from 'vue-template-compiler';
import { ComponentDep, ComponentDepItem, MakeEntryTemplatePayload, PackageDep } from '../type/template';
const nanoId = require('nanoid');

interface Nav {
    cnName: string;
    maintainer?: string;
    index: number;
    children?: {
        [key: string]: Nav;
    };
}
interface Navs {
    [key: string]: Nav
}
interface TplConfig {
    // maintainer: string;
    cnName: string;
    path: string;
    maintainer: string;
    designer?: string;
}

interface GroupConfig {
    groupName: string;
    path: string;
    list: TplConfig[]
}

interface NavConfig {
    title: string;
    groups: GroupConfig[];
}

function formatNavConfig(navCfg: NavConfig): Navs {
    const config: Navs = {};
    navCfg.groups.map((group, index) => {
        const { path: key, groupName: name, ...rest } = group;
        config[key] = {
            ...rest,
            cnName: name,
            index,
            children: group.list.reduce((state, item, i) => {
                const { path: childKey, ...rest } = item;
                state[childKey] = {
                    ...rest,
                    index: i,
                }
                return state;
            }, {} as Navs),
        }

    })
    return config;
}
export class Template {
    id: string;
    name: string
    cnName?: string
    path: string
    entry: string
    dependencies: Dependencies
    nav?: Nav
    url: string
    key: string
    maintainer: string
    index: number;

    screenshotPath?: string
    screenshotS3URL?: string

    constructor(name: string, dir: string, parent: TemplateDirectory) {
        this.id = getId(parent.name, name)
        this.key = `${parent.name}-${name}`
        this.name = name
        this.path = dir

        const dirChildrens = fs.readdirSync(dir)
        const indexs = dirChildrens.find((fileName) => /^index\.\w+$/.test(fileName))
        if (!indexs) {
            throw new Error(`文件夹 ${dir} 中必须包含 index 文件`)
        }
        this.entry = path.join(dir, indexs)
        this.dependencies = getFullDependencies(this.entry)

        this.url = `${parent.name}/${this.name}`
        const { nav: parentNav } = parent

        const childrenNav = parentNav ? parentNav.children : {}
        const nav = childrenNav[this.name]
        this.nav = nav
        this.index = nav ? nav.index : -1;
        this.cnName = this.nav ? this.nav.cnName : ''
        this.maintainer = this.nav ? this.nav.maintainer : '';
    }
}

export class TemplateDirectory {
    id: string;
    name: string
    cnName?: string
    path: string
    children: Template[]
    nav?: Nav
    index: number;

    constructor(name: string, dir: string, nav?: Nav) {
        this.id = getId(name)
        this.name = name
        this.path = dir
        this.nav = nav;
        this.cnName = this.nav ? this.nav.cnName : ''
        this.index = nav ? nav.index : -1;
        this.children = this.readChildren(dir);
    }

    readChildren(dir: string, nav?: Nav) {
        const dirChildrens = fs.readdirSync(dir)
        return dirChildrens.reduce((children, p) => {
            const pdir = path.join(dir, p)
            const state = fs.statSync(pdir)
            if (state.isDirectory()) {
                try {
                    children.push(new Template(p, pdir, this))
                } catch (e) {
                    warningLog(e.message)
                }
            }
            return children
        }, []).sort((a, b) => {
            return a.index - b.index;
        });
    }
}

export type TemplateDirectories = TemplateDirectory[];


function getTemplateDirectories(root: string, nav: NavConfig) {
    const navArray = formatNavConfig(nav);

    const names: string[] = fs.readdirSync(root)
    const map: TemplateDirectories = [];

    names.forEach((name: string) => {
        const p = path.join(root, name)
        const state = fs.statSync(p)
        if (state.isDirectory()) {
            const t = new TemplateDirectory(name, p, navArray[name])
            if (t.children.length) {
                map.push(t);
            }
        }
    });

    return map.sort((a, b) => a.index - b.index)
}

function resolve(dir: string) {
    return path.join(process.cwd(), dir)
}

// const TEMPLATES_PATH = resolve(path.join('src', 'views'))

export type TaskArguments = {
    cwd: string;
    templates: Template[];
}

export async function getTemplates(templatePath: any) {
    const navConfig = require(path.join(process.cwd(), 'nav.config.json'))
    const templates = getTemplateDirectories(resolve(path.join('src', templatePath)), navConfig[0])
    updateLockFile()
    return templates
}

// export function vueTemplateParser(
//     fileList: Array<{ filePath: string; fileName: string }>,
//     packageDep: PackageDep,
// ): ComponentDep {
//     const dep: ComponentDep = {};
//     fileList.forEach(file => {
//         if (!fs.existsSync(file.filePath)) {
//             fatalLog(`组件${file.fileName}的文件名有误，正确的路径是${file.filePath}`);
//         }
//         const content = fs.readFileSync(file.filePath).toString();
//         const ast = compile(content).ast;
//         const tagNameList = generateVueTagNameList(ast);
//         const depList = generateCompDep(content, packageDep);
//         dep[file.fileName] = {
//             tagNameList,
//             depList,
//         };
//     });
//     return dep;
// }

// export function reactTemplateParser(
//     fileList: Array<{ filePath: string; fileName: string }>,
//     packageDep: PackageDep,
// ): ComponentDep {
//     const dep: ComponentDep = {};
//     fileList.forEach(file => {
//         const content = fs.readFileSync(file.filePath).toString();
//         const depList = generateCompDep(content, packageDep);
//         const tagNameList = generateReactTagNameList(content);
//         dep[file.fileName] = {
//             tagNameList,
//             depList,
//         };
//     });
//     return dep;
// }

// export function generateVueTagNameList(ast: ASTElement, isMtd = true): string[] {
//     const tagList: string[] = [];
//     const stack: ASTElement[] = [];
//     stack.push(ast);
//     while (stack.length !== 0) {
//         const item: ASTNode = stack.shift();
//         if (!!item.tag) {
//             tagList.push(item.tag);
//         }
//         if (item.children && item.children.length > 0) {
//             stack.push(...(item.children as ASTElement[]));
//         }
//     }

//     return isMtd
//         ? tagList
//               .filter(tag => !!tag)
//               .filter(tag => tag.startsWith('mtd') || tag.startsWith('Mtd'))
//               .map(tag => toCamelCaseTag(tag))
//         : tagList;
// }

// function generateReactTagNameList(content: string): string[] {
//     return (
//         content
//             ?.match(/<(\w+)[\s>]/g)
//             ?.filter(tag => tag?.startsWith('<Mtd'))
//             ?.map(tag => tag?.match(/<(\w+)[\s>]/)?.[1]) ?? []
//     );
// }

// function generateCompDep(content: string, packageDep: PackageDep): ComponentDepItem[] {
//     const result: ComponentDepItem[] = [];
//     const reg = new RegExp(/import.+from.+['"](.+)['"]/g);
//     const matchedList = content.match(reg);
//     const depMap: { [key: string]: boolean } = {};
//     if (matchedList) {
//         matchedList.forEach(item => {
//             const value = item.match(/import.+from.+['"](.+)['"]/);
//             const dependencies = value[1];
//             if (!depMap[dependencies]) {
//                 const isExternal =
//                     dependencies in packageDep.dependencies || dependencies in packageDep.peerDependencies;
//                 const version =
//                     packageDep.dependencies[dependencies] || packageDep.peerDependencies[dependencies] || '';
//                 result.push({
//                     dependencies,
//                     version,
//                     isExternal,
//                 });
//                 depMap[dependencies] = true;
//             }
//         });
//     }
//     return result;
// }

// 项目构建入口
function replaceEntryTemplate(subPath: string, payload: MakeEntryTemplatePayload) {
    const { listModuleStr, importModuleStr, listComponentStr, importComponentStr, installComponentStr } = payload;
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/listModuleStr/g, listModuleStr)
        .replace(/importModuleStr/g, importModuleStr)
        .replace(/listComponentStr/g, listComponentStr)
        .replace(/importComponentStr/g, importComponentStr)
        .replace(/installComponentStr/g, installComponentStr);
}

export function tsEntryTemplate(payload: any, isCustomEntryPath: any) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/entry.txt' : '../template/vue_pc_ts/entry.txt';
    return replaceEntryTemplate(isCustomEntryPath ? path.join(process.cwd(), './entry.txt') : path.join(__dirname, vueTplPath), payload);
}

export function esEntryTemplate(payload: MakeEntryTemplatePayload) {
    return replaceEntryTemplate('../template/vue_pc_es/entry.txt', payload);
}

// 组件初始内容
function replaceComponentTemplate(subPath: string, exportName: string, componentClassName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentClassName/g, componentClassName);
}

export function tsComponentTemplate(exportName: string, componentClassName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/component.txt' : '../template/vue_pc_ts/component.txt';
    return replaceComponentTemplate(vueTplPath, exportName, componentClassName);
}

export function esComponentTemplate(exportName: string, componentClassName: string) {
    return replaceComponentTemplate('../template/vue_pc_es/component.txt', exportName, componentClassName);
}

// 组件demo内容
function replaceDemoTemplate(subPath: string, exportName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName);
}

export function esDemoTemplate(exportName: string) {
    return replaceDemoTemplate('../template/vue_pc_es/demo.txt', exportName);
}

export function tsDemoTemplate(exportName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/demo.txt' : '../template/vue_pc_ts/demo.txt';
    return replaceDemoTemplate(vueTplPath, exportName);
}

function replaceRegistryTemplate(subPath: string, exportName: string, componentName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/fileName/g, componentName);
}

// 组件注册逻辑
export function esRegistryTemplate(exportName: string, componentName: string) {
    return replaceRegistryTemplate('../template/vue_pc_es/registry.txt', exportName, componentName);
}

export function tsRegistryTemplate(exportName: string, componentName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/registry.txt' : '../template/vue_pc_ts/registry.txt';
    return replaceRegistryTemplate(vueTplPath, exportName, componentName);
}


export function testTemplate(exportName: string, componentName) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/test.txt'))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentName/g, componentName);
}

export function componentDocTemplate(componentName: string, cnName: string, maintainer: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/doc.txt'))
        .toString()
        .replace(/componentName/g, componentName)
        .replace(/cnNameVal/g, cnName)
        .replace(/maintainerVal/g, maintainer)
        .replace(/nanoId/g, nanoId.nanoid());
}

export function typeDefTemplate(exportName: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/typeDef.txt'))
        .toString()
        .replace(/exportName/g, exportName);
}

export function sassTemplate(className: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/sass.txt'))
        .toString()
        .replace(/className/g, className);
}
