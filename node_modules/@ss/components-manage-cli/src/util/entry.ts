import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import { fatalLog } from '@ss/components-manage-tools';
import { toCamelCaseTag, checkCompiler, getVueVersion } from './common';
import { nanoid } from 'nanoid';

export async function vueTemplateParser(
    fileList: Array<{ filePath: string; fileName: string }>,
    packageDep: any,
): Promise<any> {
    const dep: any = {};
    
    const { vueVersion, vueVersionMap } = getVueVersion();

    await checkCompiler(vueVersion, vueVersionMap);

    fileList.forEach(file => {
        if (!fs.existsSync(file.filePath)) {
            fatalLog(`组件${file.fileName}的文件名有误，正确的路径是${file.filePath}`);
        }
        let ast:any = [];
        let tagNameList = [];
        let depList = [];
        const content = fs.readFileSync(file.filePath).toString();
        if (vueVersionMap === 3) {
            const compileTemplate = require('@vue/compiler-sfc').compileTemplate;
            ast = compileTemplate({source: content, filename: file.fileName, id: file.fileName}).ast;
            tagNameList = generateVueTagNameList4Vue3(ast);
            depList = generateCompDep(content, packageDep);
        } else {
            const compile = require('vue-template-compiler').compile;
            ast = compile(content).ast;
            tagNameList = generateVueTagNameList(ast);
            depList = generateCompDep(content, packageDep);
        }
        
        dep[file.fileName] = {
            tagNameList,
            depList,
        };
    });
    return dep;
}

export function reactTemplateParser(
    fileList: Array<{ filePath: string; fileName: string }>,
    packageDep: any,
): any {
    const dep: any = {};
    fileList.forEach(file => {
        const content = fs.readFileSync(file.filePath).toString();
        const depList = generateCompDep(content, packageDep);
        const tagNameList = generateReactTagNameList(content);
        dep[file.fileName] = {
            tagNameList,
            depList,
        };
    });
    return dep;
}

export function generateVueTagNameList(ast, isMtd = true): string[] {
    const tagList: string[] = [];
    const stack = [];
    stack.push(ast);
    while (stack.length !== 0) {
        const item = stack.shift();
        if (!!item.tag) {
            tagList.push(item.tag);
        }
        if (item.children && item.children.length > 0) {
            stack.push(...(item.children));
        }
    }

    return isMtd
        ? tagList
            .filter(tag => !!tag)
            .filter(tag => tag.startsWith('mtd') || tag.startsWith('Mtd'))
            .map(tag => toCamelCaseTag(tag))
        : tagList;
}

export function generateVueTagNameList4Vue3(ast, isMtd = true): string[] {
    const tagList: string[] = [];
    const stack = [];
    if (ast?.children[0]) {
        stack.push(ast?.children[0]);
    }
    while (stack.length !== 0) {
        const item = stack.shift();
        if (!!item.tag) {
            tagList.push(item.tag);
        }
        if (item.children && item.children.length > 0) {
            stack.push(...(item.children));
        }
    }

    return isMtd
        ? tagList
            .filter(tag => !!tag)
            .filter(tag => tag.startsWith('mtd') || tag.startsWith('Mtd'))
            .map(tag => toCamelCaseTag(tag))
        : tagList;
}


function generateReactTagNameList(content: string): string[] {
    return (
        content
            ?.match(/<(\w+)[\s>]/g)
            ?.filter(tag => tag?.startsWith('<Mtd'))
            ?.map(tag => tag?.match(/<(\w+)[\s>]/)?.[1]) ?? []
    );
}

function generateCompDep(content: string, packageDep: any): any[] {
    const result: any[] = [];
    const reg = new RegExp(/import.+from.+['"](.+)['"]/g);
    const matchedList = content.match(reg);
    const depMap: { [key: string]: boolean } = {};
    if (matchedList) {
        matchedList.forEach(item => {
            const value = item.match(/import.+from.+['"](.+)['"]/);
            const dependencies = value[1];
            if (!depMap[dependencies]) {
                const isExternal =
                    dependencies in packageDep.dependencies || dependencies in packageDep.peerDependencies;
                const version =
                    packageDep.dependencies[dependencies] || packageDep.peerDependencies[dependencies] || '';
                result.push({
                    dependencies,
                    version,
                    isExternal,
                });
                depMap[dependencies] = true;
            }
        });
    }
    return result;
}

// 项目构建入口
function replaceEntryTemplate(subPath: string, payload: any) {
    const { listModuleStr, importModuleStr, listComponentStr, importComponentStr, installComponentStr } = payload;
    return fs
        .readFileSync(subPath)
        .toString()
        .replace(/listModuleStr/g, listModuleStr)
        .replace(/importModuleStr/g, importModuleStr)
        .replace(/listComponentStr/g, listComponentStr)
        .replace(/importComponentStr/g, importComponentStr)
        .replace(/installComponentStr/g, installComponentStr);
}

export function tsEntryTemplate(payload: any, isCustomEntryPath: any) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/entry.txt' : '../template/vue_pc_ts/entry.txt';
    return replaceEntryTemplate(isCustomEntryPath ? path.join(process.cwd(), './entry.txt') : path.join(__dirname, vueTplPath), payload);
}

export function esEntryTemplate(payload: any, isCustomEntryPath: any) {
    return replaceEntryTemplate(isCustomEntryPath ? path.join(process.cwd(), './entry.txt') : path.join(__dirname, '../template/vue_pc_es/entry.txt'), payload);
}

// 组件初始内容
function replaceComponentTemplate(subPath: string, exportName: string, componentClassName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentClassName/g, componentClassName);
}

export function tsComponentTemplate(exportName: string, componentClassName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/component.txt' : '../template/vue_pc_ts/component.txt';
    return replaceComponentTemplate(vueTplPath, exportName, componentClassName);
}

export function esComponentTemplate(exportName: string, componentClassName: string) {
    return replaceComponentTemplate('../template/vue_pc_es/component.txt', exportName, componentClassName);
}

// 组件demo内容
function replaceDemoTemplate(subPath: string, exportName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName);
}

export function esDemoTemplate(exportName: string) {
    return replaceDemoTemplate('../template/vue_pc_es/demo.txt', exportName);
}

export function tsDemoTemplate(exportName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/demo.txt' : '../template/vue_pc_ts/demo.txt';
    return replaceDemoTemplate(vueTplPath, exportName);
}

function replaceRegistryTemplate(subPath: string, exportName: string, componentName: string) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/fileName/g, componentName);
}

// 组件注册逻辑
export function esRegistryTemplate(exportName: string, componentName: string) {
    return replaceRegistryTemplate('../template/vue_pc_es/registry.txt', exportName, componentName);
}

export function tsRegistryTemplate(exportName: string, componentName: string) {
    const { vueVersionMap } = getVueVersion();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/registry.txt' : '../template/vue_pc_ts/registry.txt';
    return replaceRegistryTemplate(vueTplPath, exportName, componentName);
}

export function testTemplate(exportName: string, componentName) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/test.txt'))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentName/g, componentName);
}

export function componentDocTemplate(componentName: string, cnName: string, maintainer: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/doc.txt'))
        .toString()
        .replace(/componentName/g, componentName)
        .replace(/cnNameVal/g, cnName)
        .replace(/maintainerVal/g, maintainer)
        .replace(/nanoId/g, nanoid());
}

export function typeDefTemplate(exportName: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/typeDef.txt'))
        .toString()
        .replace(/exportName/g, exportName);
}

export function sassTemplate(className: string) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/sass.txt'))
        .toString()
        .replace(/className/g, className);
}