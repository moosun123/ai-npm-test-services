import * as path from 'path'
import * as fs from 'fs'
import { getFile, getEntry } from './common'

function removeAnnotation (content: string) {
  return content.replace(/\/\*[\s\S]*\*\//, '').replace(/\/\/.*\r{0,1}\n/g, '')
}

const ImportRegexp = [
  /\bimport\s+['"](.+)['"]/g,
  /\bfrom\s+['"](\S+)['"]/g,
]

const excludeDependencies = ['router', 'source'].map((p) => {
  return path.join(process.cwd(), 'src', p);
})

type FileDependency = string;
const fileCache: { [key: string]: FileDependency[] } = {}

function analysiDependencies (file: string) {
  if (fileCache[file]) {
    return fileCache[file]
  } else if (excludeDependencies.find((exclude) => {
    return file.indexOf(exclude) > -1;
  })) {
    return [];
  }
  fileCache[file] = []
  try {
    let content = removeAnnotation(fs.readFileSync(getFile(file), { encoding: 'utf-8' }))
    if (path.extname(file) === '.vue') {
      // 提取 script 标签内字段
      const b = content.indexOf('<script')
      const e = content.lastIndexOf('</script>')
      content = content.substr(b, e - b)
    }
    const dependencies: FileDependency[] = []
    ImportRegexp.forEach((regexp) => {
      const matches = content.match(regexp)
      if (matches && matches.length) {
        matches.forEach((str) => {
          dependencies.push(str.match(/['"](.+)['"]$/)[1])
        })
      }
    })
    fileCache[file] = dependencies
    return dependencies
  } catch (e) {
    console.error(e)
  }
  return []
}

function isRelative (filePath: string) {
  return filePath.charAt(0) === '.'
}

type DependencyVersion = string;
export type Dependencies = {
  // modules: { [key: string]: DependencyVersion };
  devDependencies: { [key: string]: DependencyVersion },
  dependencies: { [key: string]: DependencyVersion },

  relative: string[];
  unknown: string[];
};

function formatDependencies (dependencies: FileDependency[]) {
  return dependencies.reduce((state: Dependencies, d: string) => {
    if (isRelative(d)) {
      state.relative.push(d)
      return state
    }
    const pkgPath = path.join(process.cwd(), 'package.json')
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'))
    const PackageDependencies: {
      [key: string]: string;
    } = Object.assign({}, pkg.devDependencies, pkg.dependencies)
    // 尝试从 package.json 匹配对应的包名
    const array = d.split('/')
    let version: string
    let name: string
    for (let i = 1; !version && i <= array.length; i++) {
      name = array.slice(0, i).join('/')
      version = PackageDependencies[name]
    }
    if (!version) {
      state.unknown.push(d)
    } else if ((pkg.devDependencies || {})[name]) {
      state.devDependencies[name] = version
    } else {
      state.dependencies[name] = version
    }
    return state
  }, { devDependencies: {}, dependencies: {}, relative: [], unknown: [] })
}

function concatDependencies (a: Dependencies, ...array: Dependencies[]) {
  const { relative, devDependencies, dependencies, unknown } = a
  array.forEach((dp) => {
    Object.assign(devDependencies, dp.devDependencies)
    Object.assign(dependencies, dp.dependencies)
    relative.concat(dp.relative)
    unknown.concat(dp.unknown)
  })
  return a
}

type DependenciesCache = { [key: string]: Dependencies };

export function getFullDependencies (entry: string) {
  const cached: DependenciesCache = {}

  function reduce (file: string, cached: DependenciesCache) {
    const dependencies = formatDependencies(analysiDependencies(file))
    cached[file] = dependencies

    const { relative: relativeFiles } = dependencies
    relativeFiles.map((f) => {
      return path.join(file, '..', f)
    })
    .filter((f) => !cached[f])
    .forEach((f: string) => {
      return concatDependencies(dependencies, reduce(f, cached))
    })

    return dependencies
  }
  return reduce(entry, cached)
}

export function getGlobalDependencies (entryName: string) {
  const entry = getEntry(entryName)
  return getFullDependencies(entry)
}
