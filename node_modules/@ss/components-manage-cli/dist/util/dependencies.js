"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalDependencies = exports.getFullDependencies = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const common_1 = require("./common");
function removeAnnotation(content) {
    return content.replace(/\/\*[\s\S]*\*\//, '').replace(/\/\/.*\r{0,1}\n/g, '');
}
const ImportRegexp = [
    /\bimport\s+['"](.+)['"]/g,
    /\bfrom\s+['"](\S+)['"]/g,
];
const excludeDependencies = ['router', 'source'].map((p) => {
    return path.join(process.cwd(), 'src', p);
});
const fileCache = {};
function analysiDependencies(file) {
    if (fileCache[file]) {
        return fileCache[file];
    }
    else if (excludeDependencies.find((exclude) => {
        return file.indexOf(exclude) > -1;
    })) {
        return [];
    }
    fileCache[file] = [];
    try {
        let content = removeAnnotation(fs.readFileSync((0, common_1.getFile)(file), { encoding: 'utf-8' }));
        if (path.extname(file) === '.vue') {
            const b = content.indexOf('<script');
            const e = content.lastIndexOf('</script>');
            content = content.substr(b, e - b);
        }
        const dependencies = [];
        ImportRegexp.forEach((regexp) => {
            const matches = content.match(regexp);
            if (matches && matches.length) {
                matches.forEach((str) => {
                    dependencies.push(str.match(/['"](.+)['"]$/)[1]);
                });
            }
        });
        fileCache[file] = dependencies;
        return dependencies;
    }
    catch (e) {
        console.error(e);
    }
    return [];
}
function isRelative(filePath) {
    return filePath.charAt(0) === '.';
}
function formatDependencies(dependencies) {
    return dependencies.reduce((state, d) => {
        if (isRelative(d)) {
            state.relative.push(d);
            return state;
        }
        const pkgPath = path.join(process.cwd(), 'package.json');
        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
        const PackageDependencies = Object.assign({}, pkg.devDependencies, pkg.dependencies);
        const array = d.split('/');
        let version;
        let name;
        for (let i = 1; !version && i <= array.length; i++) {
            name = array.slice(0, i).join('/');
            version = PackageDependencies[name];
        }
        if (!version) {
            state.unknown.push(d);
        }
        else if ((pkg.devDependencies || {})[name]) {
            state.devDependencies[name] = version;
        }
        else {
            state.dependencies[name] = version;
        }
        return state;
    }, { devDependencies: {}, dependencies: {}, relative: [], unknown: [] });
}
function concatDependencies(a, ...array) {
    const { relative, devDependencies, dependencies, unknown } = a;
    array.forEach((dp) => {
        Object.assign(devDependencies, dp.devDependencies);
        Object.assign(dependencies, dp.dependencies);
        relative.concat(dp.relative);
        unknown.concat(dp.unknown);
    });
    return a;
}
function getFullDependencies(entry) {
    const cached = {};
    function reduce(file, cached) {
        const dependencies = formatDependencies(analysiDependencies(file));
        cached[file] = dependencies;
        const { relative: relativeFiles } = dependencies;
        relativeFiles.map((f) => {
            return path.join(file, '..', f);
        })
            .filter((f) => !cached[f])
            .forEach((f) => {
            return concatDependencies(dependencies, reduce(f, cached));
        });
        return dependencies;
    }
    return reduce(entry, cached);
}
exports.getFullDependencies = getFullDependencies;
function getGlobalDependencies(entryName) {
    const entry = (0, common_1.getEntry)(entryName);
    return getFullDependencies(entry);
}
exports.getGlobalDependencies = getGlobalDependencies;
