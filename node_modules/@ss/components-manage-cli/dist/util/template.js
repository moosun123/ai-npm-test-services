"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sassTemplate = exports.typeDefTemplate = exports.componentDocTemplate = exports.testTemplate = exports.tsRegistryTemplate = exports.esRegistryTemplate = exports.tsDemoTemplate = exports.esDemoTemplate = exports.esComponentTemplate = exports.tsComponentTemplate = exports.esEntryTemplate = exports.tsEntryTemplate = exports.getTemplates = exports.TemplateDirectory = exports.Template = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const components_manage_tools_1 = require("@ss/components-manage-tools");
const dependencies_1 = require("./dependencies");
const lock_1 = require("./lock");
const common_1 = require("./common");
const nanoId = require('nanoid');
function formatNavConfig(navCfg) {
    const config = {};
    navCfg.groups.map((group, index) => {
        const { path: key, groupName: name, ...rest } = group;
        config[key] = {
            ...rest,
            cnName: name,
            index,
            children: group.list.reduce((state, item, i) => {
                const { path: childKey, ...rest } = item;
                state[childKey] = {
                    ...rest,
                    index: i,
                };
                return state;
            }, {}),
        };
    });
    return config;
}
class Template {
    constructor(name, dir, parent) {
        this.id = (0, lock_1.getId)(parent.name, name);
        this.key = `${parent.name}-${name}`;
        this.name = name;
        this.path = dir;
        const dirChildrens = fs.readdirSync(dir);
        const indexs = dirChildrens.find((fileName) => /^index\.\w+$/.test(fileName));
        if (!indexs) {
            throw new Error(`文件夹 ${dir} 中必须包含 index 文件`);
        }
        this.entry = path.join(dir, indexs);
        this.dependencies = (0, dependencies_1.getFullDependencies)(this.entry);
        this.url = `${parent.name}/${this.name}`;
        const { nav: parentNav } = parent;
        const childrenNav = parentNav ? parentNav.children : {};
        const nav = childrenNav[this.name];
        this.nav = nav;
        this.index = nav ? nav.index : -1;
        this.cnName = this.nav ? this.nav.cnName : '';
        this.maintainer = this.nav ? this.nav.maintainer : '';
    }
}
exports.Template = Template;
class TemplateDirectory {
    constructor(name, dir, nav) {
        this.id = (0, lock_1.getId)(name);
        this.name = name;
        this.path = dir;
        this.nav = nav;
        this.cnName = this.nav ? this.nav.cnName : '';
        this.index = nav ? nav.index : -1;
        this.children = this.readChildren(dir);
    }
    readChildren(dir, nav) {
        const dirChildrens = fs.readdirSync(dir);
        return dirChildrens.reduce((children, p) => {
            const pdir = path.join(dir, p);
            const state = fs.statSync(pdir);
            if (state.isDirectory()) {
                try {
                    children.push(new Template(p, pdir, this));
                }
                catch (e) {
                    (0, components_manage_tools_1.warningLog)(e.message);
                }
            }
            return children;
        }, []).sort((a, b) => {
            return a.index - b.index;
        });
    }
}
exports.TemplateDirectory = TemplateDirectory;
function getTemplateDirectories(root, nav) {
    const navArray = formatNavConfig(nav);
    const names = fs.readdirSync(root);
    const map = [];
    names.forEach((name) => {
        const p = path.join(root, name);
        const state = fs.statSync(p);
        if (state.isDirectory()) {
            const t = new TemplateDirectory(name, p, navArray[name]);
            if (t.children.length) {
                map.push(t);
            }
        }
    });
    return map.sort((a, b) => a.index - b.index);
}
function resolve(dir) {
    return path.join(process.cwd(), dir);
}
async function getTemplates(templatePath) {
    const navConfig = require(path.join(process.cwd(), 'nav.config.json'));
    const templates = getTemplateDirectories(resolve(path.join('src', templatePath)), navConfig[0]);
    (0, lock_1.updateLockFile)();
    return templates;
}
exports.getTemplates = getTemplates;
function replaceEntryTemplate(subPath, payload) {
    const { listModuleStr, importModuleStr, listComponentStr, importComponentStr, installComponentStr } = payload;
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/listModuleStr/g, listModuleStr)
        .replace(/importModuleStr/g, importModuleStr)
        .replace(/listComponentStr/g, listComponentStr)
        .replace(/importComponentStr/g, importComponentStr)
        .replace(/installComponentStr/g, installComponentStr);
}
function tsEntryTemplate(payload, isCustomEntryPath) {
    const { vueVersionMap } = (0, common_1.getVueVersion)();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/entry.txt' : '../template/vue_pc_ts/entry.txt';
    return replaceEntryTemplate(isCustomEntryPath ? path.join(process.cwd(), './entry.txt') : path.join(__dirname, vueTplPath), payload);
}
exports.tsEntryTemplate = tsEntryTemplate;
function esEntryTemplate(payload) {
    return replaceEntryTemplate('../template/vue_pc_es/entry.txt', payload);
}
exports.esEntryTemplate = esEntryTemplate;
function replaceComponentTemplate(subPath, exportName, componentClassName) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentClassName/g, componentClassName);
}
function tsComponentTemplate(exportName, componentClassName) {
    const { vueVersionMap } = (0, common_1.getVueVersion)();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/component.txt' : '../template/vue_pc_ts/component.txt';
    return replaceComponentTemplate(vueTplPath, exportName, componentClassName);
}
exports.tsComponentTemplate = tsComponentTemplate;
function esComponentTemplate(exportName, componentClassName) {
    return replaceComponentTemplate('../template/vue_pc_es/component.txt', exportName, componentClassName);
}
exports.esComponentTemplate = esComponentTemplate;
function replaceDemoTemplate(subPath, exportName) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName);
}
function esDemoTemplate(exportName) {
    return replaceDemoTemplate('../template/vue_pc_es/demo.txt', exportName);
}
exports.esDemoTemplate = esDemoTemplate;
function tsDemoTemplate(exportName) {
    const { vueVersionMap } = (0, common_1.getVueVersion)();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/demo.txt' : '../template/vue_pc_ts/demo.txt';
    return replaceDemoTemplate(vueTplPath, exportName);
}
exports.tsDemoTemplate = tsDemoTemplate;
function replaceRegistryTemplate(subPath, exportName, componentName) {
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/fileName/g, componentName);
}
function esRegistryTemplate(exportName, componentName) {
    return replaceRegistryTemplate('../template/vue_pc_es/registry.txt', exportName, componentName);
}
exports.esRegistryTemplate = esRegistryTemplate;
function tsRegistryTemplate(exportName, componentName) {
    const { vueVersionMap } = (0, common_1.getVueVersion)();
    const vueTplPath = vueVersionMap === 3 ? '../template/vue3_pc_ts/registry.txt' : '../template/vue_pc_ts/registry.txt';
    return replaceRegistryTemplate(vueTplPath, exportName, componentName);
}
exports.tsRegistryTemplate = tsRegistryTemplate;
function testTemplate(exportName, componentName) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/test.txt'))
        .toString()
        .replace(/exportName/g, exportName)
        .replace(/componentName/g, componentName);
}
exports.testTemplate = testTemplate;
function componentDocTemplate(componentName, cnName, maintainer) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/doc.txt'))
        .toString()
        .replace(/componentName/g, componentName)
        .replace(/cnNameVal/g, cnName)
        .replace(/maintainerVal/g, maintainer)
        .replace(/nanoId/g, nanoId.nanoid());
}
exports.componentDocTemplate = componentDocTemplate;
function typeDefTemplate(exportName) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/typeDef.txt'))
        .toString()
        .replace(/exportName/g, exportName);
}
exports.typeDefTemplate = typeDefTemplate;
function sassTemplate(className) {
    return fs
        .readFileSync(path.join(__dirname, '../template/common/sass.txt'))
        .toString()
        .replace(/className/g, className);
}
exports.sassTemplate = sassTemplate;
