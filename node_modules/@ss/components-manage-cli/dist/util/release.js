"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractReleaseInfo = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const api_1 = require("./api");
const child_process_1 = __importDefault(require("child_process"));
const components_manage_tools_1 = require("@ss/components-manage-tools");
const coverage_1 = require("./coverage");
const git_1 = require("./git");
const analyze_1 = require("./analyze");
const fetch_1 = require("./fetch");
const common_1 = require("./common");
const nav_1 = require("./nav");
const constant_1 = require("./constant");
async function getNpmInfo(cwd) {
    const packageJSONPath = path_1.default.join(cwd, 'package.json');
    if (!fs_1.default.existsSync(packageJSONPath)) {
        throw new Error('package.json not exists ðŸ‘¿');
    }
    const packageJSONStr = fs_1.default.readFileSync(packageJSONPath).toString();
    try {
        const packageJSON = JSON.parse(packageJSONStr);
        const git = await (0, git_1.gitURL)(cwd);
        return {
            git: git || '',
            cmVersion: (0, common_1.getCMVersion)(),
            name: packageJSON.name || '',
            desc: packageJSON.desc || '',
            npmName: packageJSON.name || '',
            keyword: packageJSON.keyword || '',
            version: packageJSON.version || '',
            scaffoldVersion: packageJSON.scaffoldVersion || '',
        };
    }
    catch (e) {
        throw new Error(e);
    }
}
async function extractReleaseInfo(options = {}) {
    const token = (0, components_manage_tools_1.checkLogin)();
    const { id } = (0, common_1.inspectTemplate)();
    const cwd = process.cwd();
    const { platform, framework } = (0, common_1.readProgramConfig)(cwd);
    const branch = await (0, git_1.checkGitStatus)(cwd, options);
    const commitInfo = {
        branch,
        version: JSON.parse(fs_1.default.readFileSync(path_1.default.join(cwd, 'package.json'), 'utf-8')).version
    };
    if (!options.skipVersion) {
        const lastVersion = await (0, fetch_1.lastReleaseVersion)(id);
        const version = await (0, fetch_1.confirmReleaseVersion)({
            id,
            lastVersion,
        });
        commitInfo['version'] = version;
    }
    const npmInfo = await getNpmInfo(cwd);
    const componentsInfo = {};
    let packageDep = {}, coverage = {};
    if (options.releaseType !== 'lowcode') {
        (0, components_manage_tools_1.infoLog)('ä¾èµ–ä¿¡æ¯æå–ä¸­ðŸš€');
        const packageDep = await (0, analyze_1.analyzePackageDep)(cwd);
        const componentsDep = await (0, analyze_1.analyzeCompDep)(cwd, framework, packageDep);
        (0, components_manage_tools_1.successLog)('ä¾èµ–ä¿¡æ¯æå–æˆåŠŸâœ…');
        const components = {};
        Object.keys(componentsDep).forEach(component => {
            components[component] = component;
        });
        let screenshots = {};
        if (!options.skipScreenshot && platform !== 'mobile') {
            (0, components_manage_tools_1.infoLog)('æˆªå›¾ç”Ÿæˆä¸­ðŸŒ„');
            await (0, components_manage_tools_1.startScreenShot)({
                cwd,
                components,
                framework,
                screenShotsPrefix: constant_1.SCREEN_SHOTS_PREFIX,
                execBuffer: constant_1.execBuffer,
                screenShotsPort: options.screenshotPort,
                materialType: 'componentLib'
            });
            (0, components_manage_tools_1.successLog)('æˆªå›¾ç”ŸæˆæˆåŠŸâœ…');
            (0, components_manage_tools_1.infoLog)('ä¸Šä¼ æˆªå›¾ä¸­âœˆï¸');
            screenshots = await (0, components_manage_tools_1.uploadScreenShots)(cwd, components, constant_1.SCREEN_SHOTS_PREFIX, 'componentLib');
            child_process_1.default.execSync(`rm -rf ${constant_1.SCREEN_SHOTS_PREFIX}`, { cwd });
            (0, components_manage_tools_1.successLog)('æˆªå›¾ä¸Šä¼ æˆåŠŸâœ…ï¸');
        }
        (0, components_manage_tools_1.infoLog)('æå–æ–‡æ¡£ä¿¡æ¯ä¸­ðŸ“„');
        const api = (0, api_1.getAPIInfo)(cwd, components);
        const code = (0, api_1.getCodeInfo)(cwd, components);
        (0, components_manage_tools_1.successLog)('æ–‡æ¡£ä¿¡æ¯æå–æˆåŠŸâœ…');
        if (!options.skipTest && platform !== 'mobile' && framework !== 'react') {
            (0, components_manage_tools_1.infoLog)('æå–æµ‹è¯•è¦†ç›–çŽ‡ä¿¡æ¯â˜•ï¸');
            if (process.env.DISABLE_UNIT_TEST !== 'true') {
                coverage = (0, coverage_1.collectCoverage)();
            }
            (0, components_manage_tools_1.successLog)('æµ‹è¯•è¦†ç›–çŽ‡ä¿¡æ¯æå–æˆåŠŸâœ…');
        }
        Object.entries(api).forEach(([name, apiInfo]) => {
            const tagName = (0, common_1.formatComponentName)(name);
            componentsInfo[tagName] = {
                doc: apiInfo,
                screenshots: screenshots[name] || '',
                componentDep: componentsDep[name],
                testCoverage: coverage[tagName] || {
                    line: '0%',
                    statement: '0%',
                },
            };
        });
        Object.entries(code).forEach(([name, codeInfo]) => {
            const tagName = (0, common_1.formatComponentName)(name);
            componentsInfo[tagName] = {
                ...componentsInfo[tagName],
                code: codeInfo
            };
        });
    }
    const message = await (0, git_1.gitStatusMessage)(cwd);
    if (message.includes('Changes not staged for commit') || message.includes('Changes to be committed')) {
        await (0, fetch_1.commitReleaseVersion)(commitInfo);
    }
    const lastCommitMessage = await (0, git_1.lastCommit)(cwd);
    const componentNavInfo = (0, nav_1.readComponentsNavInfo)(path_1.default.join(cwd, 'nav.config.json'));
    const docNavInfo = (0, nav_1.readDocNavInfo)({
        platform,
        framework,
        filePath: path_1.default.join(cwd, 'doc.config.json'),
    });
    return {
        id,
        token,
        branch,
        commit: lastCommitMessage,
        techStack: framework,
        testCoverage: coverage.total,
        packageDep,
        docNav: docNavInfo,
        componentNav: componentNavInfo,
        components: componentsInfo,
        ...npmInfo,
    };
}
exports.extractReleaseInfo = extractReleaseInfo;
