"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishLowcode = exports.buildLowcode = exports.buildLowcodeLocal = void 0;
const fs = require('fs');
const path = require('path');
const upperCamelCase = require('uppercamelcase');
const components_manage_tools_1 = require("@ss/components-manage-tools");
const common_1 = require("../util/common");
const release_1 = require("../util/release");
const execSync = require('child_process').execSync;
function buildLowcodeLocal() {
    const configPath = path.join(__dirname, '../lowcode/lowcode.config.js');
    try {
        execSync(`npx webpack server --config ${configPath}`, { stdio: 'inherit' });
    }
    catch (error) {
        (0, components_manage_tools_1.fatalLog)(error);
    }
}
exports.buildLowcodeLocal = buildLowcodeLocal;
function buildLowcode() {
    tscLowcode();
}
exports.buildLowcode = buildLowcode;
function tscLowcode() {
    try {
        execSync('cp node_modules/@ss/type-material/tsconfig.lowcode.json tsconfig.lowcode.json', { maxBuffer: 10 * 1000 * 1024 });
        execSync('npx tsc --project tsconfig.lowcode.json', { maxBuffer: 10 * 1000 * 1024 });
        replaceLowcodeWebpackConfigTemplate();
        execSync('npx --max_old_space_size=8192 webpack --config lowcode.webpack.config.js', { maxBuffer: 10 * 1000 * 1024 });
        console.log('----- execSync end -----');
        process.exit(0);
    }
    catch (error) {
        (0, components_manage_tools_1.fatalLog)(error);
    }
}
function replaceLowcodeWebpackConfigTemplate() {
    const programPath = process.cwd();
    const OUTPUT_PATH = path.join(programPath, './lowcode.webpack.config.js');
    const MtdConfig = require(path.join(programPath, './mtd.config.js'));
    const subPath = '../template/lowcode/lowcodeWebpackConfig.txt';
    const template = fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/LowcodeType/g, MtdConfig.lowcode.outputName);
    console.log("template content is", template);
    fs.writeFileSync(OUTPUT_PATH, template);
    console.log('[build lowcode] DONE:', OUTPUT_PATH);
}
function replaceLowcodeEntryTemplate(componentMetas) {
    const importComponentMetaStr = componentMetas
        .map(item => {
        const itemName = upperCamelCase(item);
        return `import ${itemName} from './${item}/meta';`;
    })
        .join('\n');
    const listComponentMetaStr = componentMetas.map(item => upperCamelCase(item)).join(',\n    ') + ',';
    const subPath = '../template/lowcode/entry.txt';
    return fs
        .readFileSync(path.join(__dirname, subPath))
        .toString()
        .replace(/importComponentMetaStr/g, importComponentMetaStr)
        .replace(/listComponentMetaStr/g, listComponentMetaStr);
}
function buildLowcodeEntry() {
    const programPath = process.cwd();
    const lowcodePath = path.join(programPath, './lowcode');
    const OUTPUT_PATH = path.join(programPath, './lowcode/index.ts');
    const metaFiles = fs.readdirSync(lowcodePath);
    const componentMetas = [];
    metaFiles.forEach(function (item, index) {
        let stat = fs.lstatSync(path.join(lowcodePath, item));
        if (stat.isDirectory()) {
            componentMetas.push(item);
        }
    });
    const tsTemplate = replaceLowcodeEntryTemplate(componentMetas);
    fs.writeFileSync(OUTPUT_PATH, tsTemplate);
    console.log('[build lowcode:entry] DONE:', OUTPUT_PATH);
}
const publishLowcode = async (options) => {
    options.skipVersion = true;
    options.releaseType = 'lowcode';
    if (options.skipCheck) {
        options.skipCheckBranch = true;
        options.skipTest = true;
    }
    const dir = process.cwd();
    (0, common_1.checkDocAPI)(dir);
    const data = await (0, release_1.extractReleaseInfo)(options);
    data.releaseType = 'lowcode';
    data.materialVersion = (0, common_1.getMaterialVersion)();
    await (0, components_manage_tools_1.publishLowcodeApi)(data);
};
exports.publishLowcode = publishLowcode;
