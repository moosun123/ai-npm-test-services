import { scrollTop, findComponentsDownward, sharpMatcherRegx } from '@ss/mtd-vue/es/utils/util';
import MtdAffix from '@ss/mtd-vue/es/components/affix';
import { CONFIG_PROVIDER, getPrefixCls } from '@ss/mtd-vue/es/utils/config';

import { on, off } from '@ss/mtd-vue/es/utils/dom';
var __vue_render__ = function __vue_render__() {
  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.wrapperComponent, { tag: "component", attrs: { "offset-top": _vm.offsetTop, "offset-bottom": _vm.offsetBottom, "get-target": _vm.affix ? _vm.getAffixTarget : undefined }, on: { "change": _vm.handleAffixStateChange } }, [_c('div', { class: _vm.prefix + "-wrapper", style: _vm.wrapperStyle }, [_c('div', { class: _vm.prefix }, [_c('div', { class: _vm.prefix + "-ink " + _vm.prefix + "-ink-" + _vm.placement }, [_c('span', { directives: [{ name: "show", rawName: "v-show", value: _vm.showInk && _vm.inkVisible, expression: "showInk && inkVisible" }], class: _vm.prefix + "-ink-ball", style: { top: _vm.inkTop + "px" } })]), _vm._t("default")], 2)])]);
};
var __vue_staticRenderFns__ = [];

export default {
  render: __vue_render__,

  staticRenderFns: __vue_staticRenderFns__,

  name: 'MtdAnchor',
  provide: function provide() {
    return {
      anchorCom: this
    };
  },

  components: {
    MtdAffix: MtdAffix
  },
  inheritAttrs: false,
  props: {
    affix: {
      type: Boolean,
      default: true
    },
    offsetTop: {
      type: Number,
      default: 0
    },
    offsetBottom: Number,
    bounds: {
      type: Number,
      default: 5
    },
    container: null,
    showInk: {
      type: Boolean,
      default: true
    },
    scrollOffset: {
      type: Number,
      default: 0
    },
    placement: {
      type: String,
      default: 'left',
      validator: function validator(v) {
        return !v || ['left', 'right'].indexOf(v) !== -1;
      }
    }
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls: getPrefixCls
      }
    }
  },
  data: function data() {
    return {
      isAffixed: false, // current affixed state
      inkTop: 0,
      inkVisible: false,
      animating: false, // if is scrolling now
      currentLink: '', // current show link =>  #href -> currentLink = #href
      currentId: '', // current show title id =>  #href -> currentId = href
      scrollContainer: null,
      scrollElement: null,
      titlesOffsetArr: [],
      wrapperTop: 0,
      upperFirstTitle: true
    };
  },

  computed: {
    prefix: function prefix() {
      return this.config.getPrefixCls('anchor');
    },
    wrapperComponent: function wrapperComponent() {
      return this.affix ? 'MtdAffix' : 'div';
    },
    wrapperStyle: function wrapperStyle() {
      return {
        maxHeight: this.offsetTop ? 'calc(100vh - ' + this.offsetTop + 'px)' : '100vh'
      };
    },
    containerIsWindow: function containerIsWindow() {
      return this.scrollContainer === window;
    }
  },
  watch: {
    '$route': function $route() {
      var _this = this;

      this.handleHashChange();
      this.$nextTick(function () {
        _this.handleScrollTo();
      });
    },
    container: function container() {
      this.init();
    },
    currentLink: function currentLink(newHref, oldHref) {
      this.$emit('change', newHref, oldHref);
    }
  },
  mounted: function mounted() {
    this.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.removeListener();
  },

  methods: {
    handleAffixStateChange: function handleAffixStateChange(state) {
      this.isAffixed = this.affix && state;
    },
    handleScroll: function handleScroll(e) {
      if (this.titlesOffsetArr[0]) {
        this.upperFirstTitle = e.target.scrollTop < this.titlesOffsetArr[0].offset;
      }
      if (this.animating) return;
      this.updateTitleOffset();
      var scrollTop = (document.documentElement.scrollTop || document.body.scrollTop || e.target.scrollTop) + this.scrollOffset;
      this.getCurrentScrollAtTitleId(scrollTop);
    },
    handleHashChange: function handleHashChange() {
      var url = window.location.href;
      var sharpLinkMatch = sharpMatcherRegx.exec(url);
      if (!sharpLinkMatch) {
        this.currentLink = null;
        this.currentId = null;
      } else {
        this.currentLink = sharpLinkMatch[0];
        this.currentId = sharpLinkMatch[1];
      }
    },
    handleScrollTo: function handleScrollTo() {
      var _this2 = this;

      if (!this.currentId) return;
      var anchor = document.getElementById(this.currentId);
      if (!anchor) return;
      var currentLinkElementA = this.$el.querySelector('a[data-href="' + this.currentLink + '"]');
      var offset = this.scrollOffset;
      if (!currentLinkElementA) {
        this.handleSetInkTop();
        return;
      }
      offset = parseFloat(currentLinkElementA.getAttribute('data-scroll-offset'));

      var offsetTop = anchor.offsetTop - this.wrapperTop - offset;
      this.animating = true;
      scrollTop(this.scrollContainer, this.scrollElement.scrollTop, offsetTop, 600, function () {
        _this2.animating = false;
      });
      this.handleSetInkTop();
    },
    handleSetInkTop: function handleSetInkTop() {
      var currentLinkElementA = this.$el.querySelector('a[data-href="' + this.currentLink + '"]');
      if (!currentLinkElementA) {
        this.inkVisible = false;
        return;
      }
      var elementATop = currentLinkElementA.offsetTop;
      var top = elementATop < 0 ? this.offsetTop : elementATop;
      this.inkTop = top;
      this.inkVisible = true;
    },
    updateTitleOffset: function updateTitleOffset() {
      var _this3 = this;

      var links = findComponentsDownward(this, 'MtdAnchorLink').map(function (link) {
        return link.href;
      });
      var idArr = links.map(function (link) {
        return link.split('#')[1];
      });
      var offsetArr = [];
      idArr.forEach(function (id) {
        var titleEle = document.getElementById(id);
        if (titleEle) {
          offsetArr.push({
            link: '#' + id,
            offset: titleEle.offsetTop - _this3.scrollElement.offsetTop
          });
        }
      });
      this.titlesOffsetArr = offsetArr;
    },
    getAffixTarget: function getAffixTarget() {
      return this.container ? typeof this.container === 'string' ? document.querySelector(this.container) : this.container : window;
    },
    getCurrentScrollAtTitleId: function getCurrentScrollAtTitleId(scrollTop) {
      var i = -1;
      var len = this.titlesOffsetArr.length;
      var titleItem = {
        link: '#',
        offset: 0
      };
      scrollTop += this.bounds;
      while (++i < len) {
        var currentEle = this.titlesOffsetArr[i];
        var nextEle = this.titlesOffsetArr[i + 1];
        if (scrollTop >= currentEle.offset && scrollTop < (nextEle && nextEle.offset || Infinity)) {
          titleItem = this.titlesOffsetArr[i];
          break;
        }
      }
      this.currentLink = titleItem.link;
      this.handleSetInkTop();
    },
    getContainer: function getContainer() {
      this.scrollContainer = this.getAffixTarget();
      this.scrollElement = this.container ? this.scrollContainer : document.documentElement || document.body;
    },
    removeListener: function removeListener() {
      off(this.scrollContainer, 'scroll', this.handleScroll);
      off(window, 'hashchange', this.handleHashChange);
    },
    init: function init() {
      var _this4 = this;

      this.handleHashChange();
      this.$nextTick(function () {
        _this4.removeListener();
        _this4.getContainer();
        _this4.wrapperTop = _this4.containerIsWindow ? 0 : _this4.scrollElement.offsetTop;
        _this4.handleScrollTo();
        _this4.handleSetInkTop();
        _this4.updateTitleOffset();
        if (_this4.titlesOffsetArr[0]) {
          _this4.upperFirstTitle = _this4.scrollElement.scrollTop < _this4.titlesOffsetArr[0].offset;
        }
        on(_this4.scrollContainer, 'scroll', _this4.handleScroll);
        on(window, 'hashchange', _this4.handleHashChange);
      });
    }
  }
};