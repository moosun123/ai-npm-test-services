import _defineProperty from 'babel-runtime/helpers/defineProperty';
import { CONFIG_PROVIDER, getPrefixCls } from '@ss/mtd-vue/es/utils/config';
import debounce from 'throttle-debounce/debounce';
import { on, off } from '@ss/mtd-vue/es/utils/dom';
import { addResizeListener, removeResizeListener } from '@ss/mtd-vue/es/utils/resize-event';

function getScroll(target, top) {
  var prop = top ? 'pageYOffset' : 'pageXOffset';
  var method = top ? 'scrollTop' : 'scrollLeft';

  var ret = target[prop];

  if (typeof ret !== 'number') {
    ret = window.document.documentElement[method];
  }

  return ret;
}

function getOffset(element) {
  var rect = element.getBoundingClientRect();

  var scrollTop = getScroll(window, true);
  var scrollLeft = getScroll(window);

  var docEl = window.document.body;
  var clientTop = docEl.clientTop || 0;
  var clientLeft = docEl.clientLeft || 0;
  // clientTop和clientLeft兼容性比较好，不需要修改
  return {
    top: rect.top + scrollTop - clientTop,
    left: rect.left + scrollLeft - clientLeft
  };
}

var __vue_render__ = function __vue_render__() {
  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', [_c('div', { ref: "point", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2), _c('div', { directives: [{ name: "show", rawName: "v-show", value: _vm.slot, expression: "slot" }], style: _vm.placeHolderStyle })]);
};
var __vue_staticRenderFns__ = [];

export default {
  render: __vue_render__,

  staticRenderFns: __vue_staticRenderFns__,

  name: 'MtdAffix',
  props: {
    offsetTop: {
      type: Number,
      default: 0
    },
    offsetBottom: {
      type: Number
    },
    debounce: {
      type: Number,
      default: 0
    },
    getTarget: {
      type: Function
    }
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls: getPrefixCls
      }
    }
  },
  data: function data() {
    return {
      affix: false,
      styles: {},
      slot: false,
      placeHolderStyle: {},
      containerEl: null
    };
  },

  computed: {
    offsetType: function offsetType() {
      return this.offsetBottom >= 0 ? 'bottom' : 'top';
    },
    classes: function classes() {
      return [_defineProperty({}, this.config.getPrefixCls('affix'), this.affix)];
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.containerEl = this.getTarget ? this.getTarget() : window;
    if (this.containerEl) {
      on(this.containerEl, 'scroll', this.debounceScroll);
      // 当窗口缩放时也需要重新触发,以调整affix的宽度
      addResizeListener(this.$el, this.debounceScroll);
      this.$nextTick(function () {
        _this.debounceScroll();
      });
    } else {
      console.warn('MTD[Affix]: getTarget prop must return an HTMLElement');
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.containerEl) {
      off(this.containerEl, 'scroll', this.debounceScroll);
      removeResizeListener(this.$el, this.debounceScroll);
    }
  },

  methods: {
    handleScroll: function handleScroll() {
      var affix = this.affix;
      var scrollTop = getScroll(this.containerEl, true);
      var elOffset = getOffset(this.$el);
      var containerHeight = this.containerEl === window ? window.innerHeight || document.body.clientHeight : this.containerEl.getBoundingClientRect().height;

      var elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight;
      if (affix) {
        if (this.offsetType === 'top') {
          if (elOffset.top - this.offsetTop > scrollTop) {
            this.slot = false;
            this.placeHolderStyle = {};
            this.affix = false;
            this.styles = null;
            this.$emit('change', false);
          } else {
            var containerRect = this.$el.getBoundingClientRect();
            // 虽然已经固定,但是窗口可能被缩放,因此要实时更新元素宽度以适应缩放
            this.styles.width = containerRect.width + 'px';
            this.placeHolderStyle.width = containerRect.width + 'px';
          }
        } else if (this.offsetType === 'bottom') {
          if (elOffset.top + this.offsetBottom + elHeight < scrollTop + containerHeight) {
            this.slot = false;
            this.placeHolderStyle = {};
            this.affix = false;
            this.styles = null;
            this.$emit('change', false);
          } else {
            var _containerRect = this.$el.getBoundingClientRect();
            // 虽然已经固定,但是窗口可能被缩放,因此要实时更新元素宽度以适应缩放
            this.styles.width = _containerRect.width + 'px';
            this.placeHolderStyle.width = _containerRect.width + 'px';
          }
        }
      } else {
        if (this.offsetType === 'top') {
          if (elOffset.top - this.offsetTop < scrollTop) {
            var pointRect = this.$refs.point.getBoundingClientRect();
            var _containerRect2 = this.$el.getBoundingClientRect();
            this.affix = true;
            this.placeHolderStyle = {
              width: pointRect.width + 'px',
              height: pointRect.height + 'px'
            };
            this.slot = true;
            this.styles = {
              top: this.offsetTop + 'px',
              width: _containerRect2.width + 'px'
            };
            this.$emit('change', true);
          }
        } else if (this.offsetType === 'bottom') {
          if (elOffset.top + this.offsetBottom + elHeight > scrollTop + containerHeight) {
            var _pointRect = this.$refs.point.getBoundingClientRect();
            var _containerRect3 = this.$el.getBoundingClientRect();
            this.affix = true;
            this.placeHolderStyle = {
              width: _pointRect.width + 'px',
              height: _pointRect.height + 'px'
            };
            this.slot = true;
            this.styles = {
              bottom: this.offsetBottom + 'px',
              width: _containerRect3.width + 'px'
            };
            this.$emit('change', true);
          }
        }
      }
    },
    debounceScroll: function debounceScroll() {
      if (this.debounce) {
        debounce(this.debounce, this.handleScroll)();
      } else {
        this.handleScroll();
      }
    }
  }
};