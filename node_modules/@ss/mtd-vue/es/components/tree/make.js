import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import createHoc from '@ss/mtd-vue/es/utils/hoc';

export default function createTreeNode(name, Component) {
  var namedComponent = createHoc({
    name: name,
    inject: ['tree'],
    props: {
      node: {
        type: Object,
        required: true
      },
      data: {
        type: Object,
        required: true
      }
    },
    computed: {
      expandOnClickNode: function expandOnClickNode() {
        return this.tree.expandOnClickNode;
      },
      checkOnClickNode: function checkOnClickNode() {
        return this.tree.checkOnClickNode;
      },
      indent: function indent() {
        return this.tree.baseIndent + this.tree.indent * this.node.level;
      },
      loadData: function loadData() {
        return this.tree.loadData;
      }
    },
    methods: {
      handleExpanded: function handleExpanded() {
        var _tree;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_tree = this.tree).$emit.apply(_tree, ['expandedChange'].concat(_toConsumableArray(args)));
      },
      handleChecked: function handleChecked() {
        var _tree2;

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        (_tree2 = this.tree).$emit.apply(_tree2, ['checkedChange'].concat(_toConsumableArray(args)));
      },
      handleLoadData: function handleLoadData() {
        var _tree3;

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        (_tree3 = this.tree).$emit.apply(_tree3, ['loadedData'].concat(_toConsumableArray(args)));
      },
      handleSelected: function handleSelected() {
        var _tree4;

        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        (_tree4 = this.tree).$emit.apply(_tree4, ['selectedNode'].concat(_toConsumableArray(args)));
      },
      handleNodeClick: function handleNodeClick() {
        var _tree5;

        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        (_tree5 = this.tree).$emit.apply(_tree5, ['nodeClick'].concat(_toConsumableArray(args)));
      }
    }
  }, {
    mapStateToProps: function mapStateToProps(context) {
      return {
        node: context.node,
        data: context.data,
        expandOnClickNode: context.expandOnClickNode,
        checkOnClickNode: context.checkOnClickNode,
        indent: context.indent,
        loadData: context.loadData,
        expandIcon: context.tree._expandIcon,
        selectable: context.tree.selectable,
        nodeClass: context.tree.nodeClass,
        draggable: context.tree.draggable
      };
    },
    mapMethodToListener: function mapMethodToListener(context) {
      return {
        'expandedChange': context.handleExpanded,
        'checkedChange': context.handleChecked,
        'loadedData': context.handleLoadData,
        'selected': context.handleSelected,
        'node-click': context.handleNodeClick,
        'tree-node-drag-start': context.tree.handleDragStart,
        'tree-node-drag-over': context.tree.handleDragOver,
        'tree-node-drag-end': context.tree.handleDragEnd
      };
    },
    getScopedSlots: function getScopedSlots(context) {
      return context.tree.$scopedSlots;
    }
  })(Component);

  // 防止使用局部注册组件时，找不到组件
  Component.components = Component.components || {};
  if (Component.components[name]) {
    console.warn('[MTD warn][makeTreeNode]: ' + name + 'components has the same name components dependency');
  } else {
    Component.components[name] = namedComponent;
  }
  return namedComponent;
}