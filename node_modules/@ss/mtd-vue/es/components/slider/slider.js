import _extends from 'babel-runtime/helpers/extends';
import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import MtdSliderButton from './button';
import { CONFIG_PROVIDER, getPrefixCls, getSize } from '@ss/mtd-vue/es/utils/config';

var __vue_render__ = function __vue_render__() {
  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "sliderWrapper", class: _vm.wrapperClass, on: { "click": _vm.handleClick } }, [!_vm.thresholds ? _c('div', { class: _vm.prefix + "-bar", style: _vm.vertical ? { height: _vm.bars.w, bottom: _vm.bars.x } : { width: _vm.bars.w, left: _vm.bars.x } }) : _vm._e(), _vm.fixedValue ? _c('div', { class: _vm.prefix + "-fixed-bar", style: _vm.vertical ? { height: _vm.getPercent(_vm.fixedValue) } : { width: _vm.getPercent(_vm.fixedValue) } }) : _vm._e(), _vm._l(_vm.internalValue, function (item, i) {
    return _c('mtd-slider-button', { key: 'button-' + i, attrs: { "prefix": _vm.prefix, "value": item, "type": i, "vertical": _vm.vertical, "format-tooltip": _vm.formatTooltip, "get-percent": _vm.getPercent }, on: { "change": _vm.handleChange, "dragging": _vm.handleButtonDragging, "drag-end": _vm.handleDragEnd } }, [_vm._t("handler")], 2);
  }), _vm.dots ? _vm._l(_vm.dots, function (item) {
    return _c('div', { key: 'stop-' + item, class: _vm.prefix + "-stop", style: _vm.vertical ? { bottom: _vm.getPercent(item) } : { left: _vm.getPercent(item) } });
  }) : _vm._e(), _vm.tracks ? _c('div', { class: _vm.prefix + "-tracks" }, [_vm.range ? _c('div', { class: _vm.prefix + "-track " + _vm.prefix + "-track-left", style: _vm.vertical ? { height: (_vm.minValue - _vm.min) * 100 / _vm.wholeLength + "%" } : { width: (_vm.minValue - _vm.min) * 100 / _vm.wholeLength + "%" } }) : _vm._e(), _vm._l(_vm.tracks, function (item, index) {
    return _c('div', { key: 'track-' + index, class: _vm.prefix + "-track", style: _vm.vertical ? { height: item.w, bottom: item.x,
        backgroundColor: item.color } : { width: item.w, left: item.x,
        backgroundColor: item.color } });
  }), _c('div', { class: _vm.prefix + "-track " + _vm.prefix + "-track-right", style: _vm.vertical ? { height: 100 - (_vm.maxValue - _vm.min) * 100 / _vm.wholeLength + "%" } : { width: 100 - (_vm.maxValue - _vm.min) * 100 / _vm.wholeLength + "%" } })], 2) : _vm._e(), _c('div', { class: _vm.prefix + "-mark", style: _vm.vertical ? { height: '100%' } : { width: '100%' } }, _vm._l(_vm.markTexts, function (item, index) {
    return _c('span', { key: 'mark-' + index, class: _vm.prefix + "-mark-text", style: _vm.vertical ? { bottom: (item.value - _vm.min) * 100 / _vm.wholeLength + "%" } : { left: (item.value - _vm.min) * 100 / _vm.wholeLength + "%" } }, [_vm._v(_vm._s(item.label))]);
  }), 0)], 2);
};
var __vue_staticRenderFns__ = [];

export default {
  render: __vue_render__,

  staticRenderFns: __vue_staticRenderFns__,

  name: 'MtdSlider',
  components: {
    MtdSliderButton: MtdSliderButton
  },
  model: {
    prop: 'value'
  },
  props: {
    size: {
      type: String
    },
    marks: {
      type: Object
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    value: {
      type: [Number, Array]
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    step: Number,
    steps: Array,
    thresholds: {
      type: Object
    },
    fixedValue: {
      type: Number
    },
    formatTooltip: Function
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls: getPrefixCls,
        getSize: getSize
      }
    }
  },
  data: function data() {
    return {
      dragging: false,
      tip: false,
      internalValue: []
    };
  },

  computed: {
    prefix: function prefix() {
      return this.config.getPrefixCls('slider');
    },
    _size: function _size() {
      return this.config.getSize(this);
    },
    minValue: function minValue() {
      return Math.max(Math.min.apply(Math, _toConsumableArray(this.internalValue)), this.min);
    },
    maxValue: function maxValue() {
      return Math.min(Math.max.apply(Math, _toConsumableArray(this.internalValue)), this.max);
    },
    bars: function bars() {
      var min = this.range ? this.minValue : this.min;
      return {
        w: this.getPercent(this.maxValue - min, 0),
        x: this.range ? this.getPercent(this.minValue) : 0
      };
    },
    dots: function dots() {
      var _this = this;

      var step = this.step,
          steps = this.steps;

      if ((!step || step < 0) && !steps) {
        return;
      }
      var arr = step ? [] : steps;
      if (step) {
        var min = this.min,
            max = this.max;

        var n = min + step;
        while (n < max) {
          arr.push(n);
          n = n + step;
        }
      }
      arr = arr.filter(function (v) {
        return v > _this.min && v < _this.max;
      });
      return arr;
    },
    markTexts: function markTexts() {
      var _this2 = this;

      var arr = void 0;
      if (this.marks) {
        arr = _Object$keys(this.marks).map(function (m) {
          return {
            value: m,
            label: _this2.marks[m] || m
          };
        });
      } else {
        arr = [this.min, this.max];
        if (this.fixedValue) {
          arr = [this.fixedValue].concat(_toConsumableArray(arr));
        }
        if (this.dots) {
          arr = [].concat(_toConsumableArray(this.dots), _toConsumableArray(arr));
        }
        if (this.thresholds) {
          arr = [].concat(_toConsumableArray(this.thresholds.values), _toConsumableArray(arr));
        }
        arr = arr.map(function (v) {
          return { value: v, label: v };
        });
      }
      arr = arr.sort(function (a, b) {
        return a.value - b.value;
      }).filter(function (v, i) {
        return (!arr[i + 1] || v.value !== arr[i + 1].value) && v.value >= _this2.min && v.value <= _this2.max;
      });
      return arr;
    },
    wholeLength: function wholeLength() {
      return this.max - this.min;
    },
    curFixedValue: function curFixedValue() {
      return this.fixedValue || this.min;
    },
    wrapperClass: function wrapperClass() {
      var _ref;

      var prefix = this.prefix;

      return [prefix, [(_ref = {}, _defineProperty(_ref, prefix + '-disabled', this.disabled), _defineProperty(_ref, prefix + '-vertical', this.vertical), _defineProperty(_ref, prefix + '-' + this._size, this._size), _ref)]];
    },
    tracks: function tracks() {
      var _this3 = this;

      if (this.thresholds) {
        var begin = this.min;
        return this.thresholds.values.map(function (v, index) {
          var range = _extends({
            value: v,
            color: _this3.thresholds.colors[index]
          }, _this3.getRange(begin, v));
          begin = v;
          return range;
        });
      }
      return undefined;
    }
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler() {
        this.syncValue();
      }
    },
    range: {
      handler: function handler() {
        this.syncValue();
      }
    }
  },
  methods: {
    syncValue: function syncValue() {
      if (this.range) {
        this.internalValue = [].concat(_toConsumableArray(this.value));
        this.internalValue.length = 2;
      } else {
        this.internalValue = [this.value];
      }
      for (var i = 0; i < this.internalValue.length; i++) {
        // can't use .map()
        var v = this.internalValue[i];
        this.internalValue[i] = !v && v !== 0 ? this.min : v;
      }
    },
    getPercent: function getPercent(value) {
      var beign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.min;

      var n = (value - beign) * 100 / this.wholeLength;
      if (n < 0) {
        n = 0;
      } else if (n > 100) {
        n = 100;
      }
      return n + '%';
    },
    getRange: function getRange(start, end) {
      return {
        w: this.getPercent(end - start, 0), // range size
        x: this.getPercent(start) // x: vertical ? bottom : left
      };
    },
    handleClick: function handleClick(e) {
      if (this.dragging) {
        return;
      }
      this.vertical ? this.setPositionY(e) : this.setPositionX(e);
      this.handleChange();
    },
    handleButtonDragging: function handleButtonDragging(e, type) {
      this.dragging = true;
      this.vertical ? this.setPositionY(e, type) : this.setPositionX(e, type);
    },
    handleDragEnd: function handleDragEnd(e, type) {
      this.dragging = false;
    },
    parseValue: function parseValue(value) {
      return parseInt(value); // todo 解决精度问题
    },
    setValue: function setValue(offset, type) {
      var dot = this.getNearestStop(offset);
      var value = dot !== undefined ? dot : this.parseValue(this.min + offset * this.wholeLength);

      var index = type === undefined ? this.getNearestButtonType(value) : type;
      this.$set(this.internalValue, index, value);
    },
    setPositionX: function setPositionX(e, type) {
      if (this.disabled) {
        return;
      }
      var start = this.$refs.sliderWrapper.getBoundingClientRect().left;
      var fixedValue = start + Math.round((this.curFixedValue - this.min) / this.wholeLength * this.$refs.sliderWrapper.clientWidth);
      var end = this.$refs.sliderWrapper.getBoundingClientRect().right;
      var current = e.clientX;
      var offset = void 0;
      if (current <= fixedValue) {
        offset = (this.curFixedValue - this.min) / this.wholeLength;
      } else if (e.clientX >= end) {
        offset = 1;
      } else {
        offset = (current - start) / this.$refs.sliderWrapper.clientWidth;
      }
      this.setValue(offset, type);
    },
    setPositionY: function setPositionY(e, type) {
      if (this.disabled) {
        return;
      }
      var start = this.$refs.sliderWrapper.getBoundingClientRect().bottom;
      var fixedValue = start - Math.round((this.curFixedValue - this.min) / this.wholeLength * this.$refs.sliderWrapper.clientHeight);
      var end = this.$refs.sliderWrapper.getBoundingClientRect().top;
      var current = e.clientY;
      var offset = void 0;
      if (current >= fixedValue) {
        offset = (this.curFixedValue - this.min) / this.wholeLength;
      } else if (current <= end) {
        offset = 1;
      } else {
        offset = (start - current) / this.$refs.sliderWrapper.clientHeight;
      }
      this.setValue(offset, type);
    },
    getNearestButtonType: function getNearestButtonType(value) {
      var vs = this.internalValue.map(function (v, i) {
        return {
          index: i,
          diff: Math.abs(v - value)
        };
      });
      vs.sort(function (a, b) {
        return a.diff - b.diff;
      });
      return vs[0] ? vs[0].index : 1;
    },
    getNearestStop: function getNearestStop(offset) {
      if (!this.dots) {
        return undefined;
      };
      var value = offset * this.wholeLength + this.min;
      var orders = [this.min, this.max, value].concat(_toConsumableArray(this.dots)).sort(function (a, b) {
        return a - b;
      });
      var index = orders.indexOf(value);
      var next = index === orders.length ? this.max : orders[index + 1];
      var pre = index === 0 ? this.min : orders[index - 1];
      return Math.abs(next - value) > Math.abs(pre - value) ? pre : next;
    },
    handleChange: function handleChange() {
      var _this4 = this;

      var value = this.internalValue.sort(function (a, b) {
        return a - b;
      });
      if (value.some(function (v, i) {
        return v !== _this4.value[i];
      })) {
        var v = this.range ? value : value[0];
        this.$emit('input', v);
        this.$emit('change', v);
      }
      this.syncValue();
    }
  }
};