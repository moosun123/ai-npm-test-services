<template>
  <div
    :class="[prefix, {
      [`${prefix}-disabled`]: disabled,
    }, rateClass]"
    :aria-valuenow="currentValue"
    :aria-valuetext="text"
    aria-valuemin="0"
    :aria-valuemax="count"
    tabindex="0"
    @mouseleave="resetCurrentValue"
  >
    <mtd-tooltip v-bind="tooltipProps"
      placement="top"
      :class="`${prefix}-item-wrapper`"
      :disabled="disabled || (!$scopedSlots.tooltip && !texts)"
      :close-delay="0" :open-delay="0"
      v-for="item in count"
      :key="item"
    >
      <div slot="content">
        <slot :value="item" name="tooltip">
          {{ texts ? texts[item - 1] : '' }}
        </slot>
      </div>
      <span
        :class="[`${prefix}-item`, getItemClass(item)]"
        @mousemove="setCurrentValue(item, $event)"
        @click="selectValue(item)">
        <i
          :class="[`${prefix}-icon`, iconClasses[item - 1], { 'hover': hoverIndex === item }]"
          :style="getIconStyle(item)" />
        <i v-if="showDecimalIcon(item)"
          :class="[`${prefix}-decimal`, activeIconClass]"
          :style="decimalStyle" />
      </span>
    </mtd-tooltip>
    <span
      v-if="text || $scopedSlots.default"
      :class="`${prefix}-text`">
      <slot :value="value">{{ text }}</slot>
    </span>
  </div>
</template>
<script>
import { isString } from '@/utils/type';
import MtdTooltip from '@components/tooltip';
import { CONFIG_PROVIDER,
  getPrefixCls,
  getIconCls,
} from '@/utils/config';

function parseToKV (v, count) {
  let map = v;
  if (isString(v)) {
    map = {
      [count]: v,
    };
  }
  const keys = Object.keys(map);
  return keys.sort((a, b) => a - b).reduce((s, k) => {
    s[k] = map[k];
    return s;
  }, {});
}

function getValueFromMap (v, map) {
  const keys = Object.keys(map);
  const current = keys.find((key, index) => {
    const next = keys[index + 1];
    return (index === 0 && v < key) || (v >= key && (v < next || !next));
  });
  return map[current];
}

export default {
  name: 'Rate',

  components: {
    MtdTooltip,
  },

  props: {
    value: {
      type: Number,
      default: 0,
    },
    count: {
      type: Number,
      default: 5,
    },
    classes: {
      type: Object,
    },
    icon: {
      type: [String, Object],
    },
    color: {
      type: [String, Object],
    },
    disabled: Boolean,
    voidColor: {
      type: String,
    },
    disabledVoidColor: {
      type: String,
    },
    voidIcon: String,
    disabledVoidIcon: String,
    allowHalf: {
      type: Boolean,
      default: false,
    },
    allowClear: {
      type: Boolean,
      default: false,
    },
    texts: {
      type: Array,
    },
    tooltipProps: {
      type: Object,
      default () {
        return {};
      },
    },
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getIconCls,
      },
    },
  },

  data () {
    return {
      currentValue: this.value,
      hoverIndex: -1,
      pointerAtLeftHalf: false,
    };
  },

  computed: {
    prefix () {
      return this.config.getPrefixCls('rate');
    },
    _icon () {
      return this.icon || this.config.getIconCls('star');
    },
    rateClass () {
      if (this.classes) {
        return getValueFromMap(this.value, this.classes);
      }
      return undefined;
    },

    text () {
      if (this.texts) {
        // todo: 需要和设计确认是否是向上取整
        return this.texts[Math.ceil(this.value) - 1];
      }
      return '';
    },

    valueInteger () {
      return parseInt(this.value);
    },

    valueDecimal () {
      return this.value * 100 - this.valueInteger * 100;
    },

    icons () {
      return parseToKV(this._icon);
    },

    activeIconClass () {
      return getValueFromMap(this.value, this.icons);
    },

    voidIconClass () {
      const icon = this.disabled
        ? this.disabledVoidIcon
        : this.voidIcon;
      return icon || this.activeIconClass;
    },

    iconClasses () {
      const result = [];
      let i = 0;
      let threshold = this.currentValue;
      if (
        this.allowHalf &&
        this.currentValue !== Math.floor(this.currentValue)
      ) {
        threshold--;
      }
      for (; i < threshold; i++) {
        result.push(this.activeIconClass);
      }
      for (; i < this.count; i++) {
        result.push(this.voidIconClass);
      }
      return result;
    },

    colors () {
      return this.color ? parseToKV(this.color) : {};
    },

    activeColor () {
      return getValueFromMap(this.currentValue, this.colors);
    },

    decimalStyle () {
      let width = '';
      if (this.disabled) {
        width = `${this.valueDecimal}%`;
      } else if (this.allowHalf) {
        width = '50%';
      }
      return {
        color: this.activeColor,
        width,
      };
    },

  },

  watch: {
    value: {
      immediate: true,
      handler (val) {
        this.currentValue = val;
        this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
      },
    },
  },

  methods: {
    getIconStyle (item) {
      const voidColor = this.disabled
        ? this.disabledVoidColor
        : this.voidColor;
      const color = item <= this.currentValue ? this.activeColor : voidColor;
      return {
        color,
      };
    },

    getItemClass (itemValue) {
      const { prefix } = this;
      if (this.currentValue !== parseInt(this.currentValue)) {
        // 包含小数
        if (this.currentValue > itemValue) {
          return `${prefix}-item-full`;
        } else if (this.currentValue + 1 > itemValue) {
          return `${prefix}-item-half`;
        }
      } else if (this.currentValue >= itemValue) {
        return `${prefix}-item-full`;
      }
      return '';
    },

    showDecimalIcon (item) {
      const showWhenDisabled = this.disabled &&
        this.valueDecimal > 0 &&
        item - 1 < this.value &&
        item > this.value;
      /* istanbul ignore next */
      const showWhenAllowHalf = this.allowHalf &&
        this.pointerAtLeftHalf &&
        item - 0.5 <= this.currentValue &&
        item > this.currentValue;
      return showWhenDisabled || showWhenAllowHalf;
    },

    setCurrentValue (value, event) {
      if (this.disabled) {
        return;
      }
      /* istanbul ignore if */
      if (this.allowHalf) {
        const target = event.currentTarget;
        this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
        this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
      } else {
        this.currentValue = value;
      }
      this.hoverIndex = value;
    },

    resetCurrentValue () {
      if (this.disabled) {
        return;
      }
      if (this.allowHalf) {
        this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
      }
      this.currentValue = this.value;
      this.hoverIndex = -1;
    },

    selectValue (value) {
      if (this.disabled) {
        return;
      }
      let nextValue = value;
      if (this.allowHalf && this.pointerAtLeftHalf) {
        nextValue = this.currentValue;
      }
      if (this.allowClear && nextValue === this.value) {
        nextValue = 0;
      }
      this.resetCurrentValue();
      this.$emit('input', nextValue);
      this.$emit('change', nextValue);
    },
  },
};
</script>
