<template>
  <div :class="prefix">
    <p :class="`${prefix}-header`">
      <mtd-checkbox
        v-model="allChecked"
        @change="handleAllCheckedChange"
        :is-under-control="false"
        :indeterminate="isIndeterminate">
        {{ title }}
      </mtd-checkbox>
      <span :class="`${transferPrefix}-sum`">{{ checkedSummary }}</span>
    </p>
    <div :class="[
      `${prefix}-body`,
      {'with-footer' : hasFooter }
     ]">
      <mtd-input
        :class="`${prefix}-filter`"
        v-model="query"
        :suffix-icon="iconPrefix('search')"
        :placeholder="placeholder"
        clearable
        v-if="filterable" />
      <mtd-checkbox-group
        v-model="checked"
        v-show="!hasNoMatch && data.length > 0"
        :class="[`${prefix}-list`, { 'is-filterable': filterable }]"
      >
        <mtd-checkbox
          :class="`${prefix}-item`"
          :disabled="item[disabledProp]"
          :value="item[keyProp]"
          :key="item[keyProp]"
          v-for="item in filteredData">
          <template v-if="!$parent.$scopedSlots.default && item">
            {{ item[labelProp] }}
          </template>
          <slot :row="item" v-else />
        </mtd-checkbox>
      </mtd-checkbox-group>
      <p
        :class="`${prefix}-empty`"
        v-show="hasNoMatch">{{ noMatchText }}</p>
      <p
        :class="`${prefix}-empty`"
        v-show="data.length === 0 && !hasNoMatch"
      >
        {{ noDataText }}
      </p>
    </div>
    <div :class="`${prefix}-footer`" v-if="hasFooter">
      <slot name="footer" />
    </div>
  </div>
</template>

<script>
import MtdCheckboxGroup from '@components/checkbox-group';
import MtdCheckbox from '@components/checkbox';
import MtdInput from '@components/input';
import { isFunction } from '@/utils/type';
import {
  CONFIG_PROVIDER,
  getPrefixCls,
  getIconCls,
} from '@/utils/config';

export default {
  name: 'MtdTransferPanel',
  components: {
    MtdCheckboxGroup,
    MtdCheckbox,
    MtdInput,
  },
  componentName: 'MtdTransferPanel',
  props: {
    data: {
      type: Array,
      default () {
        return [];
      },
    },
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: {
      type: Object,
      default () {
        return {};
      },
    },
    filterMethod: Function,
    defaultChecked: Array,
    props: {
      type: Object,
      default () {
        return {};
      },
    },
    noMatchText: {
      type: String,
      default () {
        return '暂无搜索结果';
      },
    },
    noDataText: {
      type: String,
      default () {
        return '暂无数据';
      },
    },
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getIconCls,
      },
    },
  },
  data () {
    return {
      checked: [],
      selected: [],
      allChecked: false,
      query: '',
      checkChangeByUser: true,
    };
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('transfer-panel');
    },
    transferPrefix () {
      return this.config.getPrefixCls('transfer');
    },
    iconPrefix () {
      return this.config.getIconCls;
    },
    filter () {
      return isFunction(this.filterMethod) ? this.filterMethod
        : (query, item) => {
          const label = item[this.labelProp] || item[this.keyProp].toString();
          return label.toLowerCase().indexOf(query.toLowerCase()) > -1;
        };
    },
    filteredData () {
      if (!this.filterable) {
        return this.data;
      }
      return this.data.filter(item => {
        return this.filter(this.query, item);
      });
    },
    checkableData () {
      return this.filteredData.filter(item => !item[this.disabledProp]);
    },
    checkedSummary () {
      const checkedLength = this.checked.length;
      const dataLength = this.data.length;
      const { noChecked, hasChecked } = this.format;
      if (noChecked && hasChecked) {
        return checkedLength > 0
          ? hasChecked.replace(/\${checked}/g, checkedLength)
            .replace(/\${total}/g, dataLength)
          : noChecked.replace(/\${total}/g, dataLength);
      } else {
        return `${checkedLength}/${dataLength}`;
      }
    },
    isIndeterminate () {
      const checkedLength = this.checked.length;
      return checkedLength > 0 && checkedLength < this.checkableData.length;
    },
    hasNoMatch () {
      return this.query.length > 0 && this.filteredData.length === 0;
    },
    labelProp () {
      return this.props.label || 'label';
    },
    keyProp () {
      return this.props.key || 'key';
    },
    disabledProp () {
      return this.props.disabled || 'disabled';
    },
    hasFooter () {
      return !!this.$slots.footer;
    },
  },
  watch: {
    checked (val, oldVal) {
      this.updateAllChecked();
      if (this.checkChangeByUser) {
        const movedKeys = val.concat(oldVal)
          .filter(v => val.indexOf(v) === -1 || oldVal.indexOf(v) === -1);
        this.$emit('checked-change', val, movedKeys);
      } else {
        this.$emit('checked-change', val);
        this.checkChangeByUser = true;
      }
    },
    data () {
      const checked = [];
      const filteredDataKeys =
      this.filteredData.map(item => item[this.keyProp]);
      this.checked.forEach(item => {
        if (filteredDataKeys.indexOf(item) > -1) {
          checked.push(item);
        }
      });
      this.checkChangeByUser = false;
      this.checked = checked;
    },
    checkableData () {
      this.updateAllChecked();
    },
    defaultChecked: {
      immediate: true,
      handler (val, oldVal) {
        if (oldVal && val.length === oldVal.length &&
          val.every(item => oldVal.indexOf(item) > -1)) return;
        const checked = [];
        const checkableDataKeys =
        this.checkableData.map(item => item[this.keyProp]);
        val.forEach(item => {
          if (checkableDataKeys.indexOf(item) > -1) {
            checked.push(item);
          }
        });
        this.checkChangeByUser = false;
        this.checked = checked;
      },
    },
  },
  methods: {
    updateAllChecked () {
      const checkableDataKeys =
        this.checkableData.map(item => item[this.keyProp]);
      this.allChecked = checkableDataKeys.length > 0 &&
        checkableDataKeys.every(item => this.checked.indexOf(item) > -1);
    },
    handleAllCheckedChange (value) {
      this.checked = value
        ? this.checkableData.map(item => item[this.keyProp])
        : [];
    },
  },
};
</script>
