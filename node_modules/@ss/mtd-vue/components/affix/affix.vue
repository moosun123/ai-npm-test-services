<template>
  <div>
    <div ref="point" :class="classes" :style="styles">
      <slot />
    </div>
    <div v-show="slot" :style="placeHolderStyle" />
  </div>
</template>
<script>
import { CONFIG_PROVIDER, getPrefixCls } from '@/utils/config';
import debounce from 'throttle-debounce/debounce';
import { on, off } from '@/utils/dom';
import {addResizeListener, removeResizeListener} from '@/utils/resize-event';

function getScroll (target, top) {
  const prop = top ? 'pageYOffset' : 'pageXOffset';
  const method = top ? 'scrollTop' : 'scrollLeft';

  let ret = target[prop];

  if (typeof ret !== 'number') {
    ret = window.document.documentElement[method];
  }

  return ret;
}

function getOffset (element) {
  const rect = element.getBoundingClientRect();

  const scrollTop = getScroll(window, true);
  const scrollLeft = getScroll(window);

  const docEl = window.document.body;
  const clientTop = docEl.clientTop || 0;
  const clientLeft = docEl.clientLeft || 0;
  // clientTop和clientLeft兼容性比较好，不需要修改
  return {
    top: rect.top + scrollTop - clientTop,
    left: rect.left + scrollLeft - clientLeft,
  };
}

export default {
  name: 'MtdAffix',
  props: {
    offsetTop: {
      type: Number,
      default: 0,
    },
    offsetBottom: {
      type: Number,
    },
    debounce: {
      type: Number,
      default: 0,
    },
    getTarget: {
      type: Function,
    },
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
      },
    },
  },
  data () {
    return {
      affix: false,
      styles: {},
      slot: false,
      placeHolderStyle: {},
      containerEl: null,
    };
  },
  computed: {
    offsetType () {
      return this.offsetBottom >= 0 ? 'bottom' : 'top';
    },
    classes () {
      return [
        {
          [this.config.getPrefixCls('affix')]: this.affix,
        },
      ];
    },
  },
  mounted () {
    this.containerEl = this.getTarget ? this.getTarget() : window;
    if (this.containerEl) {
      on(this.containerEl, 'scroll', this.debounceScroll);
      // 当窗口缩放时也需要重新触发,以调整affix的宽度
      addResizeListener(this.$el, this.debounceScroll);
      this.$nextTick(() => {
        this.debounceScroll();
      });
    } else {
      console.warn('MTD[Affix]: getTarget prop must return an HTMLElement');
    }
  },
  beforeDestroy () {
    if (this.containerEl) {
      off(this.containerEl, 'scroll', this.debounceScroll);
      removeResizeListener(this.$el, this.debounceScroll);
    }
  },
  methods: {
    handleScroll () {
      const affix = this.affix;
      const scrollTop = getScroll(this.containerEl, true);
      const elOffset = getOffset(this.$el);
      const containerHeight =
        this.containerEl === window
          ? (window.innerHeight || document.body.clientHeight)
          : this.containerEl.getBoundingClientRect().height;

      const elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight;
      if (affix) {
        if (this.offsetType === 'top') {
          if ((elOffset.top - this.offsetTop) > scrollTop) {
            this.slot = false;
            this.placeHolderStyle = {};
            this.affix = false;
            this.styles = null;
            this.$emit('change', false);
          } else {
            const containerRect = this.$el.getBoundingClientRect();
            // 虽然已经固定,但是窗口可能被缩放,因此要实时更新元素宽度以适应缩放
            this.styles.width = `${containerRect.width}px`;
            this.placeHolderStyle.width = `${containerRect.width}px`;
          }
        } else if (this.offsetType === 'bottom') {
          if (
            (elOffset.top + this.offsetBottom + elHeight) <
            (scrollTop + containerHeight)
          ) {
            this.slot = false;
            this.placeHolderStyle = {};
            this.affix = false;
            this.styles = null;
            this.$emit('change', false);
          } else {
            const containerRect = this.$el.getBoundingClientRect();
            // 虽然已经固定,但是窗口可能被缩放,因此要实时更新元素宽度以适应缩放
            this.styles.width = `${containerRect.width}px`;
            this.placeHolderStyle.width = `${containerRect.width}px`;
          }
        }
      } else {
        if (this.offsetType === 'top') {
          if ((elOffset.top - this.offsetTop) < scrollTop) {
            const pointRect = this.$refs.point.getBoundingClientRect();
            const containerRect = this.$el.getBoundingClientRect();
            this.affix = true;
            this.placeHolderStyle = {
              width: pointRect.width + 'px',
              height: pointRect.height + 'px',
            };
            this.slot = true;
            this.styles = {
              top: `${this.offsetTop}px`,
              width: `${containerRect.width}px`,
            };
            this.$emit('change', true);
          }
        } else if (this.offsetType === 'bottom') {
          if (
            (elOffset.top + this.offsetBottom + elHeight) >
            (scrollTop + containerHeight)
          ) {
            const pointRect = this.$refs.point.getBoundingClientRect();
            const containerRect = this.$el.getBoundingClientRect();
            this.affix = true;
            this.placeHolderStyle = {
              width: pointRect.width + 'px',
              height: pointRect.height + 'px',
            };
            this.slot = true;
            this.styles = {
              bottom: `${this.offsetBottom}px`,
              width: `${containerRect.width}px`,
            };
            this.$emit('change', true);
          }
        }
      }
    },
    debounceScroll () {
      if (this.debounce) {
        debounce(this.debounce, this.handleScroll)();
      } else {
        this.handleScroll();
      }
    },
  },
};
</script>
