<template>
  <textarea v-bind="$attrs" v-on="inputLisenters"
    ref="textarea"
    :class="[prefix, {
      [`${prefix}-disabled`]: disabled,
      [`${prefix}-readonly`]: readonly,
      [`${prefix}-invalid`]: invalid,
    }]" :value="value"
    :readonly="readonly" :disabled="disabled"
    :style="textareaCalcStyle"
  />
</template>
<script>
import calcNodeHeight from './calcNodeHeight';
import {
  CONFIG_PROVIDER,
  getPrefixCls,
} from '@/utils/config';
import { isKey } from '@/utils/key-codes';

export default {
  name: 'Textarea',
  props: {
    disabled: Boolean,
    readonly: Boolean,
    invalid: Boolean,
    value: [String, Number],
    autosize: {
      type: [Boolean, Object],
      default: false,
    },
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
      },
    },
  },
  data () {
    return {
      textareaCalcStyle: {},
      isComposing: false,
    };
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('textarea');
    },
    inputLisenters () {
      const lisenters = Object.assign({}, this.$listeners, {
        input: this.handleInput,
        compositionstart: this.handleComposition,
        compositionupdate: this.handleComposition,
        compositionend: this.handleComposition,
        keyup: this.handleKeyup,
      });
      if (lisenters.change) {
        // it will trigger change event twice if not remove
        delete lisenters.change;
      }
      return lisenters;
    },
  },
  watch: {
    value (val) {
      this.$nextTick(this.resizeTextarea);
    },
  },
  mounted () {
    this.resizeTextarea();
  },
  methods: {
    setNativeInput () {
      const { textarea } = this.$refs;
      if (textarea && textarea.value !== this.value) {
        textarea.value = this.inputValue;
      }
    },
    handleInput (event, options) {
      const { value } = event.target;
      if (value !== this.value) {
        this.$emit('input', value);
        if (!this.isComposing) {
          setTimeout(this.setNativeInput, 0);
        }
      }
      if (!this.isComposing || (options && options.change)) {
        this.$emit('change', value);
      }
    },
    handleComposition (e) {
      const { type } = e;
      if (this.$listeners[type]) {
        this.$emit(type, e);
      }
      if (type === 'compositionend') {
        this.isComposing = false;
        this.handleInput(e, { change: true });
      } else {
        this.isComposing = true;
      }
    },
    handleKeyup (e) {
      if (this.$listeners.keyup) {
        this.$emit('keyup', e);
      }
      if (isKey(e, 'enter') && !this.isComposing) {
        this.$emit('enter', e);
      }
    },
    focus () {
      this.$refs.textarea.focus();
    },
    blur () {
      this.$refs.textarea.blur();
    },
    select () {
      this.$refs.textarea.select();
    },
    resizeTextarea () {
      if (this.$isServer || !this.autosize) return;
      const { minRows, maxRows } = this.autosize;
      this.textareaCalcStyle = calcNodeHeight(this.$refs.textarea, minRows, maxRows);
    },
  },
};
</script>
