<template>
  <component
    :is="wrapperComponent"
    :offset-top="offsetTop"
    :offset-bottom="offsetBottom"
    :get-target="affix ? getAffixTarget : undefined"
    @change="handleAffixStateChange"
  >
    <div :class="`${prefix}-wrapper`" :style="wrapperStyle">
      <div :class="prefix">
        <div :class="`${prefix}-ink ${prefix}-ink-${placement
        }`">
          <span
            v-show="showInk && inkVisible"
            :class="`${prefix}-ink-ball`"
            :style="{top: `${inkTop}px`}" />
        </div>
        <slot />
      </div>
    </div>
  </component>
</template>
<script>
import {
  scrollTop,
  findComponentsDownward,
  sharpMatcherRegx,
} from '@/utils/util';
import MtdAffix from '@components/affix';
import { CONFIG_PROVIDER, getPrefixCls } from '@/utils/config';

import { on, off } from '@/utils/dom';
export default {
  name: 'MtdAnchor',
  provide () {
    return {
      anchorCom: this,
    };
  },
  components: {
    MtdAffix,
  },
  inheritAttrs: false,
  props: {
    affix: {
      type: Boolean,
      default: true,
    },
    offsetTop: {
      type: Number,
      default: 0,
    },
    offsetBottom: Number,
    bounds: {
      type: Number,
      default: 5,
    },
    container: null,
    showInk: {
      type: Boolean,
      default: true,
    },
    scrollOffset: {
      type: Number,
      default: 0,
    },
    placement: {
      type: String,
      default: 'left',
      validator (v) {
        return !v || ['left', 'right'].indexOf(v) !== -1;
      },
    },
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
      },
    },
  },
  data () {
    return {
      isAffixed: false, // current affixed state
      inkTop: 0,
      inkVisible: false,
      animating: false, // if is scrolling now
      currentLink: '', // current show link =>  #href -> currentLink = #href
      currentId: '', // current show title id =>  #href -> currentId = href
      scrollContainer: null,
      scrollElement: null,
      titlesOffsetArr: [],
      wrapperTop: 0,
      upperFirstTitle: true,
    };
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('anchor');
    },
    wrapperComponent () {
      return this.affix ? 'MtdAffix' : 'div';
    },
    wrapperStyle () {
      return {
        maxHeight: this.offsetTop
          ? `calc(100vh - ${this.offsetTop}px)`
          : '100vh',
      };
    },
    containerIsWindow () {
      return this.scrollContainer === window;
    },
  },
  watch: {
    '$route' () {
      this.handleHashChange();
      this.$nextTick(() => {
        this.handleScrollTo();
      });
    },
    container () {
      this.init();
    },
    currentLink (newHref, oldHref) {
      this.$emit('change', newHref, oldHref);
    },
  },
  mounted () {
    this.init();
  },
  beforeDestroy () {
    this.removeListener();
  },
  methods: {
    handleAffixStateChange (state) {
      this.isAffixed = this.affix && state;
    },
    handleScroll (e) {
      if (this.titlesOffsetArr[0]) {
        this.upperFirstTitle = e.target.scrollTop <
          this.titlesOffsetArr[0].offset;
      }
      if (this.animating) return;
      this.updateTitleOffset();
      const scrollTop = (document.documentElement.scrollTop ||
        document.body.scrollTop ||
        e.target.scrollTop) + this.scrollOffset;
      this.getCurrentScrollAtTitleId(scrollTop);
    },
    handleHashChange () {
      const url = window.location.href;
      const sharpLinkMatch = sharpMatcherRegx.exec(url);
      if (!sharpLinkMatch) {
        this.currentLink = null;
        this.currentId = null;
      } else {
        this.currentLink = sharpLinkMatch[0];
        this.currentId = sharpLinkMatch[1];
      }
    },
    handleScrollTo () {
      if (!this.currentId) return;
      const anchor = document.getElementById(this.currentId);
      if (!anchor) return;
      const currentLinkElementA =
        this.$el.querySelector(`a[data-href="${this.currentLink}"]`);
      let offset = this.scrollOffset;
      if (!currentLinkElementA) {
        this.handleSetInkTop();
        return;
      }
      offset = parseFloat(currentLinkElementA.getAttribute('data-scroll-offset'));

      const offsetTop = anchor.offsetTop - this.wrapperTop - offset;
      this.animating = true;
      scrollTop(
        this.scrollContainer,
        this.scrollElement.scrollTop,
        offsetTop,
        600,
        () => {
          this.animating = false;
        });
      this.handleSetInkTop();
    },
    handleSetInkTop () {
      const currentLinkElementA =
        this.$el.querySelector(`a[data-href="${this.currentLink}"]`);
      if (!currentLinkElementA) {
        this.inkVisible = false;
        return;
      }
      const elementATop = currentLinkElementA.offsetTop;
      const top = (elementATop < 0 ? this.offsetTop : elementATop);
      this.inkTop = top;
      this.inkVisible = true;
    },
    updateTitleOffset () {
      const links = findComponentsDownward(this, 'MtdAnchorLink').map(link => {
        return link.href;
      });
      const idArr = links.map(link => {
        return link.split('#')[1];
      });
      const offsetArr = [];
      idArr.forEach(id => {
        const titleEle = document.getElementById(id);
        if (titleEle) {
          offsetArr.push({
            link: `#${id}`,
            offset: titleEle.offsetTop - this.scrollElement.offsetTop,
          });
        }
      });
      this.titlesOffsetArr = offsetArr;
    },
    getAffixTarget () {
      return this.container ? (typeof this.container === 'string'
        ? document.querySelector(this.container)
        : this.container)
        : window;
    },
    getCurrentScrollAtTitleId (scrollTop) {
      let i = -1;
      const len = this.titlesOffsetArr.length;
      let titleItem = {
        link: '#',
        offset: 0,
      };
      scrollTop += this.bounds;
      while (++i < len) {
        const currentEle = this.titlesOffsetArr[i];
        const nextEle = this.titlesOffsetArr[i + 1];
        if (
          scrollTop >= currentEle.offset &&
          scrollTop < ((nextEle && nextEle.offset) || Infinity)
        ) {
          titleItem = this.titlesOffsetArr[i];
          break;
        }
      }
      this.currentLink = titleItem.link;
      this.handleSetInkTop();
    },
    getContainer () {
      this.scrollContainer = this.getAffixTarget();
      this.scrollElement = this.container
        ? this.scrollContainer
        : (document.documentElement || document.body);
    },
    removeListener () {
      off(this.scrollContainer, 'scroll', this.handleScroll);
      off(window, 'hashchange', this.handleHashChange);
    },
    init () {
      this.handleHashChange();
      this.$nextTick(() => {
        this.removeListener();
        this.getContainer();
        this.wrapperTop = this.containerIsWindow
          ? 0
          : this.scrollElement.offsetTop;
        this.handleScrollTo();
        this.handleSetInkTop();
        this.updateTitleOffset();
        if (this.titlesOffsetArr[0]) {
          this.upperFirstTitle = this.scrollElement.scrollTop <
            this.titlesOffsetArr[0].offset;
        }
        on(this.scrollContainer, 'scroll', this.handleScroll);
        on(window, 'hashchange', this.handleHashChange);
      });
    },
  },
};
</script>
