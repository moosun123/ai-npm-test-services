<template>
  <popper
    :class="{ [`${prefix}-${_size}`]: _size, [prefix]: true }"
    :visible="visible"
    ref="popper"
    trigger="click"
    :append-to-container="appendToContainer"
    :get-popup-container="getPopupContainer"
    :popper-options="popperOptions"
    @clickoutside="handleClickoutside"
  >
    <reference>
      <mtd-select-input
        type="text"
        ref="reference"
        v-bind="$attrs"

        :value="value"
        :size="_size"
        :loading="loading"
        :clearable="clearable"
        v-on="inputLisenter"

        @keydown.down.stop.prevent="navigateOptions('next')"
        @keydown.up.stop.prevent="navigateOptions('prev')"
        @keydown.enter.stop.prevent="selectOption"
        @keydown.esc.stop.prevent="focused = false"
        @compositionstart="handleComposition"
        @compositionend="handleComposition"
        :class="{[`${selectPrefix}-search-focus`]: focused}" />
    </reference>
    <drop ref="drop"
      :class="[popperClass, `${selectPrefix}-dropdown`]" :use-show="true"
      :style="{
        'min-width': minWidth,
      }"
    >
      <ul :class="`${dropdownPrefix}-menu`" ref="menu">
        <div :class="`${prefix}-dropdown-menu`" v-show="!loading">
          <option-wrap v-if="$slots.default"
            @updated="handleSlotUpdated">
            <slot />
          </option-wrap>
          <template v-else-if="$props.data.length">
            <mtd-option v-for="(option, i) in optionData"
              :key="i" :label="option" :value="option"
              ref="dataOption" />
          </template>
        </div>
        <slot name="loading" v-if="loading">
          <li :class="`${dropdownPrefix}-menu-item ${selectPrefix}-dropdown-loading`">
            {{ loadingText }}
          </li>
        </slot>
      </ul>
    </drop>
  </popper>
</template>
<script>
import {
  Popper,
  Drop,
  Reference,
} from '@components/popper';
import { typeOf } from '@/utils/util';
import MtdSelectInput from '@components/select-input';
import OptionWrap from './option-wrap';
import MtdOption from '@components/option';
import NavigationMixin from '@components/select/navigation-mixin';
import scrollIntoView from '@/utils/scroll-into-view';
import { CONFIG_PROVIDER,
  getPrefixCls,
  getSize,
} from '@/utils/config';

export default {
  name: 'Autocomplete',
  components: {
    MtdSelectInput,
    Popper,
    Drop,
    OptionWrap,
    Reference,
    MtdOption,
  },
  mixins: [NavigationMixin],
  inheritAttrs: false,
  provide () {
    return {
      'select': this,
    };
  },
  props: {
    value: [String, Number, Object],
    size: String,
    data: {
      type: Array,
      default: () => [],
    },
    loading: Boolean,
    clearable: Boolean,
    loadingText: {
      type: String,
      default () {
        return '搜索中';
      },
    },
    popperClass: String,
    filterMethod: {
      type: [Function, Boolean],
      default: null,
    },
    appendToContainer: {
      type: Boolean,
      default: true,
    },
    getPopupContainer: Function,
    popperOptions: Object,
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getSize,
      },
    },
  },
  data () {
    return {
      minWidth: 0,
      inputWidth: 0,
      options: [], // 默认的无效options;
      selfOptions: [], // 使用的options;
      hasAnySelfOptions: false,
      focused: false,
      hasDefaultSlot: false,
      dataOptions: [],
      isOnComposition: false,
    };
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('autocomplete');
    },
    _size () {
      return this.config.getSize(this);
    },
    selectPrefix () {
      return this.config.getPrefixCls('select');
    },
    dropdownPrefix () {
      return this.config.getPrefixCls('dropdown');
    },
    allOptions () {
      return this.dataOptions || this.selfOptions;
    },
    navOptions () {
      return this.allOptions.filter((o) => o.visible && !o._disabled);
    },
    isEmpty () {
      if (!this.hasDefaultSlot) {
        return !this.optionData.length;
      }
      return !this.hasAnySelfOptions;
    },
    visible () {
      return this.focused && !this.isEmpty;
    },
    optionData () {
      if (!this.hasDefaultSlot &&
          this.$props.data.length && this.value) {
        if (this.filterMethod === true) {
          return this.$props.data;
        } else if (this.filterMethod === false) {
          return [];
        } else if (typeOf(this.filterMethod) === 'function') {
          return this.$props.data.filter((option) => {
            return this.filterMethod(this.value, option);
          });
        }
      }
      return this.$props.data;
    },
    inputLisenter () {
      const lisenter = {
        ...this.$listeners,
        input: this.handleInputQuery,
        blur: this.handleBlur,
        focus: this.handleFocus,
      };
      delete lisenter.select;
      delete lisenter.search;
      return lisenter;
    },
  },
  watch: {
    focused (val) {
      if (!val) {
        this.resetHover();
      }
      this.getInputWidth();
    },
    inputWidth (val) {
      this.minWidth = `${val}px`;
    },
    optionData () {
      this.$nextTick(() => {
        this.dataOptions = this.$refs.dataOption;
        this.updatePopper();
      });
    },
  },
  created () {
    this.$on('optionClick', this.handleOptionClick);
  },
  mounted () {
    this.dataOptions = this.$refs.dataOption;
  },
  methods: {
    addOption (option) {
      this.options.push(option);
    },
    focus () {
      this.$refs.reference.focus();
    },
    blur () {
      this.$refs.reference.blur();
    },
    handleSlotUpdated () {
      if (this.$slots.default) {
        this.hasDefaultSlot = true;
        this.selfOptions = this.getOptionsFromSlotAnyLevel();
      } else {
        this.hasDefaultSlot = false;
        this.selfOptions = [];
      }
      this.hasAnySelfOptions = !!this.selfOptions.length;
      this.updatePopper();
    },
    getInputWidth () {
      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
    },
    handleComposition (e) {
      const { type } = e;
      if (type === 'compositionend') {
        this.isOnComposition = false;
        // 当混合输入前后值不变时，不会触发后续的 input 事件，所以需要再次触发 query
        this.$emit('search', e.target.value);
      } else {
        this.isOnComposition = true;
      }
    },
    handleBlur (event) {
      if (!this.visible) {
        this.handleClickoutside(event);
        this.$emit('blur', event);
      }
    },
    handleClickoutside (event) {
      this.focused = false;
    },
    handleInputQuery (value) {
      this.focused = true;
      this.$emit('input', value);
      this.$emit('change', value);
      if (!this.isOnComposition) {
        this.$emit('search', value);
      }
    },
    handleOptionClick (option, keyboard) {
      this.focused = false;
      if (option.value !== this.value) {
        this.$emit('input', option.value);
        this.$emit('change', option.value);
      }
      // 事件顺序参照: https://tt.sankuai.com/ticket/detail?id=4148656
      this.$emit('select', option.value);
      !keyboard && this.$emit('blur');
    },
    handleFocus (event) {
      this.focused = true;
      this.$emit('focus', event);
    },
    getOptionsFromSlotFirstLevel () {
      if (!this.$slots.default || !this.$slots.default.length) {
        return [];
      } else {
        return this.$slots.default.filter((item) => {
          return item.componentOptions &&
            (item.$options.name === 'MtdOption' || item.componentOptions.tag === 'mtd-option');
        });
      }
    },
    getOptionsFromSlotAnyLevel () {
      if (!this.$children || !this.$children.length) {
        return [];
      } else {
        const options = [];
        this.searchOption(this, options);
        return options;
      }
    },
    searchOption (node, options) {
      if (!node.$children || !this.$children.length) {
        return;
      }
      node.$children.forEach((item) => {
        if (item.$options.name === 'MtdOption' || item.$options._componentTag === 'mtd-option') {
          options.push(item);
        } else {
          this.searchOption(item, options);
        }
      });
    },
    scrollToOption (option) { // 超长滚动;
      const target = Array.isArray(option) &&
        option[0] ? option[0].$el : option.$el;
      if (this.$refs.popper && target) {
        const menu = this.$refs.menu;
        scrollIntoView(menu, target);
      }
    },
    selectOption (option) {
      if (this.hoverOption && this.hoverOption.visible) {
        this.handleOptionClick(this.hoverOption, true);
      }
    },
    toggleMenu () {
      if (!this.disabled) {
        if (!this.filterable || !this.focused) {
          this.focused = !this.focused;
        }
        if (this.focused) {
          this.$refs.tagInput && this.$refs.tagInput.focus();
        }
      }
    },
    updatePopper () {
      if (this.visible) {
        this.$refs.popper.updatePopper();
      }
    },
  },
};
</script>
