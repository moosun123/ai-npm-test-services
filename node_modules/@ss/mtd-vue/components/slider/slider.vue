<template>
    <div
      :class="wrapperClass"
      ref="sliderWrapper"
      @click="handleClick">
      <div
        :class="`${prefix}-bar`"
        :style="vertical
          ? { height: bars.w, bottom: bars.x }
          : { width: bars.w, left: bars.x }"
        v-if="!thresholds"
      />
      <div
        :class="`${prefix}-fixed-bar`"
        :style="vertical
          ? {height: getPercent(fixedValue)}
          : {width: getPercent(fixedValue)}"
        v-if="fixedValue" />
      <mtd-slider-button
        v-for="(item, i) in internalValue"
        :key="'button-' + i"
        :prefix="prefix"
        :value="item"
        :type="i"
        :vertical="vertical"
        :format-tooltip="formatTooltip"
        :get-percent="getPercent"
        @change="handleChange"
        @dragging="handleButtonDragging"
        @drag-end="handleDragEnd"
      >
        <slot name="handler" />
      </mtd-slider-button>
      <template v-if="dots">
        <div
          :class="`${prefix}-stop`"
          v-for="item in dots"
          :style="vertical
            ? {bottom: getPercent(item)}
            : {left: getPercent(item)}"
          :key="'stop-' + item"
        />
      </template>
      <div
        :class="`${prefix}-tracks`"
        v-if="tracks"
      >
          <div
            :class="`${prefix}-track ${prefix}-track-left`"
            v-if="range"
            :style="vertical
              ? {height: `${(minValue - min) * 100 / wholeLength}%`}
              : {width: `${(minValue - min) * 100 / wholeLength}%`}" />
          <div
            :class="`${prefix}-track`"
            v-for="(item, index) in tracks"
            :style="vertical
              ? {height: item.w, bottom: item.x,
                backgroundColor: item.color}
              : {width: item.w, left: item.x,
                backgroundColor: item.color}"
            :key="'track-' + index"
          />
          <div
            :class="`${prefix}-track ${prefix}-track-right`"
            :style="vertical
              ? {height: `${100 -
                (maxValue - min) * 100 / wholeLength}%`}
              : {width: `${100 -
                (maxValue - min) * 100 / wholeLength}%`}" />
      </div>
      <div
        :class="`${prefix}-mark`"
        :style="vertical
          ? {height: '100%'}
          : {width: '100%'}"
      >
        <span
          :class="`${prefix}-mark-text`"
          v-for="(item, index) in markTexts"
          :key="'mark-' + index"
          :style="vertical
            ? {bottom: `${(item.value - min) * 100 / wholeLength}%`}
            : {left: `${(item.value - min) * 100 / wholeLength}%`}"
        >{{ item.label }}</span>
      </div>
    </div>
</template>
<script>
import MtdSliderButton from './button.vue';
import {
  CONFIG_PROVIDER,
  getPrefixCls,
  getSize,
} from '@/utils/config';

export default {
  name: 'MtdSlider',
  components: {
    MtdSliderButton,
  },
  model: {
    prop: 'value',
  },
  props: {
    size: {
      type: String,
    },
    marks: {
      type: Object,
    },
    min: {
      type: Number,
      default: 0,
    },
    max: {
      type: Number,
      default: 100,
    },
    value: {
      type: [ Number, Array ],
    },
    range: {
      type: Boolean,
      default: false,
    },
    vertical: {
      type: Boolean,
      default: false,
    },
    disabled: {
      type: Boolean,
      default: false,
    },
    step: Number,
    steps: Array,
    thresholds: {
      type: Object,
    },
    fixedValue: {
      type: Number,
    },
    formatTooltip: Function,
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getSize,
      },
    },
  },
  data () {
    return {
      dragging: false,
      tip: false,
      internalValue: [],
    };
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('slider');
    },
    _size () {
      return this.config.getSize(this);
    },
    minValue () {
      return Math.max(Math.min(...this.internalValue), this.min);
    },
    maxValue () {
      return Math.min(Math.max(...this.internalValue), this.max);
    },
    bars () {
      const min = this.range ? this.minValue : this.min;
      return {
        w: this.getPercent(this.maxValue - min, 0),
        x: this.range ? this.getPercent(this.minValue) : 0,
      };
    },
    dots () {
      const { step, steps } = this;
      if ((!step || step < 0) && !steps) {
        return;
      }
      let arr = step ? [] : steps;
      if (step) {
        const { min, max } = this;
        let n = min + step;
        while (n < max) {
          arr.push(n);
          n = n + step;
        }
      }
      arr = arr.filter(v => {
        return v > this.min &&
          v < this.max;
      });
      return arr;
    },
    markTexts () {
      let arr;
      if (this.marks) {
        arr = Object.keys(this.marks).map((m) => {
          return {
            value: m,
            label: this.marks[m] || m,
          };
        });
      } else {
        arr = [this.min, this.max];
        if (this.fixedValue) {
          arr = [...[this.fixedValue], ...arr];
        }
        if (this.dots) {
          arr = [...this.dots, ...arr];
        }
        if (this.thresholds) {
          arr = [...this.thresholds.values, ...arr];
        }
        arr = arr.map((v) => { return { value: v, label: v }; });
      }
      arr = arr.sort((a, b) => a.value - b.value)
        .filter((v, i) => (!arr[i + 1] || v.value !== arr[i + 1].value) &&
          v.value >= this.min && v.value <= this.max);
      return arr;
    },
    wholeLength () {
      return this.max - this.min;
    },
    curFixedValue () {
      return this.fixedValue || this.min;
    },
    wrapperClass () {
      const { prefix } = this;
      return [
        prefix,
        [
          {
            [`${prefix}-disabled`]: this.disabled,
            [`${prefix}-vertical`]: this.vertical,
            [`${prefix}-${this._size}`]: this._size,
          },
        ],
      ];
    },
    tracks () {
      if (this.thresholds) {
        let begin = this.min;
        return this.thresholds.values.map((v, index) => {
          const range = {
            value: v,
            color: this.thresholds.colors[index],
            ...this.getRange(begin, v),
          };
          begin = v;
          return range;
        });
      }
      return undefined;
    },
  },
  watch: {
    value: {
      immediate: true,
      handler () {
        this.syncValue();
      },
    },
    range: {
      handler () {
        this.syncValue();
      },
    },
  },
  methods: {
    syncValue () {
      if (this.range) {
        this.internalValue = [...this.value];
        this.internalValue.length = 2;
      } else {
        this.internalValue = [this.value];
      }
      for (let i = 0; i < this.internalValue.length; i++) {
        // can't use .map()
        const v = this.internalValue[i];
        this.internalValue[i] = !v && v !== 0 ? this.min : v;
      }
    },
    getPercent (value, beign = this.min) {
      let n = (value - beign) * 100 / this.wholeLength;
      if (n < 0) {
        n = 0;
      } else if (n > 100) {
        n = 100;
      }
      return `${n}%`;
    },
    getRange (start, end) {
      return {
        w: this.getPercent(end - start, 0), // range size
        x: this.getPercent(start), // x: vertical ? bottom : left
      };
    },
    handleClick (e) {
      if (this.dragging) {
        return;
      }
      this.vertical
        ? this.setPositionY(e)
        : this.setPositionX(e);
      this.handleChange();
    },
    handleButtonDragging (e, type) {
      this.dragging = true;
      this.vertical ? this.setPositionY(e, type) : this.setPositionX(e, type);
    },
    handleDragEnd (e, type) {
      this.dragging = false;
    },
    parseValue (value) {
      return parseInt(value); // todo 解决精度问题
    },
    setValue (offset, type) {
      const dot = this.getNearestStop(offset);
      const value = dot !== undefined ? dot
        : this.parseValue(this.min + offset * this.wholeLength);

      const index = type === undefined ? this.getNearestButtonType(value)
        : type;
      this.$set(this.internalValue, index, value);
    },
    setPositionX (e, type) {
      if (this.disabled) {
        return;
      }
      const start = this.$refs.sliderWrapper
        .getBoundingClientRect()
        .left;
      const fixedValue = start +
        Math.round((this.curFixedValue - this.min) / this.wholeLength *
        this.$refs.sliderWrapper.clientWidth);
      const end = this.$refs.sliderWrapper.getBoundingClientRect().right;
      const current = e.clientX;
      let offset;
      if (current <= fixedValue) {
        offset = (this.curFixedValue - this.min) / this.wholeLength;
      } else if (e.clientX >= end) {
        offset = 1;
      } else {
        offset = (current - start) / this.$refs.sliderWrapper
          .clientWidth;
      }
      this.setValue(offset, type);
    },
    setPositionY (e, type) {
      if (this.disabled) {
        return;
      }
      const start = this.$refs.sliderWrapper
        .getBoundingClientRect()
        .bottom;
      const fixedValue = start -
        Math.round((this.curFixedValue - this.min) / this.wholeLength *
        this.$refs.sliderWrapper.clientHeight);
      const end = this.$refs.sliderWrapper.getBoundingClientRect().top;
      const current = e.clientY;
      let offset;
      if (current >= fixedValue) {
        offset = (this.curFixedValue - this.min) / this.wholeLength;
      } else if (current <= end) {
        offset = 1;
      } else {
        offset = (start - current) / this.$refs.sliderWrapper
          .clientHeight;
      }
      this.setValue(offset, type);
    },
    getNearestButtonType (value) {
      const vs = this.internalValue.map((v, i) => {
        return {
          index: i,
          diff: Math.abs(v - value),
        };
      });
      vs.sort((a, b) => a.diff - b.diff);
      return vs[0] ? vs[0].index : 1;
    },
    getNearestStop (offset) {
      if (!this.dots) {
        return undefined;
      };
      const value = offset * this.wholeLength + this.min;
      const orders = [this.min, this.max, value, ...this.dots]
        .sort((a, b) => a - b);
      const index = orders.indexOf(value);
      const next = index === orders.length ? this.max : orders[index + 1];
      const pre = index === 0 ? this.min : orders[index - 1];
      return Math.abs(next - value) > Math.abs(pre - value) ? pre : next;
    },
    handleChange () {
      const value = this.internalValue.sort((a, b) => a - b);
      if (value.some((v, i) => v !== this.value[i])) {
        const v = this.range ? value : value[0];
        this.$emit('input', v);
        this.$emit('change', v);
      }
      this.syncValue();
    },
  },
};
</script>
