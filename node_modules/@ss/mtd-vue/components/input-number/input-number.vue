<template>
  <div :class="{
    [`${prefix}-wrapper`]: true,
    [`${prefix}-disabled`]: disabled,
    [`${prefix}-invalid`]: invalid,
    [`${prefix}-without-controls`]: !controls,
    [`${prefix}-controls-right`]: controlsPosition === 'right',
    [`${prefix}-${_size}`]: !!_size
  }">
    <span
      :class="[`${prefix}-handle ${prefix}-handle-down`, {
        [`${prefix}-handle-disabled`]: downHandleDisabled
      }]"
      v-if="controls"
      @click.prevent="handleDownStep"
    >
      <Icon :name="controlsPosition === 'right' ? 'down': 'remove'" />
    </span>
    <span
      :class="{
        [`${prefix}-handle ${prefix}-handle-up`]: true,
        [`${prefix}-handle-disabled`]: upHandleDisabled}"
      v-if="controls"
      @click.prevent="handleUpStep"
    >
      <Icon :name="controlsPosition === 'right' ? 'up': 'add'" />
    </span>
    <input :class="prefix"
      v-bind="$attrs"
      type="text"
      autocomplete="off"
      :placeholder="placeholder"
      :name="name"
      :value="displayValue"
      :disabled="disabled"
      ref="input"
      @input="handleInput"
      @change="handleChange"
      @focus="handleFocus"
      @blur="handleBlur"
      @keyup="handleKeyUp"
      @keydown.up.prevent="handleUpStep"
      @keydown.down.prevent="handleDownStep"
    >
  </div>
</template>
<script>
import Icon from '@components/icon';
import { CONFIG_PROVIDER,
  getPrefixCls,
  getSize,
} from '@/utils/config';

function isEmptyNullUndefined (val) {
  return val === '' || val === undefined || val === null;
}

export default {
  name: 'InputNumber',
  components: {
    Icon,
  },
  props: {
    value: [String, Number],
    placeholder: String,
    name: String,
    size: String,
    disabled: {
      type: Boolean,
      default: false,
    },
    invalid: {
      type: Boolean,
      default: false,
    },
    max: {
      type: Number,
      default: Infinity,
    },
    min: {
      type: Number,
      default: -Infinity,
    },
    precision: {
      type: Number,
      validator (val) {
        return val === undefined || (val >= 0 && val === parseInt(val, 10));
      },
    },
    step: {
      type: Number,
      default: 1,
    },
    formatter: Function,
    parser: Function,
    controls: {
      type: Boolean,
      default: true,
    },
    controlsPosition: {
      type: String,
      default: '',
      validator: function (val) {
        return ['right', ''].indexOf(val) !== -1;
      },
    },
    allowEmpty: Boolean,
    illegalClear: Boolean,
  },
  data () {
    return {
      currentValue: '',
      userInput: null,
    };
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getSize,
      },
    },
  },
  computed: {
    prefix () {
      return this.config.getPrefixCls('input-number');
    },
    _size () {
      return this.config.getSize(this);
    },
    upHandleDisabled () {
      return this.increase(this.currentValue) > this.max;
    },
    downHandleDisabled () {
      return this.decrease(this.currentValue) < this.min;
    },
    displayValue () {
      if (this.userInput !== null) {
        return this.formatWrapper(this.userInput);
      }
      let val = this.currentValue;
      const parseFloatValue = parseFloat(val, 10);
      if (!isNaN(parseFloatValue)) {
        val = this.precisionWrapper(parseFloatValue);
      }
      val = this.formatWrapper(val);
      return val;
    },
    numPrecision () {
      const { value, step, getPrecision, precision, currentValue } = this;
      const stepPrecision = getPrecision(step);
      if (precision !== undefined) {
        if (stepPrecision > precision) {
          console.warn('precision should not be less than the decimal places of step');
        }
        return precision;
      } else {
        let inputValuePrecision = getPrecision(value);
        if (value !== undefined && currentValue && typeof currentValue === 'number') {
          inputValuePrecision = getPrecision(currentValue);
        }
        return Math.max(inputValuePrecision, stepPrecision);
      }
    },
  },
  watch: {
    value: {
      immediate: true,
      handler (val) {
        if (!this.isNumber(val)) {
          console.warn('MTD[InputNumber] value shoule be number');
          return;
        }
        val = isEmptyNullUndefined(val) ? '' : parseFloat(val, 10);
        this.currentValue = val;
        this.userInput = null;
      },
    },
  },
  methods: {
    handleInput (event) {
      let val = event.target.value.trim().replace(/。/g, '.');
      val = this.parserWrapper(val);
      this.userInput = val;
    },
    handleChange (event) {
      const val = this.userInput;
      if (this.isNumber(val)) {
        // double parseFloag, -0 -> 0
        const newVal = val === '' ? '' : parseFloat(parseFloat(val, 10), 10);
        this.setCurrentValue(newVal);
      }
      this.userInput = null;
    },
    handleFocus (event) {
      this.$emit('focus', event);
    },
    handleBlur (event) {
      this.$emit('blur', event);
    },
    handleUpStep () {
      if (this.disabled || this.upHandleDisabled) {
        return;
      }
      const val = this.userInput || this.currentValue;
      const newVal = this.increase(val);
      this.setCurrentValue(newVal);
    },
    handleDownStep () {
      if (this.disabled || this.downHandleDisabled) {
        return;
      }
      const val = this.userInput || this.currentValue;
      const newVal = this.decrease(val);
      this.setCurrentValue(newVal);
    },
    commonCrease (type, val) {
      let newVal = val || 0;
      if (!this.isNumber(newVal)) {
        return this.currentValue;
      }
      if (isEmptyNullUndefined(val) && ((this.min && this.min !== -Infinity) || this.min === 0)) {
        return this.min;
      }
      newVal = parseFloat(newVal, 10);
      const precisionFactor = Math.pow(10, this.numPrecision);
      const precisionNewVal = precisionFactor * newVal;
      const precisionStep = precisionFactor * this.step;
      const result = (type === 'up'
        ? precisionNewVal + precisionStep
        : precisionNewVal - precisionStep) / precisionFactor;
      return Number(result.toFixed(this.numPrecision));
    },
    increase (val) {
      return this.commonCrease('up', val);
    },
    decrease (val) {
      return this.commonCrease('down', val);
    },
    setCurrentValue (val) {
      if (this.precision !== undefined) {
        if (!(this.allowEmpty && val === '')) {
          val = this.precisionWrapper(val);
        }
      }
      val = this.getValidValueByMinAndMax(val);
      if (this.currentValue === val) {
        return;
      }
      // toFixed返回的是字符串
      val = isEmptyNullUndefined(val) ? null : Number(val);
      this.$emit('input', val);
      this.$emit('change', val);
    },
    isNumber (val) {
      return isEmptyNullUndefined(val) ? true : !isNaN(parseFloat(val, 10));
    },
    getPrecision (val) {
      if (isEmptyNullUndefined(val)) {
        return 0;
      }
      const valString = val.toString();
      const dotPosition = valString.indexOf('.');
      let precision = 0;
      if (dotPosition !== -1) {
        precision = valString.length - dotPosition - 1;
      }
      return precision;
    },
    precisionWrapper (num) {
      if (this.numPrecision !== undefined) {
        const numStr = String(num);
        if (numStr.includes('e') && num > 1) {
          // 如果是科学计数法，则不做处理，且对于小于1的小数保持原来的处理（不会使用科学计数法）
          return num;
        };
        // 超出精度的舍弃，toFixed会四舍五入
        const pointArr = numStr.split('.');
        if (pointArr && pointArr[1] > this.numPrecision) {
          num = pointArr[0] + '.' + pointArr[1].substr(0, this.numPrecision);
        }
        num = Number(num).toFixed(this.numPrecision);
      }
      return num;
    },
    formatWrapper (num) {
      return this.formatter ? this.formatter(num) : num;
    },
    parserWrapper (num) {
      return this.parser ? this.parser(num) : num;
    },
    getValidValueByMinAndMax (val) {
      if (this.allowEmpty && val === '') {
        return '';
      }
      if (val < this.min) {
        val = this.illegalClear ? undefined : this.min;
      }
      if (val > this.max) {
        val = this.illegalClear ? undefined : this.max;
      }
      return val;
    },
    handleKeyUp (e) {
      this.$emit('keyup', e);
    },
  },
};
</script>
