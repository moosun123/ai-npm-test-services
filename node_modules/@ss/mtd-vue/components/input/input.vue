<template>
  <div :class="{
      [`${prefix}-wrapper`]: true,
      [`${prefix}-group`]: $slots.prepend || $slots.append || $scopedSlots.prepend || $scopedSlots.append,
      [`${prefix}-prefix`]: hasPrefix,
      [`${prefix}-suffix`]: hasSuffix,
      [`${prefix}-disabled`]: disabled,
      [`${prefix}-readonly`]: readonly,
      [`${prefix}-invalid`]: invalid,
      [`${prefix}-${_size}`]: !!_size,
      [`${prefix}-${genre}`]: !!genre,
    }"
    @mouseenter="hovering = true"
    @mouseleave="hovering = false"
  >
    <div :class="`${prefix}-group-prepend`" v-if="$slots.prepend || $scopedSlots.prepend">
      <slot name="prepend" />
    </div>
    <span :class="`${prefix}-prefix-inner`" v-if="hasPrefix">
      <slot name="prefix">
        <i :class="prefixIcon" @click="handlePrefixClick" />
      </slot>
    </span>
    <input v-bind="$attrs" :type="type" :value="inputValue"
      :readonly="readonly"
      :disabled="disabled"
      :class="prefix"
      ref="input"
      v-on="inputLisenters">
    <span :class="`${prefix}-suffix-inner`" v-if="hasSuffix">
      <Icon v-if="loading" name="loading" />
      <Icon name="error-circle" :class="`${prefix}-clear`"
        @click.stop="handleClearClick"
        v-else-if="showClear" />
      <slot name="suffix" v-else>
        <i :class="suffixIcon" @click="handleSuffixClick" />
      </slot>
    </span>
    <div :class="`${prefix}-group-append`" v-if="$slots.append || $scopedSlots.append">
      <slot name="append" />
    </div>
  </div>
</template>
<script>
import { isKey } from '@/utils/key-codes';
import {
  CONFIG_PROVIDER,
  getPrefixCls,
  getSize,
} from '@/utils/config';
import Icon from '@components/icon';

export default {
  name: 'Input',
  components: {
    Icon,
  },
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: 'text',
    },
    genre: String,
    size: String,
    clearable: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    invalid: Boolean,
    value: [String, Number],
    prefixIcon: String,
    suffixIcon: String,
    loading: Boolean,
    clearableOnReadonly: Boolean, // 当 readonly 时是否可以清空
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getSize,
      },
    },
  },
  data () {
    return {
      focused: false,
      hovering: false,
      isComposing: false,
    };
  },

  computed: {
    prefix () {
      return this.config.getPrefixCls('input');
    },
    _size () {
      return this.config.getSize(this);
    },
    hasPrefix: {
      cache: false,
      get: function () {
        return !!(this.prefixIcon || this.$slots.prefix || this.$scopedSlots.prefix);
      },
    },
    hasSuffix: {
      cache: false,
      get: function () {
        return this.loading || this.clearable || !!(this.suffixIcon || this.$slots.suffix || this.$scopedSlots.suffix);
      },
    },
    hasValue () {
      return (this.value === 0) || !!this.value;
    },
    inputValue () {
      return this.hasValue ? this.value : '';
    },
    inputLisenters () {
      const lisenters = Object.assign({}, this.$listeners, {
        input: this.handleInput,
        focus: this.handleFocus,
        blur: this.handleBlur,
        keyup: this.handleKeyup,
        compositionstart: this.handleComposition,
        compositionupdate: this.handleComposition,
        compositionend: this.handleComposition,
      });
      if (lisenters.change) {
        // it will trigger change event twice if not remove
        delete lisenters.change;
      }
      return lisenters;
    },
    canClear () {
      return this.clearable && !this.disabled &&
        (this.clearableOnReadonly || !this.readonly);
    },
    showClear () {
      return this.canClear &&
        this.hasValue && (this.focused || this.hovering);
    },
  },
  methods: {
    handleInput (event, options) {
      const { value } = event.target;
      if (value !== this.value) {
        this.$emit('input', value);
        if (!this.isComposing) {
          setTimeout(this.setNativeInput, 0);
        }
      }
      if (!this.isComposing || (options && options.change)) {
        this.$emit('change', value);
      }
    },
    handleClearClick (event) {
      this.$emit('clear');
      this.handleInput({ target: { value: '' } });
    },
    handlePrefixClick (e) {
      this.focus();
      this.$emit('click-prefix', e);
    },
    handleSuffixClick (e) {
      this.focus();
      this.$emit('click-suffix', e);
    },
    handleFocus (e) {
      this.focused = true;
      this.$emit('focus', e);
    },
    handleBlur (e) {
      this.focused = false;
      this.$emit('blur', e);
    },
    focus () {
      this.$refs.input.focus();
    },
    blur () {
      this.$refs.input.blur();
    },
    select () {
      this.$refs.input.select();
    },
    setNativeInput () {
      const { input } = this.$refs;
      if (input && input.value !== this.value) {
        input.value = this.inputValue;
      }
    },
    handleComposition (e) {
      const { type } = e;
      if (this.$listeners[type]) {
        this.$emit(type, e);
      }
      if (type === 'compositionend') {
        this.isComposing = false;
        this.handleInput(e, { change: true });
      } else {
        this.isComposing = true;
      }
    },
    handleKeyup (e) {
      if (this.$listeners.keyup) {
        this.$emit('keyup', e);
      }
      if (isKey(e, 'enter') && !this.isComposing) {
        this.$emit('enter', e);
      }
    },
  },
};
</script>
