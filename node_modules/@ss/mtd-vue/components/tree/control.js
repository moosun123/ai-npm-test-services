import createHoc from '@/utils/hoc';

function isControlled (context, propName) {
  return propName in context.$options.propsData;
}

export default function (name, component) {
  return createHoc({
    name,
    props: {
      data: {
        type: Array,
        default () {
          return [];
        },
      },
      checkedKeys: {
        type: Array,
        default () {
          return [];
        },
      },
      selectedKeys: {
        type: [Array, String],
        default () {
          return [];
        },
      },
      expandedKeys: {
        type: [Array, String],
        default () {
          return [];
        },
      },
      defaultExpandAll: {
        type: Boolean,
        default () {
          return false;
        },
      },
      nodeKey: {
        type: String,
        default () {
          return 'id';
        },
      },
      loadedKeys: {
        type: Array,
        default () {
          return [];
        },
      },
      props: {
        type: Object,
      },
    },
    data () {
      return {
        isCheckedControlled: isControlled(this, 'checkedKeys'),
        isSelectedControlled: isControlled(this, 'selectedKeys'),
        isExpandedControlled: isControlled(this, 'expandedKeys'),
        isLoadedControlled: isControlled(this, 'loadedKeys'),
        state: {
          checkedKeys: [],
          selectedKeys: [],
          expandedKeys: [],
          loadedKeys: [],
        },
      };
    },
    watch: {
      data: {
        immediate: true,
        handler (n, v) {
          if (!this.isExpandedControlled && this.defaultExpandAll) {
            this.state.expandedKeys = this.getDefaultExpandedKeys(this.data);
          }
        },
      },
    },
    computed: {
      checked () {
        return this.isCheckedControlled ? this.checkedKeys
          : this.state.checkedKeys;
      },
      selected () {
        return this.isSelectedControlled ? this.selectedKeys
          : this.state.selectedKeys;
      },
      expanded () {
        return this.isExpandedControlled ? this.expandedKeys
          : this.state.expandedKeys;
      },
      loaded () {
        return this.isLoadedControlled ? this.loadedKeys
          : this.state.loadedKeys;
      },
    },
    methods: {
      // private methods
      updateCheckedKeys (v) {
        this.state.checkedKeys = v;
        this.$emit('update:checkedKeys', v);
      },
      updateSelectedKeysKeys (v) {
        this.state.selectedKeys = v;
        this.$emit('update:selectedKeys', v);
      },
      updateExpandedKeys (v) {
        this.state.expandedKeys = v;
        this.$emit('update:expandedKeys', v);
      },
      updateLoadedKeys (v) {
        this.state.loadedKeys = v;
        this.$emit('update:loadedKeys', v);
      },
      getDefaultExpandedKeys (data) {
        const defaultExpandedKeys = [];
        if (data.length) {
          this.handleExpandedKeys(data, defaultExpandedKeys);
        }
        return defaultExpandedKeys;
      },
      handleExpandedKeys (source, target) {
        const childField = (this.props || {}).children || 'children';
        source.forEach((item, index) => {
          if (item[childField] && item[childField].length) {
            target.push(item[this.nodeKey]);
            this.handleExpandedKeys(item[childField], target);
          }
        });
      },

      // public methods
      getCheckedNodes (checkedStrategy) {
        const { wrappedInstance } = this.$refs;
        const cs = checkedStrategy === undefined ? wrappedInstance.checkedStrategy
          : checkedStrategy;
        return wrappedInstance.getCheckedNodes(wrappedInstance.root, cs);
      },
      getHalfCheckedNodes () {
        const { wrappedInstance } = this.$refs;
        return wrappedInstance.getHalfCheckedNodes();
      },
      getNode (key) {
        const { wrappedInstance } = this.$refs;
        return wrappedInstance.getNode(key);
      },
      filter (val) {
        this.$refs.wrappedInstance.filter(val);
      },
    },
  }, {
    mapStateToProps (context) {
      return {
        checkedKeys: context.checked,
        selectedKeys: context.selected,
        expandedKeys: context.expanded,
        loadedKeys: context.loaded,
        data: context.data,
        nodeKey: context.nodeKey,
        props: context.props,
      };
    },
    mapMethodToListener (context) {
      // warning 动态监听会造成错误
      const lisenter = {};
      if (!context.isCheckedControlled) {
        lisenter['update:checkedKeys'] = context.updateCheckedKeys;
      }
      if (!context.isSelectedControlled) {
        lisenter['update:selectedKeys'] = context.updateSelectedKeysKeys;
      }
      if (!context.isExpandedControlled) {
        lisenter['update:expandedKeys'] = context.updateExpandedKeys;
      }
      if (!context.isLoadedControlled) {
        lisenter['update:loadedKeys'] = context.updateLoadedKeys;
      }
      return lisenter;
    },
    withRef: true,
  })(component);
}
