

<script lang="ts">
import { Vue, Component, Prop } from 'vue-property-decorator';
import ConditionItem from './components/condition-item.vue';
import ConditionWrap from './components/condition-wrap.vue';

import { mixins } from 'vue-class-component';
import props from './mixin/props.vue';
import { isFunction } from './utils/index';
import _ from 'lodash';
@Component({
    components: {
        ConditionItem,
        ConditionWrap,
    },
})
export default class MpaConditionExpression extends mixins(props) {
    @Prop({
        type: [Object, Array],
        default: () => {
            return {};
        },
    })
    private conditionData;

    public validate() {
        const temp = this._validate(this.conditionData[this.childConditionListAttr]);
        const errorList: string[] = [];
        return Promise.all(
            temp.map(it => {
                return Promise.resolve(it.compInstance.validate());
            }),
        ).then(res => {
            res.forEach((it, index) => {
                errorList.push(it as string);
                let errorTxt = '';
                if (typeof it !== 'boolean') {
                    errorTxt = it as string;
                }
                this.$set(temp[index], 'error', errorTxt);
            });
            return errorList;
        });
    }

    public addRootCondition(condition) {
        if (this.conditionData && this.conditionData[this.childConditionListAttr]) {
            let tempCondition = condition;
            if (this.$attrs.showHeader) {
                tempCondition = Object.assign(condition, {
                    [this.childConditionListAttr]: condition[this.childConditionListAttr] || [],
                });
            }
            // 如果有类型
            if (condition.hasOwnProperty('type')) {
                // 如果找到该类型
                const index = this.conditionData[this.childConditionListAttr]
                    .findIndex(it => it.type === condition.type);
                if (index > -1) {
                    const currentType = this.conditionData[this.childConditionListAttr][index];
                    if (currentType.hasOwnProperty('comp')) {
                        this.conditionData[this.childConditionListAttr].splice(index, 1, {
                            type: currentType.type,
                            [this.conditionTypeAttr]: this.conditionOptions[0].value,
                            [this.childConditionListAttr]: [
                                currentType,
                                condition
                            ]
                        });
                    } else {
                        currentType[this.childConditionListAttr]
                            &&
                            currentType[this.childConditionListAttr].push(condition);
                    }
                } else {
                    this.conditionData[this.childConditionListAttr].push(tempCondition);
                }
            } else {
                this.conditionData[this.childConditionListAttr].push(tempCondition);
            }
        }
    }

    public getRootData() {
        return this.copyRootData(this.conditionData);
    }



    private get otherProps() {
        const $attrs = Object.assign({}, this.$attrs);
        delete $attrs.conditionData;
        return {
            ...$attrs,
            conditionOptions: this.conditionOptions,
            props: this.props,
            disabled: this.disabled,
            hoverAdd: this.hoverAdd,
            editHeader: this.editHeader,
            filterText: this.filterText,
            filterTextWidth: this.filterTextWidth,
            hoverLevel: this.hoverLevel,
            filterHeighLight: this.filterHeighLight,
            addChildButton: this.addChildButton,
            addChildButtonLevel: this.addChildButtonLevel
        };
    }

    private addCondition({ name = '', parentData, comp = '', root }) {
        const callback = params => {
            if (!root[this.childConditionListAttr]) {
                this.$set(root, this.childConditionListAttr, []);
                this.$set(
                    root,
                    this.conditionTypeAttr,
                    root[this.conditionTypeAttr] || this.conditionOptions[0].value,
                );
            }
            root[this.childConditionListAttr].push(params);
        };
        this.$emit('addCondition', { name, parentData, comp, callback });
    }

    private compChanged(val) {
        this.$emit('compChanged', val);
    }

    private deleteCondition() {
        const that = this;
        function deleteItem(root, parent, index) {
            if (Array.isArray(root[that.childConditionListAttr])) {
                root[that.childConditionListAttr].forEach((it, i) => {
                    deleteItem(it, root, i);
                });
                if (!root[that.childConditionListAttr].length) {
                    if (root.data && root.comp) {
                        delete root[that.childConditionListAttr];
                    } else {
                        parent && parent[that.childConditionListAttr].splice(index, 1);
                    }
                }
            }
        }
        deleteItem(this.conditionData, null, 0);
    }

    private createExpression(r, data, level, parent, index = 0, name = '') {
        if (data[this.childConditionListAttr]) {
            if (data.data && data.comp) {
                if (!data.uid) {
                    data.uid = _.uniqueId();
                }
                return [
                    r('div', { class: 'condition-wrap-filter' }, [
                        r('condition-item', {
                            props: {
                                parent,
                                index,
                                comp: data.comp,
                                propData: data.data,
                                parentName: name,
                                ...this.otherProps,
                            },
                            key: data.uid,
                            on: {
                                addCondition: this.addCondition,
                                deleteCondition: this.deleteCondition,
                                compChanged: this.compChanged,
                            },
                        }),
                        r(
                            'condition-wrap',
                            {
                                props: {
                                    isFilter: true,
                                    deepLevel: -1,
                                    childrenLen: data[this.childConditionListAttr]
                                        ? data[this.childConditionListAttr].length
                                        : 0,
                                    root: data,
                                    parent: data,
                                    index,
                                    ...this.otherProps,
                                },
                                on: {
                                    deleteCondition: this.deleteCondition,
                                },
                            },
                            data[this.childConditionListAttr].map((it, i) => {
                                return r('condition-wrap', {
                                    props: {
                                        // 如果是过滤条件时， 由于没有外层wrap嵌套， 所以这里的len设置为1
                                        childrenLen: 1,
                                        deepLevel: level + 1,
                                        root: it,
                                        index: i,
                                        parent: data,
                                        ...this.otherProps,
                                    },
                                    on: {
                                        deleteCondition: this.deleteCondition,
                                        addCondition: this.addCondition,
                                    }
                                }, [this.createExpression(r, it, level + 1, data, i, '')]);
                            }),
                        ),
                    ]),
                ];
            } else {
                return data[this.childConditionListAttr].map((it, i) => {
                    const computedName = isFunction(it.name)
                        ? it.name.call(null, i)
                        : it.name || name;
                    return r(
                        'condition-wrap',
                        {
                            props: {
                                childrenLen:
                                    it.data && it.comp
                                        ? 1
                                        : it[this.childConditionListAttr]
                                        ? it[this.childConditionListAttr].length
                                        : 0,
                                deepLevel: level + 1,
                                parent: data,
                                index: i,
                                root: it,
                                name: computedName,
                                ...this.otherProps,
                            },
                            on: {
                                addCondition: this.addCondition,
                            }
                        },
                        this.createExpression(r, it, level + 1, data, i, computedName),
                    );
                });
            }
        } else {
            if (!data.uid) {
                data.uid = _.uniqueId();
            }
            return [
                r('condition-item', {
                    props: {
                        parent,
                        index,
                        comp: data.comp,
                        propData: data.data,
                        parentName: name,
                        ...this.otherProps,
                    },
                    key: data.uid,
                    on: {
                        addCondition: this.addCondition,
                        deleteCondition: this.deleteCondition,
                        compChanged: this.compChanged,
                    },
                }),
            ];
        }
    }

    private render(r) {
        return r(
            'div',
            {
                class: 'mpa-condition-expression',
            },
            [
                r(
                    'condition-wrap',
                    {
                        props: {
                            childrenLen: this.conditionData[this.childConditionListAttr]
                                ? this.conditionData[this.childConditionListAttr].length
                                : 0,
                            root: this.conditionData,
                            ...this.otherProps,
                        },
                        scopedSlots: {
                            addGroups: props => this.$slots.addGroups,
                        }
                    },
                    this.createExpression(r, this.conditionData, 1, this.conditionData),
                ),
            ],
        );
    }

    private _validate(list) {
        const temp: any = [];
        if (Array.isArray(list)) {
            list.forEach(it => {
                if (it[this.childConditionListAttr]) {
                    if (it.data && it.comp) {
                        temp.push(it);
                    }
                    temp.push(...this._validate(it[this.childConditionListAttr]));
                } else {
                    temp.push(it);
                }
            });
        }
        return temp;
    }

    private copyRootData(root) {
        const copy = Object.create(null);
        for (const key in root) {
            if (root.hasOwnProperty(key) && (key !== 'compInstance' && key !== 'uid')) {
                if (key === this.childConditionListAttr && Array.isArray(root[key])) {
                    copy[key] = root[key].map(it => {
                        return this.copyRootData(it);
                    });
                } else {
                    copy[key] = _.cloneDeep(root[key]);
                }
            }
        }
        return copy;
    }

}
</script>
