<template>
<Popper tag="div" :visible="open" @update:visible="handleOpenChange"
  :class="[
    wrapperClasses,
    (type === 'time' && timePlace === 'right') ? 'mpa-date-picker-right-time-wrap' : '',
  ]"
  :placement="placement" trigger="click"
  :popper-disabled="disabled"
  :toggle-on-reference-click="false"
  :append-to-container="appendToContainer"
  :get-popup-container="getPopupContainer"
  :popper-options="popperOptions"
  ref="popper"
>
  <Reference>
    <PickerInput :id="elementId" v-if="!(type === 'time' && timePlace === 'right')"
      :class="[prefix + '-editor']"
      :readonly="type === 'week' || (!editable || readonly)"
      :disabled="disabled"
      :size="_size"
      :placeholder="placeholder"
      :current-value="visualValue"
      :name="name"
      :clearable="clearable"
      clearable-on-readonly
      ref="input"
      :suffix-icon="suffixIcon"
      :invalid="invalid"
      :loading="loading"
      :genre="genre"
      @input="handleInputChange"
      @clear="handleClear"
      @focus="handleInputFocus"
      @blur="handleInputBlur"
      @enter="handleInputEnter"
    />
  </Reference>
  <Drop :class="[
    popperClass
  ]">
    <component
      :is="panel"
      ref="pickerPanel"
      :show-time="isTime && timePlace === 'default'"
      :default-time="defaultTime"
      :show-btn-now="showBtnNow"
      :confirm="needConfirm"
      :selection-mode="selectionMode"
      :steps="steps"
      :format="format"
      :holidays="holidays"
      :value="panelValue"
      :start-date="startDate"
      :split-panels="splitPanels"
      :show-week-numbers="showWeekNumbers"
      :work-cell-icon="workCellIcon"
      :iso-week="isoWeek"
      :week-start="weekStart"
      :week-year-first-start="weekYearFirstStart"
      :picker-type="type"
      :multiple="multiple"
      :focused-date="focusedDate"
      :visible="open"
      :time-place="timePlace"
      :time-picker-options="timePickerOptions"
      v-bind="ownPickerProps"
      @pick="onPick"
      @pick-click-now="handleClickNow"
      @pick-success="onPickSuccess"
      @pick-range="handlePickRange"
      @pick-time-range="handleTimeRange"
      @cancel="handleCancel"
      @current-view-change="updatePopper"
      @panel-change="handlePanelChange"
    >
      <slot name="shortcuts" slot="shortcuts" />
      <template slot-scope="scope" slot="cell">
        <slot :cell="scope.cell" name="cell">{{ scope.cell.desc }}</slot>
      </template>
      <template slot-scope="scope" slot="weekCell">
        <slot :cell="scope.cell" name="weekCell">{{ scope.cell.desc }}</slot>
      </template>
      <template slot="confirm" v-if="$slots.confirm">
        <slot name="confirm" />
      </template>
    </component>
  </Drop>
</Popper>
</template>
<script>
import {
  CONFIG_PROVIDER,
  getPrefixCls,
  getIconCls,
  getSize,
} from '../../utils/config';
import {
  Popper,
  Drop,
  Reference,
} from '../popper';
import {
  DEFAULT_FORMATS,
  RANGE_SEPARATOR,
  TYPE_VALUE_RESOLVER_MAP,
  updateDayjsLocaleConfig
} from '../../utils/date';
import {
  isDate,
  isString,
  isArray,
  isValidDate,
} from '../../utils/type';
import {
  HolidayCalendarRange
} from '../../utils/specialDayRange';
import { hasProps } from '../../utils/vnode';

import Input from './input.js';
import { isNumber } from 'lodash';
import dayjs from 'dayjs';

const isEmptyArray = (val) => {
  return val.reduce((isEmpty, str) => {
    return isEmpty && (!str ||
      (typeof str === 'string' && str.trim() === ''));
  }, true);
};

function eql(a, b) {
  const aValue = JSON.stringify(a);
  const bValue = JSON.stringify(b);
  return (!a && !b) || (aValue === bValue && typeof a === typeof b);
}

function arrayEql(a, b) {
  return (a === b) || (a && b && (a.length === b.length && a.every((v1, i) => {
    const v2 = b[i];
    return (!v1 && !v2) || v1 === v2;
  })));
}

export default {
  componentName: 'MpaDatePicker',
  components: {
    Popper,
    Drop,
    Reference,
    PickerInput: Input,
  },
  props: {
    type: {
      type: String,
      default: 'date',
    },
    format: {
      type: String,
    },
    valueFormat: {
      // 如果没有配置则默认按照当前 value 属性推断
      type: String,
    },
    holidays: {
      type: Object,
    },
    readonly: {
      type: Boolean,
      default: false,
    },
    editable: {
      type: Boolean,
      default: true,
    },
    disabled: {
      type: Boolean,
      default: false,
    },
    clearable: {
      type: Boolean,
      default: false,
    },
    confirm: {
      type: Boolean,
      default: false,
    },
    open: {
      type: Boolean,
      default: null,
    },
    multiple: {
      type: Boolean,
      default: false,
    },
    timePlace: {
      type: String,
      default: 'default',
    },
    timePickerOptions: {
      default: () => ({}),
      type: Object,
    },
    splitPanels: {
      type: Boolean,
      default: true,
    },
    workCellIcon: {
      type: Boolean,
      default: false,
    },
    showWeekNumbers: {
      type: Boolean,
      default: false,
    },
    isoWeek: {
      type: Boolean,
      default: false,
    },
    startDate: {
      type: Date,
    },
    size: {
      type: String,
    },
    placeholder: {
      type: String,
      default: '',
    },
    placement: {
      type: String,
    },
    name: {
      type: String,
    },
    elementId: {
      type: String,
    },
    steps: {
      type: Array,
      default: () => [],
    },
    value: {
      type: [Date, String, Array, Number],
    },
    options: {
      type: Object,
      default: () => ({}),
    },
    icon: String,
    appendToContainer: {
      type: Boolean,
      default: true,
    },
    getPopupContainer: Function,
    invalid: Boolean,
    loading: Boolean,
    genre: String,
    showBtnNow: {
      type: Boolean,
      default: true,
    },
    popperClass: String,

    defaultTime: {
      type: [Array, String],
    },
    popperOptions: Object,
    formatter: Function,
    weekStart: {
      type: Number,
      default: 1,
      validator(v) {
        return v >= 0 && v <= 6;
      },
    },
    weekYearFirstStart: {
      type: Boolean,
      default: true,
    },
  },
  provide() {
    return {
      CalendarPicker: this,
    };
  },
  inject: {
    config: {
      from: CONFIG_PROVIDER,
      default: {
        getPrefixCls,
        getIconCls,
        getSize,
      },
    },
  },
  data() {
    const { value } = this;
    // 不可抽成 computed 属性，computed 在 data 之后赋值
    const isRange = this.isRange();
    const emptyArray = isRange ? [null, null] : [null];
    let initialValue;
    let offsetType = false;
    let offsetValue = 0;
    if (isNumber(value)) {
      initialValue = [dayjs(new Date()).add(value, 'd').toDate()];
      offsetType = true;
      offsetValue = value;
    } else {
      initialValue = isEmptyArray(
        (isRange ? value : [value]) || [],
      ) ? emptyArray
        : this.parseDate(value);
    }
    return {
      offsetType,
      offsetValue,
      internalValue: initialValue,
      selectionMode: this.onSelectionModeChange(this.type),
      isFocused: false,
      focusedDate: (isValidDate(initialValue[0]) && initialValue[0]) ||
        this.startDate || new Date(),
      selecting: false, // 目前仅用在 timerange 中，表示是否在选择中
    };
  },
  computed: {
    isTime() {
        return this.type === 'datetime' || this.type === 'datetimerange' || this.type === 'singledatetimerange';
    },
    prefix() {
      return this.config.getPrefixCls('date-picker');
    },
    _size() {
      return this.config.getSize(this);
    },
    iconPrefix() {
      return this.config.getIconCls;
    },
    wrapperClasses() {
      return [this.prefix, {
        [this.prefix + '-focused']: this.isFocused,
      }];
    },
    visualValue() {
      let text = this.formatDate(this.internalValue);
      if (this.formatter) {
        return this.formatter(this.value, text) || '';
      }
      if (this.offsetType && isNumber(this.offsetValue)) {
        if (this.offsetValue < 0) {
          text = `${text}（${-this.offsetValue}天前）`;
        } else if (this.offsetValue > 0) {
          text = `${text}（${this.offsetValue}天后）`;
        } else if (this.offsetValue === 0) {
          text = `${text}（今天）`;
        }
      }
      return text;
    },
    publicVModelValue() {
      if (this.multiple) {
        return this.internalValue.slice();
      } else {
        const isRange = this.isRange();
        const val = this.internalValue.map((date) => {
          return isDate(date) ? new Date(date) : (date || '');
        });
        return isRange ? val : val[0];
      }
    },
    needConfirm() {
      return this.confirm ||
        (['datetime', 'datetimerange'].indexOf(this.type) > -1) ||
        this.multiple;
    },
    suffixIcon() {
      return hasProps(this, 'icon') ? this.icon
        : ((['time', 'timerange'].indexOf(this.type) > -1) ? this.iconPrefix('time-o')
          : this.iconPrefix('calendar-o'));
    },
    shouldFormatValue() {
      return isArray(this.value) ? isString(this.value[0])
        : isString(this.value);
    },
    panelValue() {
      // internalValue 可能会包含非法的 Date
      return this.internalValue.map((v) => {
        return isValidDate(v) ? v : null;
      });
    },
  },
  watch: {
    value(val, oldVal) {
      if (isNumber(oldVal) && isDate(val) && this.offsetType === true) {
        val = oldVal;
        this.offsetValue = val;
      }
      if (val instanceof Date || val instanceof Array) {
        this.internalValue = this.parseDate(val);
      }
      if (isNumber(val)) {
        this.offsetType = true;
        this.offsetValue = val;
      }
    },
    type(type, oldType) {
      this.onSelectionModeChange(type, oldType);
    },
    publicVModelValue(now, before) {
      if (this.selecting) {
        return;
      }
      const arrayValue = isArray(now) ? now : [now];
      const parseValues = this.parseDate(this.value);
      const shouldEmitInput = !arrayEql(arrayValue, parseValues) && !eql(now, this.value) &&
        !eql(arrayValue, parseValues) && !eql(now, before);
      if (shouldEmitInput) {
        const inputValue = this.formatToInput(now);
        // 携带节假日信息参数方便业务判断
        this.$emit('input', inputValue, HolidayCalendarRange);
        this.$emit('change', inputValue, HolidayCalendarRange);
      }
    },
    selecting(now, before) {
      if (before && !now) {
        const parseValues = this.parseDate(this.value);
        const shouldEmitInput = !arrayEql(this.internalValue, parseValues);
        if (shouldEmitInput) {
          const sortedDates = this.publicVModelValue.sort((a, b) => a.getTime() - b.getTime());
          const inputValue = this.formatToInput(sortedDates);
          this.$emit('input', inputValue, HolidayCalendarRange);
          this.$emit('change', inputValue, HolidayCalendarRange);
        }
      }
    },
    open(now, old) {
      if (now) {
        this.onSelectionModeChange(this.type);
        this.reset();
      }
    },
  },
  created() {
    updateDayjsLocaleConfig(this.focusedDate, this.weekStart, this.weekYearFirstStart, this.isoWeek);
  },
  mounted() {
    this.$on('focus-input', () => this.focus());
  },
  methods: {
    isRange() {
      return this.type.indexOf('range') > -1 || ['workday', 'weekends', 'holiday', 'holidayrange'].includes(this.type);
    },
    handlePanelChange(panelDate, panelType) {
      this.$emit('panel-change', panelDate, panelType);
    },
    formatToInput(date) {
      const isRange = this.isRange();
      if (this.multiple || isRange) {
        if (!isArray(date)) date = [date];
        return (date || []).map(this.formatValue)
          .filter((d) => this.valueFormat ? !!d : d !== undefined);
      }
      return this.formatValue(date);
    },
    formatValue(date) {
      if (this.valueFormat === 'timestamp') {
        return date ? date.getTime() : undefined;
      } else if (this.valueFormat || this.shouldFormatValue) {
        return this.formatDate(date, this.valueFormat || this.format);
      } else {
        return date || undefined;
      }
    },
    handleOpenChange(v) {
      if (this.readonly || this.disabled) {
        return;
      }
      this.$emit('update:open', v);
      if (v) {
        this.$emit('focus');
      } else {
        this.selecting = false;
        this.$emit('blur');
      }
    },
    handleInputFocus() {
      this.isFocused = true;
    },

    handleInputBlur() {
      this.isFocused = false;
    },
    handleInputEnter() {
      this.handleOpenChange(false);
    },
    onSelectionModeChange(type, oldType) {
      if (this.readonly || this.disabled) {
        return;
      }
      this.resetValue(type, oldType);
      if (type.match(/^date/) || type.match(/^week/) || type.match(/^holidayrange/)) type = 'date';
      if (type.match(/^month/)) type = 'month';
      if (type.match(/^holiday/)) type = 'holiday';
      if (['year', 'halfyear',  'quarter', 'month', 'date', 'time'].indexOf(type) > -1) {
        this.selectionMode = type;
      }
      if (type === 'quarterrange') {
        this.selectionMode = 'quarter';
      }
      if (type === 'halfyearrange') {
        this.selectionMode = 'halfyear';
      }
      if (type === 'yearrange') {
        this.selectionMode = 'year';
      }
      if (type === 'holiday') {
        this.selectionMode = 'holiday';
      }
      this.$nextTick(this.updatePopper);
      return this.selectionMode;
    },
    resetValue(type, oldType) {
      if (oldType && type && oldType !== type) {
        const typeChange =
          ((type.indexOf('range') > -1 || ['workday', 'weekends', 'holiday'].includes(type)) &&
        !(oldType.indexOf('range') > -1 || ['workday', 'weekends', 'holiday'].includes(oldType))) ||
          (!(type.indexOf('range') > -1 || ['workday', 'weekends', 'holiday'].includes(type)) &&
          (oldType.indexOf('range') > -1 || ['workday', 'weekends', 'holiday'].includes(oldType)))
        ;
        let resetValue;
        if (!Array.isArray(this.value)) {
          resetValue = [this.value];
        } else {
          resetValue = this.value;
        }
        // 都为 range 或都为非 range 可不强制处理默认
        if (typeChange) {
          // 值非法时处理默认
          if (this.isRange()) {
            if (resetValue.length < 2) {
              this.internalValue = [null, null];
            } else {
              this.internalValue = resetValue;
            }
          } else {
            if (resetValue.length > 1) {
              this.internalValue = [null];
            } else {
              this.internalValue = resetValue;
            }
          }
        } else {
          this.internalValue = resetValue;
        }
      }
    },
    reset() {
      this.$refs.pickerPanel && this.$refs.pickerPanel.reset &&
        this.$refs.pickerPanel.reset();
    },
    handleInputChange(newValue) {
      const oldValue = this.formatDate(this.internalValue);
      const newDate = this.parseDate(newValue, true);
      const disabledDateFn = this.options &&
        typeof this.options.disabledDate === 'function' &&
        this.options.disabledDate;
      const isValidDate = newDate.reduce((valid, date) => {
        return valid && date instanceof Date && !isNaN(date.getTime());
      }, true);
      if (!isValidDate) {
        return;
      }

      const isDisabled = disabledDateFn && newDate.some(disabledDateFn);
      if (newValue !== oldValue && !isDisabled) {
        this.internalValue = newDate.sort((a, b) => a.getTime() - b.getTime());
      }
    },
    handleClickNow() {
      const dates = this.multiple ? new Date()
        : this.internalValue.map(() => new Date());
      this.$emit('click-now');
      this.onPick(dates);
      this.handleOpenChange(false);
    },
    handleClear() {
      this.$emit('clear');
      this.offsetType = false;
      this.offsetValue = 0;
      this.internalValue = this.internalValue.map(() => '');
    },
    handlePickRange(rangeState) {
      this.$emit('pick-range', rangeState);
    },
    // 格式化 val 为 Date[]
    // 当为输入框手动输入内容时，将强制使用 format 进行格式化
    parseDate(val, forceFormat) {
      const { type, valueFormat } = this;
      const isRange = this.isRange();
      if (!isRange && Array.isArray(val) && val.length > 1) {
        val = val[0];
      }
      if (!forceFormat && valueFormat === 'timestamp') {
        if (isRange && (!val || !val.length)) {
          val = [null, null];
        } else if (!isArray(val)) {
          val = [val];
        }
        return val.map((v) => v ? new Date(parseInt(v)) : v);
      }
      const parser = (
        TYPE_VALUE_RESOLVER_MAP[type] ||
        TYPE_VALUE_RESOLVER_MAP['default']
      ).parser;
      const format = this.valueFormat || this.format || DEFAULT_FORMATS[type];
      const multipleParser = TYPE_VALUE_RESOLVER_MAP['multiple'].parser;
      if (this.multiple && val) {
        val = multipleParser(val, format);
      } else if (isRange) {
        if (!val) {
          val = [null, null];
        } else {
          if (typeof val === 'string') {
            val = parser(val, format);
          } else if (Array.isArray(val)) {
            const [start, end] = val;
            if (!start || !end) {
              val = [null, null];
            } else if (isDate(start) && isDate(end)) {
              val = val.map(date => new Date(date));
            } else if (isString(start) && isString(end)) {
              val = parser(val.join(RANGE_SEPARATOR), format);
            }
          }
        }
      } else if (val && !isDate(val)) {
        val = parser(val, format) || null;
      }
      return (isRange || this.multiple) ? (val || []) : [val];
    },
    formatDate(value, format = this.format) {
      if (this.offsetType && value && value.length && value[0] === undefined) {
          value[0] = dayjs(new Date()).toDate();
      }
      const defaultFormat = DEFAULT_FORMATS[this.type];
      if (this.multiple) {
        const formatter = TYPE_VALUE_RESOLVER_MAP.multiple.formatter;
        return formatter(isArray(value) ? value : [value],
          format || defaultFormat,
          { weekStart: this.weekStart, weekYearFirstStart: this.weekYearFirstStart, isoWeek: this.isoWeek });
      } else {
        const {formatter} = (
          TYPE_VALUE_RESOLVER_MAP[this.type] ||
          TYPE_VALUE_RESOLVER_MAP['default']
        );
        return formatter(value, format ||
          defaultFormat,
          { weekStart: this.weekStart, weekYearFirstStart: this.weekYearFirstStart, isoWeek: this.isoWeek });
      }
    },
    onPick(dates, visible = false) {
      if (isArray(dates)) {
        if (dates[0].offset) {
          dates = dates.sort((a, b) => a.offset - b.offset);
          dates = dates.map((a) => dayjs().add(a.offset, a.granularity).toDate());
        } else {
          dates = dates.sort((a, b) => a.getTime() - b.getTime());
        }
      }
      if (this.multiple) {
        this.offsetType = false;
        this.offsetValue = 0;
        const pickedTimeStamp = dates.getTime();
        const indexOfPickedDate = this.internalValue.findIndex((date) => {
          return date && date.getTime() === pickedTimeStamp;
        });
        const allDates = [...this.internalValue, dates].filter(Boolean);
        // filter away duplicates
        const timeStamps = allDates.map(date => date.getTime())
          .filter((ts, i, arr) => {
            return arr.indexOf(ts) === i && i !== indexOfPickedDate;
          });
        this.internalValue = timeStamps.map(ts => new Date(ts));
      } else {
        this.internalValue = Array.isArray(dates) ? dates : [dates];
      }
      if (this.internalValue[0] || isNumber(this.internalValue[0])) {
        if (this.multiple) {
          this.focusedDate = this.internalValue[this.internalValue.length - 1] || this.internalValue[0];
        } else {
          if (isNumber(this.internalValue[0])) {
            this.offsetType = true;
            this.offsetValue = this.internalValue[0];
            this.focusedDate = dayjs(new Date()).add(this.internalValue[0], 'd').toDate();
          } else {
            this.focusedDate = this.internalValue[0];
            this.offsetType = false;
            this.offsetValue = 0;
          }
        }
      }
      // reset the selectionMode
      if (!this.needConfirm) {
        this.onSelectionModeChange(this.type);
        if (this.open !== visible) {
          this.handleOpenChange(visible);
        }
      }
    },
    onPickSuccess() {
      this.$emit('confirm');
      this.handleOpenChange(false);
      this.reset();
    },
    handleTimeRange(value) {
      this.selecting = true;
      this.internalValue = value;
    },
    handleCancel() {
      this.internalValue = this.parseDate(this.value);
      this.handleOpenChange(false);
    },
    focus() {
      if (this.editable) {
        this.$refs.input.focus();
      }
      this.handleOpenChange(true);
    },
    blur() {
      this.$refs.input.blur();
      this.handleOpenChange(false);
    },
    updatePopper() {
      this.$nextTick(() => {
        const { open } = this;
        const { popper } = this.$refs;
        if (open && popper) {
          popper.updatePopper();
        }
      });
    },
  },
};
</script>


<style lang="scss"></style>
